
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>ფლეშ დაშიფვრა — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js" type="text/javascript"></script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../about.html" rel="author" title="About these documents"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="../api-guides/freertos-smp.html" rel="next" title="ESP-IDF FreeRTOS SMP Changes"/>
<link href="../api-guides/fatal-errors.html" rel="prev" title="Fatal Errors"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/security/flash-encryption.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "security/flash-encryption"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/security/flash-encryption.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api-guides/index.html">API სახელმძღვანელოები</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../api-guides/app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/blufi.html">BluFi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/bootloader.html">ჩატვირთვის სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/build-system.html">სისტემის შექმნა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/build-system-legacy.html">სისტემის შექმნა (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/console.html">კონსოლის კომპონენტი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/deep-sleep-stub.html">ღრმა ძილის გაღვიძების სტატიები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/error-handling.html">შეცდომების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/esp-ble-mesh/ble-mesh-index.html">ESP-BLE-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/mesh.html">ESP-MESH ( Wi-Fi )</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/core_dump.html">ESP32 ბირთვის ნაგავსაყრელი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/event-handling.html">მოვლენების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/external-ram.html">გარე SPI-თან დაკავშირებული ოპერატიული მეხსიერება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/fatal-errors.html">ფატალური შეცდომები</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="flash-encryption.html#">ფლეშ დაშიფვრა</a><ul>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#introduction">შესავალი</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#efuse-used-during-flash-encryption-process">eFuse გამოყენებულია Flash დაშიფვრის პროცესში</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#flash-encryption-process">ფლეშ დაშიფვრის პროცესი</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#steps-to-setup-flash-encryption">ფლეშ დაშიფვრის დაყენების ნაბიჯები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#development-mode">განვითარების რეჟიმი</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#using-esp32-generated-flash-encryption-key">ESP32-ის მიერ გენერირებული ფლეშ დაშიფვრის გასაღების გამოყენება</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#encrypt-multiple-partitions">მრავალი დანაყოფის დაშიფვრა</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#using-host-generated-flash-encryption-key">მასპინძლის მიერ გენერირებული ფლეშ დაშიფვრის გასაღების გამოყენება</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#release-mode">გამოშვების რეჟიმი</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#possible-failures">შესაძლო წარუმატებლობები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#key-points-about-flash-encryption">ფლეშ დაშიფვრის შესახებ ძირითადი პუნქტები</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#using-encrypted-flash">დაშიფრული ფლეშ მეხსიერების გამოყენება</a><ul>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#scope-of-flash-encryption">ფლეშ დაშიფვრის ფარგლები</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#reading-encrypted-flash">დაშიფრული ფლეშის წაკითხვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#writing-encrypted-flash">დაშიფრული ფლეშის ჩაწერა</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#updating-encrypted-flash">დაშიფრული ფლეშ მეხსიერების განახლება</a><ul>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#ota-updates">OTA განახლებები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#disabling-flash-encryption">ფლეშ დაშიფვრის გამორთვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#limitations-of-flash-encryption">ფლეშ დაშიფვრის შეზღუდვები</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#flash-encryption-and-secure-boot">ფლეშ დაშიფვრა და უსაფრთხო ჩატვირთვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#flash-encryption-advanced-features">ფლეშ დაშიფვრის გაფართოებული ფუნქციები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#encrypted-partition-flag">დაშიფრული დანაყოფის დროშა</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#enabling-uart-bootloader-encryption-decryption">UART Bootloader-ის დაშიფვრის/გაშიფვრის ჩართვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#setting-flash-crypt-config">FLASH_CRYPT_CONFIG-ის დაყენება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="flash-encryption.html#technical-details">ტექნიკური დეტალები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="flash-encryption.html#flash-encryption-algorithm">ფლეშ დაშიფვრის ალგორითმი</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/freertos-smp.html">უფასო RTOS SMP ცვლილებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/general-notes.html">ზოგადი შენიშვნები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/hlinterrupts.html">მაღალი დონის შეფერხებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/jtag-debugging/index.html">JTAG-ის გამართვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/linker-script-generation.html">ლინკერის სკრიპტის გენერირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/lwip.html">lwIP TCP/IP სტეკი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/partition-tables.html">დანაყოფის ცხრილები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/RF_calibration.html">რადიოსიხშირული კალიბრაცია</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/romconsole.html">ROM გამართვა კონსოლი</a></li>
<li class="toctree-l2"><a class="reference internal" href="secure-boot.html">უსაფრთხო ჩატვირთვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/thread-local-storage.html">ძაფების ლოკალური საცავი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/tools/index.html">ხელსაწყოები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/ulp.html">ULP კოპროცესორი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/ulp-legacy.html">ULP კოპროცესორი (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/unit-tests-legacy.html">ერთეულის ტესტირება (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/unit-tests.html">ერთეულის ტესტირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api-guides/wifi.html">WiFi დრაივერი</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../index.html">დოკუმენტები</a> »</li>
<li><a href="../api-guides/index.html">API სახელმძღვანელოები</a> »</li>
<li>ფლეშ დაშიფვრა</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/security/flash-encryption.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="flash-encryption">
<h1>ფლეშ დაშიფვრა<a class="headerlink" href="flash-encryption.html#flash-encryption" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/security/flash-encryption.html">[中文]</a></p>
<p>ეს დოკუმენტი წარმოადგენს ESP32-ზე Flash დაშიფვრის კონცეფციის შესავალს და აჩვენებს, თუ როგორ შეიძლება ამ ფუნქციის გამოყენება მომხმარებლის მიერ შემუშავების, ასევე წარმოების დროს, ნიმუშის მაგალითის გამოყენებით. დოკუმენტის ძირითადი მიზანია იყოს სწრაფი დაწყების სახელმძღვანელო ფლეშ მეხსიერება დაშიფვრის ოპერაციების შესამოწმებლად და დასადასტურებლად. ფლეშ მეხსიერება დაშიფვრის ბლოკის დეტალები შეგიძლიათ იხილოთ შემდეგში: <a class="reference external" href="https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf">ESP32 ტექნიკური საცნობარო სახელმძღვანელო</a>.</p>
<div class="section" id="introduction">
<h2>შესავალი<a class="headerlink" href="flash-encryption.html#introduction" title="Permalink to this headline">¶</a></h2>
<p>ფლეშ დაშიფვრა არის ფუნქცია ESP32-ზე მიმაგრებული SPI ფლეშ მეხსიერება ის შინაარსის დაშიფვრისთვის. როდესაც ფლეშ მეხსიერება დაშიფვრა ჩართულია, SPI ფლეშ მეხსიერება ის ფიზიკური წაკითხვა არ არის საკმარისი ფლეშ მეხსიერება შინაარსის უმეტესობის აღსადგენად. დაშიფვრა გამოიყენება ფლეშ მეხსიერება მიერ ESP32-ში ტექსტური მონაცემების გამოყენებით და (თუ დაშიფვრა ჩართულია) ჩამტვირთავი შიფრავს მონაცემებს პირველი ჩატვირთვისას.</p>
<p>ფლეშ მეხსიერება დაშიფვრის ჩართვის შემთხვევაში, შემდეგი ტიპის ფლეშ მეხსიერება მონაცემები ნაგულისხმევად დაშიფრულია:</p>
<blockquote>
<div><ul class="simple">
<li>ჩატვირთვის სისტემა</li>
<li>დაყოფის ცხრილი</li>
<li>ყველა „აპლიკაციის“ ტიპის დანაყოფი</li>
</ul>
<p>ფლეშ მეხსიერება მონაცემების სხვა ტიპები პირობითად დაშიფრულია:</p>
<ul class="simple">
<li>უსაფრთხო ჩატვირთვა ჩამტვირთავი დაიჯესტი (თუ უსაფრთხო ჩატვირთვა ჩართულია)</li>
<li>დანაყოფების ცხრილი ში „დაშიფრული“ დროშით მონიშნული ნებისმიერი დანაყოფი</li>
</ul>
</div></blockquote>
<p>ფლეშ დაშიფვრა ცალკეა <a class="reference internal" href="secure-boot.html"><span class="doc">უსაფრთხო ჩატვირთვა</span></a> ფუნქცია და შეგიძლიათ გამოიყენოთ ფლეშ მეხსიერება დაშიფვრა უსაფრთხო ჩატვირთვის ჩართვის გარეშე. თუმცა, უსაფრთხო გარემოსთვის ორივე ერთდროულად უნდა გამოიყენოთ.</p>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">საწარმოო გამოყენებისთვის, ფლეშ მეხსიერება დაშიფვრა უნდა იყოს ჩართული მხოლოდ „გამოშვების“ რეჟიმში.</p>
</div>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">ფლეშ მეხსიერება დაშიფვრის ჩართვა ზღუდავს ESP32-ის შემდგომი განახლებების ვარიანტებს. აუცილებლად წაიკითხეთ ეს დოკუმენტი (მათ შორის <a class="reference internal" href="flash-encryption.html#flash-encryption-limitations"><span class="std std-ref">ფლეშ დაშიფვრის შეზღუდვები</span></a>) და გაიგონ ფლეშ მეხსიერება დაშიფვრის ჩართვის შედეგები.</p>
</div>
</div>
<div class="section" id="efuse-used-during-flash-encryption-process">
<span id="flash-encryption-efuse"></span><h2>eFuse გამოყენებულია Flash დაშიფვრის პროცესში<a class="headerlink" href="flash-encryption.html#efuse-used-during-flash-encryption-process" title="Permalink to this headline">¶</a></h2>
<p>ფლეშ მეხსიერება დაშიფვრის ოპერაცია კონტროლდება ESP32-ზე ხელმისაწვდომი სხვადასხვა eFuse-ებით. ქვემოთ მოცემულია eFuse-ების სია და მათი აღწერა:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">eFuse</span>                 <span class="n">Description</span>                             <span class="n">Can</span> <span class="n">be</span> <span class="n">locked</span> <span class="k">for</span>   <span class="n">Default</span>
                                                              <span class="n">reading</span><span class="o">/</span><span class="n">writing</span>     <span class="n">Value</span>
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Coding scheme         This 2 bit wide eFuse controls the          Yes              0
                      actual number of bits to be used
                      from BLOCK1 to derive final 256 bit
                      AES key. The coding scheme value is
                      decoded as below:
                      0: 256 bits
                      1: 192 bits
                      2: 128 bits
                      Final AES key is derived based on the
                      FLASH_CRYPT_CONFIG value

BLOCK1                256 bit wide eFuse block for storing        Yes              x
                      AES key

FLASH_CRYPT_CONFIG    4 bit wide eFuse which controls the         Yes              0xF
                      AES encryption process

download_dis_encrypt  When set, disables the flash encryption     Yes              0
                      operation while running in UART
                      download mode

download_dis_decrypt  When set, disables the flash decryption     Yes              0
                      operation while running in UART
                      download mode

FLASH_CRYPT_CNT       7 bit eFuse which enables/disables          Yes              0
                      encryption at boot time

                      Even number of bits set (0, 2, 4, 6):
                      encrypt flash at boot time
                      Odd number of bits set (1, 3, 5, 7): do
                      not encrypt flash at boot time
</pre></div>
</div>
</div></blockquote>
<p>ზემოთ მოცემულ ბიტებზე წაკითხვისა და ჩაწერის წვდომა კონტროლდება შესაბამისი ბიტებით. <code class="docutils literal notranslate"><span class="pre">efuse_wr_disable</span></code> და <code class="docutils literal notranslate"><span class="pre">efuse_rd_disable</span></code> რეგისტრები. ESP32 eFuse-ის შესახებ დამატებითი ინფორმაციის მოძიება შესაძლებელია შემდეგ ბმულზე: <a class="reference internal" href="../api-reference/system/efuse.html"><span class="doc">eFuse მენეჯერი</span></a>.</p>
</div>
<div class="section" id="flash-encryption-process">
<h2>ფლეშ დაშიფვრის პროცესი<a class="headerlink" href="flash-encryption.html#flash-encryption-process" title="Permalink to this headline">¶</a></h2>
<p>თუ ვივარაუდებთ, რომ eFuse მნიშვნელობები ნაგულისხმევ მდგომარეობაშია და მეორე ეტაპი ჩამტვირთავი არის კომპილაცია d, რომელიც მხარს უჭერს ფლეშ მეხსიერება დაშიფვრას, ფლეშ მეხსიერება დაშიფვრის პროცესი სრულდება შემდეგნაირად:</p>
<ul class="simple">
<li>პირველი ჩართვისას გადატვირთვისას, ფლეშ მეხსიერება ში არსებული ყველა მონაცემი დაუშიფრავია (უბრალო ტექსტი). პირველი ეტაპის ჩამტვირთავი (ROM) IRAM-ში მეორე ეტაპის ჩამტვირთავს.</li>
<li>მეორე ეტაპი ჩამტვირთავი წაიკითხავს ფლეშ მეხსიერება _crypt_cnt (=00000000b) eFuse მნიშვნელობას და რადგან მნიშვნელობა არის 0 (ბიტების ლუწი რაოდენობა დაყენებულია), ის დააკონფიგურირებს და ჩართავს ფლეშ მეხსიერება დაშიფვრის ბლოკს. ის ასევე დააპროგრამებს <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CFG</span></code> eFuse 0xF მნიშვნელობამდე გადატანა.</li>
<li>ფლეშ მეხსიერება დაშიფვრის ბლოკი წარმოქმნის AES-256 ბიტიან გასაღებს და შეინახავს BLOCK1 eFuse-ში. ეს ოპერაცია აპარატურულად სრულდება და გასაღებზე წვდომა პროგრამული უზრუნველყოფით შეუძლებელია.</li>
<li>შემდეგ, ფლეშ მეხსიერება დაშიფვრის ბლოკი დაშიფვრავს ფლეშ მეხსიერება შინაარსს ( დანაყოფების ცხრილი დროშის მნიშვნელობის მიხედვით). ადგილზე დაშიფვრას შეიძლება გარკვეული დრო დასჭირდეს (დიდი დანაყოფებისთვის ერთ წუთამდე).</li>
<li>მეორე ეტაპის შემდეგ ჩამტვირთავი ადგენს ფლეშ მეხსიერება _crypt_cnt (=00000001b)-ში პირველ ხელმისაწვდომ ბიტს, რათა ფლეშ მეხსიერება შიგთავსი მონიშნოს დაშიფრულად (ბიტების კენტი რაოდენობაა მითითებული).</li>
<li>ამისთვის <a class="reference internal" href="flash-encryption.html#flash-enc-release-mode"><span class="std std-ref">გამოშვების რეჟიმი</span></a> მეორე ეტაპის ჩამტვირთავი პროგრამას წარადგენს <code class="docutils literal notranslate"><span class="pre">download_dis_encrypt</span></code>, <code class="docutils literal notranslate"><span class="pre">download_dis_decrypt</span></code> და <code class="docutils literal notranslate"><span class="pre">download_dis_cache</span></code> eFuse ბიტები 1-ზე დააყენეთ, რათა თავიდან აიცილოთ UART ჩამტვირთავი მიერ ფლეშ მეხსიერება შინაარსის გაშიფვრა. ის ასევე დაიცავს ჩაწერის ფუნქციას. <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse ბიტები.</li>
<li>ამისთვის <a class="reference internal" href="flash-encryption.html#flash-enc-development-mode"><span class="std std-ref">განვითარების რეჟიმი</span></a> მეორე ეტაპის ჩამტვირთავი მხოლოდ პროგრამას მოიცავს <code class="docutils literal notranslate"><span class="pre">download_dis_decrypt</span></code> და <code class="docutils literal notranslate"><span class="pre">download_dis_cache</span></code> eFuse ბიტები, რათა UART ჩამტვირთავი შეძლოს დაშიფრული ბინარული ფაილების ხელახლა ფლეშ მეხსიერება . ასევე <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse ბიტები ჩაწერისგან დაცული არ იქნება.</li>
<li>მეორე ეტაპი ჩამტვირთავი შემდეგ გადატვირთავს მოწყობილობას დაშიფრული გამოსახულების შესასრულებლად. ის გამჭვირვალედ გაშიფრავს ფლეშ მეხსიერება შინაარსს და ჩაიტვირთება IRAM-ში.</li>
</ul>
<p>შემუშავების ეტაპზე ხშირად საჭიროა სხვადასხვა უბრალო ტექსტის ფლეშ მეხსიერება სურათების დაპროგრამება და ფლეშ მეხსიერება დაშიფვრის პროცესის ტესტირება. ამისათვის საჭიროა UART ჩამოტვირთვის რეჟიმი, რათა შესაძლებელი იყოს ახალი უბრალო ტექსტის სურათების ჩატვირთვა იმდენჯერ, რამდენჯერაც საჭიროა. თუმცა, წარმოების დროს ან დამზადების დროს, უსაფრთხოების მიზნით, UART ჩამოტვირთვის რეჟიმს არ უნდა მიეცეს ფლეშ მეხსიერება შინაარსზე წვდომის უფლება. შესაბამისად, ეს მოითხოვს ორ განსხვავებულ ESP32 კონფიგურაციას: ერთი შემუშავებისთვის და მეორე წარმოებისთვის. შემდეგ ნაწილში აღწერილია <a class="reference internal" href="flash-encryption.html#flash-enc-development-mode"><span class="std std-ref">განვითარების რეჟიმი</span></a> და <a class="reference internal" href="flash-encryption.html#flash-enc-release-mode"><span class="std std-ref">გამოშვების რეჟიმი</span></a> ფლეშ მეხსიერება დაშიფვრისთვის და მათი გამოყენების ეტაპობრივი პროცესი.</p>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">როგორც სახელიდან ჩანს, შემუშავების რეჟიმი უნდა იქნას გამოყენებული მხოლოდ შემუშავების დროს, რადგან ის არ უშლის ხელს დაშიფრული ფლეშ მეხსიერება შინაარსის მოდიფიკაციას და შესაძლო უკან წაკითხვას.</p>
</div>
</div>
<div class="section" id="steps-to-setup-flash-encryption">
<h2>ფლეშ დაშიფვრის დაყენების ნაბიჯები<a class="headerlink" href="flash-encryption.html#steps-to-setup-flash-encryption" title="Permalink to this headline">¶</a></h2>
<div class="section" id="development-mode">
<span id="flash-enc-development-mode"></span><h3>განვითარების რეჟიმი<a class="headerlink" href="flash-encryption.html#development-mode" title="Permalink to this headline">¶</a></h3>
<p>შესაძლებელია ფლეშ მეხსიერება დაშიფვრის პროცესის გაშვება შემუშავებისთვის ESP32-ის შიდა გენერირებული გასაღების ან გარე მასპინძლის მიერ გენერირებული გასაღებების გამოყენებით.</p>
</div>
<div class="section" id="using-esp32-generated-flash-encryption-key">
<h3>ESP32-ის მიერ გენერირებული ფლეშ დაშიფვრის გასაღების გამოყენება<a class="headerlink" href="flash-encryption.html#using-esp32-generated-flash-encryption-key" title="Permalink to this headline">¶</a></h3>
<p>როგორც ზემოთ აღინიშნა <a class="reference internal" href="flash-encryption.html#flash-enc-development-mode"><span class="std std-ref">განვითარების რეჟიმი</span></a> საშუალებას აძლევს მომხმარებელს UART ჩამოტვირთვის რეჟიმის გამოყენებით ჩამოტვირთოს რაც შეიძლება მეტი უბრალო ტექსტის სურათი. ფლეშ მეხსიერება დაშიფვრის პროცესის შესამოწმებლად საჭიროა შემდეგი ნაბიჯების შესრულება:</p>
<ul class="simple">
<li>დარწმუნდით, რომ გაქვთ ESP32 მოწყობილობა ნაგულისხმევი ფლეშ მეხსიერება დაშიფვრის eFuse პარამეტრებით, როგორც ეს ნაჩვენებია <a class="reference internal" href="flash-encryption.html#flash-encryption-efuse"><span class="std std-ref">eFuse გამოყენებულია Flash დაშიფვრის პროცესში</span></a>.</li>
<li>გადადით ფლეშ მეხსიერება დაშიფვრის ნიმუშის აპლიკაციაზე <code class="docutils literal notranslate"><span class="pre">$IDF_PATH/examples/security/flash_encryption</span></code> საქაღალდე. ეს ნიმუში აპლიკაცია დაბეჭდავს ფლეშ მეხსიერება დაშიფვრის სტატუსს: ჩართულია თუ გამორთული. ის დაბეჭდავს <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse-ის მნიშვნელობა.</li>
<li>ფლეშ მეხსიერება დაშიფვრის მხარდაჭერის ჩართვა მეორე ეტაპზე ჩამტვირთავი . <a class="reference internal" href="../api-reference/kconfig.html#project-configuration-menu"><span class="std std-ref">პროექტის კონფიგურაციის მენიუ</span></a>, გადადით „უსაფრთხოების ფუნქციებზე“.</li>
<li>არჩევა <a class="reference internal" href="../api-reference/kconfig.html#config-secure-flash-enc-enabled"><span class="std std-ref">ჩატვირთვისას ფლეშ მეხსიერება დაშიფვრის ჩართვა</span></a>.</li>
<li>სტანდარტულად, რეჟიმი დაყენებულია <strong>განვითარება</strong>.</li>
<li>Bootloader-ის კონფიგურაციის ქვეშ აირჩიეთ Bootloader-ის ჟურნალის შესაბამისი დეტალიზაცია.</li>
<li>შესაძლოა საჭირო გახდეს დანაყოფების ცხრილი ოფსეტის განახლება, რადგან ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ ჩამტვირთავი ის ზომა იზრდება. იხილეთ <a class="reference internal" href="secure-boot.html#secure-boot-bootloader-size"><span class="std std-ref">ჩატვირთვის ზომა</span></a></li>
<li>კონფიგურაციის შენახვა და გასვლა.</li>
</ul>
<p>შექმენით ფლეშ მეხსიერება სრული სურათი, მათ შორის: ჩამტვირთავი , დანაყოფების ცხრილი და app. ეს დანაყოფები თავდაპირველად ფლეშ მეხსიერება ში დაუშიფრავად იწერება.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
<p>ფლეშ მეხსიერება დაშიფვრის დასრულების შემდეგ, მოწყობილობა გადაიტვირთება და შემდეგი ჩატვირთვის მეორე ეტაპზე ჩამტვირთავი დაშიფვრავს ფლეშ მეხსიერება აპლიკაციის დანაყოფს და შემდეგ გადაიტვირთება. ახლა, ნიმუში აპლიკაცია გაშიფრული იქნება გაშვების დროს და შესრულდება. ქვემოთ მოცემულია ნიმუშის გამომავალი, როდესაც ESP32 ჩაიტვირთება ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ პირველად.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>--- idf_monitor on /dev/cu.SLAB_USBtoUART 115200 ---
--- Quit: Ctrl+] | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
ets Jun  8 2016 00:22:57

rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:8452
load:0x40078000,len:13608
load:0x40080400,len:6664
entry 0x40080764
I (28) boot: ESP-IDF v4.0-dev-850-gc4447462d-dirty 2nd stage bootloader
I (29) boot: compile time 15:37:14
I (30) boot: Enabling RNG early entropy source...
I (35) boot: SPI Speed      : 40MHz
I (39) boot: SPI Mode       : DIO
I (43) boot: SPI Flash Size : 4MB
I (47) boot: Partition Table:
I (51) boot: ## Label            Usage          Type ST Offset   Length
I (58) boot:  0 nvs              WiFi data        01 02 0000a000 00006000
I (66) boot:  1 phy_init         RF data          01 01 00010000 00001000
I (73) boot:  2 factory          factory app      00 00 00020000 00100000
I (81) boot: End of partition table
I (85) esp_image: segment 0: paddr=0x00020020 vaddr=0x3f400020 size=0x0808c ( 32908) map
I (105) esp_image: segment 1: paddr=0x000280b4 vaddr=0x3ffb0000 size=0x01ea4 (  7844) load
I (109) esp_image: segment 2: paddr=0x00029f60 vaddr=0x40080000 size=0x00400 (  1024) load
0x40080000: _WindowOverflow4 at esp-idf/esp-idf/components/freertos/xtensa_vectors.S:1778

I (114) esp_image: segment 3: paddr=0x0002a368 vaddr=0x40080400 size=0x05ca8 ( 23720) load
I (132) esp_image: segment 4: paddr=0x00030018 vaddr=0x400d0018 size=0x126a8 ( 75432) map
0x400d0018: _flash_cache_start at ??:?

I (159) esp_image: segment 5: paddr=0x000426c8 vaddr=0x400860a8 size=0x01f4c (  8012) load
0x400860a8: prvAddNewTaskToReadyList at esp-idf/esp-idf/components/freertos/tasks.c:4561

I (168) boot: Loaded app from partition at offset 0x20000
I (168) boot: Checking flash encryption...
I (168) flash_encrypt: Generating new flash encryption key...
I (187) flash_encrypt: Read &amp; write protecting new key...
I (187) flash_encrypt: Setting CRYPT_CONFIG efuse to 0xF
W (188) flash_encrypt: Not disabling UART bootloader encryption
I (195) flash_encrypt: Disable UART bootloader decryption...
I (201) flash_encrypt: Disable UART bootloader MMU cache...
I (208) flash_encrypt: Disable JTAG...
I (212) flash_encrypt: Disable ROM BASIC interpreter fallback...
I (219) esp_image: segment 0: paddr=0x00001020 vaddr=0x3fff0018 size=0x00004 (     4)
I (227) esp_image: segment 1: paddr=0x0000102c vaddr=0x3fff001c size=0x02104 (  8452)
I (239) esp_image: segment 2: paddr=0x00003138 vaddr=0x40078000 size=0x03528 ( 13608)
I (249) esp_image: segment 3: paddr=0x00006668 vaddr=0x40080400 size=0x01a08 (  6664)
I (657) esp_image: segment 0: paddr=0x00020020 vaddr=0x3f400020 size=0x0808c ( 32908) map
I (669) esp_image: segment 1: paddr=0x000280b4 vaddr=0x3ffb0000 size=0x01ea4 (  7844)
I (672) esp_image: segment 2: paddr=0x00029f60 vaddr=0x40080000 size=0x00400 (  1024)
0x40080000: _WindowOverflow4 at esp-idf/esp-idf/components/freertos/xtensa_vectors.S:1778

I (676) esp_image: segment 3: paddr=0x0002a368 vaddr=0x40080400 size=0x05ca8 ( 23720)
I (692) esp_image: segment 4: paddr=0x00030018 vaddr=0x400d0018 size=0x126a8 ( 75432) map
0x400d0018: _flash_cache_start at ??:?

I (719) esp_image: segment 5: paddr=0x000426c8 vaddr=0x400860a8 size=0x01f4c (  8012)
0x400860a8: prvAddNewTaskToReadyList at esp-idf/esp-idf/components/freertos/tasks.c:4561

I (722) flash_encrypt: Encrypting partition 2 at offset 0x20000...
I (13229) flash_encrypt: Flash encryption completed
I (13229) boot: Resetting with flash encryption enabled...
</pre></div>
</div>
<p>როგორც კი ფლეშ მეხსიერება დაშიფვრა ჩაირთვება, შემდგომი ჩატვირთვისას გამომავალი შეტყობინება მიუთითებს, რომ ფლეშ მეხსიერება დაშიფვრა უკვე ჩართულია.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rst:0x1 (POWERON_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:8452
load:0x40078000,len:13652
ho 0 tail 12 room 4
load:0x40080400,len:6664
entry 0x40080764
I (30) boot: ESP-IDF v4.0-dev-850-gc4447462d-dirty 2nd stage bootloader
I (30) boot: compile time 16:32:53
I (31) boot: Enabling RNG early entropy source...
I (37) boot: SPI Speed      : 40MHz
I (41) boot: SPI Mode       : DIO
I (45) boot: SPI Flash Size : 4MB
I (49) boot: Partition Table:
I (52) boot: ## Label            Usage          Type ST Offset   Length
I (60) boot:  0 nvs              WiFi data        01 02 0000a000 00006000
I (67) boot:  1 phy_init         RF data          01 01 00010000 00001000
I (75) boot:  2 factory          factory app      00 00 00020000 00100000
I (82) boot: End of partition table
I (86) esp_image: segment 0: paddr=0x00020020 vaddr=0x3f400020 size=0x0808c ( 32908) map
I (107) esp_image: segment 1: paddr=0x000280b4 vaddr=0x3ffb0000 size=0x01ea4 (  7844) load
I (111) esp_image: segment 2: paddr=0x00029f60 vaddr=0x40080000 size=0x00400 (  1024) load
0x40080000: _WindowOverflow4 at esp-idf/esp-idf/components/freertos/xtensa_vectors.S:1778

I (116) esp_image: segment 3: paddr=0x0002a368 vaddr=0x40080400 size=0x05ca8 ( 23720) load
I (134) esp_image: segment 4: paddr=0x00030018 vaddr=0x400d0018 size=0x126a8 ( 75432) map
0x400d0018: _flash_cache_start at ??:?

I (162) esp_image: segment 5: paddr=0x000426c8 vaddr=0x400860a8 size=0x01f4c (  8012) load
0x400860a8: prvAddNewTaskToReadyList at esp-idf/esp-idf/components/freertos/tasks.c:4561

I (171) boot: Loaded app from partition at offset 0x20000
I (171) boot: Checking flash encryption...
I (171) flash_encrypt: flash encryption is enabled (3 plaintext flashes left)
I (178) boot: Disabling RNG early entropy source...
I (184) cpu_start: Pro cpu up.
I (188) cpu_start: Application information:
I (193) cpu_start: Project name:     flash-encryption
I (198) cpu_start: App version:      v4.0-dev-850-gc4447462d-dirty
I (205) cpu_start: Compile time:     Jun 17 2019 16:32:52
I (211) cpu_start: ELF file SHA256:  8770c886bdf561a7...
I (217) cpu_start: ESP-IDF:          v4.0-dev-850-gc4447462d-dirty
I (224) cpu_start: Starting app cpu, entry point is 0x40080e4c
0x40080e4c: call_start_cpu1 at esp-idf/esp-idf/components/esp32/cpu_start.c:265

I (0) cpu_start: App cpu up.
I (235) heap_init: Initializing. RAM available for dynamic allocation:
I (241) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM
I (247) heap_init: At 3FFB2EC8 len 0002D138 (180 KiB): DRAM
I (254) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM
I (260) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM
I (266) heap_init: At 40087FF4 len 0001800C (96 KiB): IRAM
I (273) cpu_start: Pro cpu start user code
I (291) cpu_start: Starting scheduler on PRO CPU.
I (0) cpu_start: Starting scheduler on APP CPU.

Sample program to check Flash Encryption
This is ESP32 chip with 2 CPU cores, WiFi/BT/BLE, silicon revision 1, 4MB external flash
Flash encryption feature is enabled
Flash encryption mode is DEVELOPMENT
Flash in encrypted mode with flash_crypt_cnt = 1
Halting...
</pre></div>
</div>
</div></blockquote>
<p>ამ ეტაპზე, თუ მომხმარებელს სურს განაახლოს შეცვლილი plaintext აპლიკაციის სურათი ფლეშ მეხსიერება ზე დაშიფრულ ფორმატში, ამის გაკეთება შეუძლია შემდეგი ბრძანების გამოყენებით:</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">encrypted</span><span class="o">-</span><span class="n">app</span><span class="o">-</span><span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="encrypt-multiple-partitions">
<span id="encrypt-partitions"></span><h3>მრავალი დანაყოფის დაშიფვრა<a class="headerlink" href="flash-encryption.html#encrypt-multiple-partitions" title="Permalink to this headline">¶</a></h3>
<p>თუ ყველა დანაყოფის განახლება დაშიფრული ფორმატით არის საჭირო, ეს შეიძლება გაკეთდეს შემდეგნაირად</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">encrypted</span><span class="o">-</span><span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="using-host-generated-flash-encryption-key">
<span id="pregenerated-flash-encryption-key"></span><h3>მასპინძლის მიერ გენერირებული ფლეშ დაშიფვრის გასაღების გამოყენება<a class="headerlink" href="flash-encryption.html#using-host-generated-flash-encryption-key" title="Permalink to this headline">¶</a></h3>
<p>შესაძლებელია ფლეშ მეხსიერება დაშიფვრის გასაღების წინასწარ გენერირება მასპინძელ კომპიუტერზე და მისი ჩაწერა ESP32-ის eFuse გასაღების ბლოკში. ეს საშუალებას იძლევა მონაცემები წინასწარ დაშიფრული იყოს მასპინძელზე და ფლეშ მეხსიერება გადაეცეს ESP32-ს ტექსტური ფლეშ მეხსიერება განახლების გარეშე. ეს ფუნქცია საშუალებას იძლევა დაშიფრული ფლეშ მეხსიერება იყოს ორივეში. <a class="reference internal" href="flash-encryption.html#flash-enc-development-mode"><span class="std std-ref">განვითარების რეჟიმი</span></a> და <a class="reference internal" href="flash-encryption.html#flash-enc-release-mode"><span class="std std-ref">გამოშვების რეჟიმი</span></a> რეჟიმები.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ეს ვარიანტი არ არის რეკომენდებული წარმოებისთვის, თუ თითოეული მოწყობილობისთვის ცალკე გასაღები არ გენერირდება.</p>
</div>
<ul>
<li><p class="first">დარწმუნდით, რომ გაქვთ ESP32 მოწყობილობა ნაგულისხმევი ფლეშ მეხსიერება დაშიფვრის eFuse პარამეტრებით, როგორც ეს ნაჩვენებია <a class="reference internal" href="flash-encryption.html#flash-encryption-efuse"><span class="std std-ref">eFuse გამოყენებულია Flash დაშიფვრის პროცესში</span></a>.</p>
</li>
<li><p class="first">შემთხვევითი გასაღების გენერირება espsecure.py-ის გამოყენებით:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">espsecure</span><span class="o">.</span><span class="n">py</span> <span class="n">generate_flash_encryption_key</span> <span class="n">my_flash_encryption_key</span><span class="o">.</span><span class="n">bin</span>
</pre></div>
</div>
</li>
<li><p class="first">დაწვით მოწყობილობის გასაღები (მხოლოდ ერთხელ). <strong>ეს უნდა გაკეთდეს პირველი დაშიფრული ჩატვირთვის წინ</strong>, წინააღმდეგ შემთხვევაში ESP32 შექმნის შემთხვევით გასაღებს, რომლის წვდომა ან შეცვლაც პროგრამულ უზრუნველყოფას არ შეუძლია:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">espefuse</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="n">PORT</span> <span class="n">burn_key</span> <span class="n">flash_encryption</span> <span class="n">my_flash_encryption_key</span><span class="o">.</span><span class="n">bin</span>
</pre></div>
</div>
</li>
<li><p class="first">ფლეშ მეხსიერება დაშიფვრის მხარდაჭერის ჩართვა მეორე ეტაპზე ჩამტვირთავი . <a class="reference internal" href="../api-reference/kconfig.html#project-configuration-menu"><span class="std std-ref">პროექტის კონფიგურაციის მენიუ</span></a>, გადადით „უსაფრთხოების ფუნქციებზე“.</p>
</li>
<li><p class="first">არჩევა <a class="reference internal" href="../api-reference/kconfig.html#config-secure-flash-enc-enabled"><span class="std std-ref">ჩატვირთვისას ფლეშ მეხსიერება დაშიფვრის ჩართვა</span></a>.</p>
</li>
<li><p class="first">სტანდარტულად, რეჟიმი დაყენებულია <strong>განვითარება</strong>.</p>
</li>
<li><p class="first">Bootloader-ის კონფიგურაციის ქვეშ აირჩიეთ Bootloader-ის ჟურნალის შესაბამისი დეტალიზაცია.</p>
</li>
<li><p class="first">შესაძლოა საჭირო გახდეს დანაყოფების ცხრილი ოფსეტის განახლება, რადგან ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ ჩამტვირთავი ის ზომა იზრდება. იხილეთ <a class="reference internal" href="secure-boot.html#secure-boot-bootloader-size"><span class="std std-ref">ჩატვირთვის ზომა</span></a></p>
</li>
<li><p class="first">კონფიგურაციის შენახვა და გასვლა.</p>
</li>
</ul>
<p>შექმენით ფლეშ მეხსიერება სრული სურათი, მათ შორის: ჩამტვირთავი , დანაყოფების ცხრილი და app. ეს დანაყოფები თავდაპირველად ფლეშ მეხსიერება ში დაუშიფრავად იწერება.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
<p>შემდეგი ჩატვირთვის მეორე ეტაპზე ჩამტვირთავი დაშიფვრავს ფლეშ მეხსიერება აპლიკაციის დანაყოფს და შემდეგ გადატვირთავს მას. ახლა ნიმუში აპლიკაცია გაშიფრული იქნება გაშვების დროს და შესრულდება.</p>
<p>ამ ეტაპზე, თუ მომხმარებელს სურს ახალი ტექსტური აპლიკაციის სურათის ფლეშ მეხსიერება ზე განახლება, მან უნდა გასცეს შემდეგი ბრძანება</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">encrypted</span><span class="o">-</span><span class="n">app</span><span class="o">-</span><span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
<p>ყველა დანაყოფის დაშიფრული ფორმატით გადაპროგრამებისთვის, მიჰყევით ინსტრუქციას <a class="reference internal" href="flash-encryption.html#encrypt-partitions"><span class="std std-ref">მრავალი დანაყოფის დაშიფვრა</span></a>.</p>
</div>
<div class="section" id="release-mode">
<span id="flash-enc-release-mode"></span><h3>გამოშვების რეჟიმი<a class="headerlink" href="flash-encryption.html#release-mode" title="Permalink to this headline">¶</a></h3>
<p>გამოშვების რეჟიმში UART ჩამტვირთავი არ შეუძლია ფლეშ მეხსიერება დაშიფვრის ოპერაციების შესრულება და ახალი ტექსტური სურათების ჩამოტვირთვა შესაძლებელია მხოლოდ OTA სქემის გამოყენებით, რომელიც დაშიფვრავს ტექსტურ სურათს ფლეშ მეხსიერება ში ჩაწერამდე.</p>
<ul class="simple">
<li>დარწმუნდით, რომ გაქვთ ESP32 მოწყობილობა ნაგულისხმევი ფლეშ მეხსიერება დაშიფვრის eFuse პარამეტრებით, როგორც ეს ნაჩვენებია <a class="reference internal" href="flash-encryption.html#flash-encryption-efuse"><span class="std std-ref">eFuse გამოყენებულია Flash დაშიფვრის პროცესში</span></a>.</li>
<li>ფლეშ მეხსიერება დაშიფვრის მხარდაჭერის ჩართვა მეორე ეტაპზე ჩამტვირთავი . <a class="reference internal" href="../api-reference/kconfig.html#project-configuration-menu"><span class="std std-ref">პროექტის კონფიგურაციის მენიუ</span></a>, გადადით „უსაფრთხოების ფუნქციებზე“.</li>
<li>არჩევა <a class="reference internal" href="../api-reference/kconfig.html#config-secure-flash-enc-enabled"><span class="std std-ref">ჩატვირთვისას ფლეშ მეხსიერება დაშიფვრის ჩართვა</span></a>.</li>
<li>არჩევა <strong>გამოშვების რეჟიმი</strong>, ნაგულისხმევად რეჟიმი დაყენებულია <strong>განვითარება</strong>გთხოვთ, გაითვალისწინოთ <strong>გაშვების რეჟიმის არჩევის შემდეგ, ``download_dis_encrypt`` და ``download_dis_decrypt`` eFuse ბიტები დაპროგრამდება UART ჩამტვირთავი ის ფლეშ მეხსიერება შინაარსზე წვდომის გასათიშად.</strong>.</li>
<li>Bootloader-ის კონფიგურაციის ქვეშ აირჩიეთ Bootloader-ის ჟურნალის შესაბამისი დეტალიზაცია.</li>
<li>შესაძლოა საჭირო გახდეს დანაყოფების ცხრილი ოფსეტის განახლება, რადგან ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ ჩამტვირთავი ის ზომა იზრდება. იხილეთ <a class="reference internal" href="secure-boot.html#secure-boot-bootloader-size"><span class="std std-ref">ჩატვირთვის ზომა</span></a></li>
<li>კონფიგურაციის შენახვა და გასვლა.</li>
</ul>
<p>შექმენით ფლეშ მეხსიერება სრული სურათი, მათ შორის: ჩამტვირთავი , დანაყოფების ცხრილი და app. ეს დანაყოფები თავდაპირველად ფლეშ მეხსიერება ში დაუშიფრავად იწერება.</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idf</span><span class="o">.</span><span class="n">py</span> <span class="n">flash</span> <span class="n">monitor</span>
</pre></div>
</div>
</div></blockquote>
<p>შემდეგი ჩატვირთვის მეორე ეტაპზე ჩამტვირთავი დაშიფვრავს ფლეშ მეხსიერება აპლიკაციის დანაყოფს და შემდეგ გადატვირთავს მას. ახლა ნიმუში აპლიკაცია სწორად უნდა იმუშაოს.</p>
<p>როგორც კი ფლეშ მეხსიერება დაშიფვრა გააქტიურდება გამოშვების რეჟიმში, ჩამტვირთავი დაიცავს ჩაწერისგან. <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse.</p>
<p>ველში შემდგომი უბრალო ტექსტის განახლებისთვის <a class="reference internal" href="flash-encryption.html#updating-encrypted-flash-ota"><span class="std std-ref">OTA სქემა</span></a> უნდა იქნას გამოყენებული.</p>
</div>
<div class="section" id="possible-failures">
<h3>შესაძლო წარუმატებლობები<a class="headerlink" href="flash-encryption.html#possible-failures" title="Permalink to this headline">¶</a></h3>
<p>ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ და თუ <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse მნიშვნელობას აქვს კენტი რაოდენობის ბიტები, მაშინ ყველა დანაყოფი (რომლებიც მონიშნულია დაშიფვრის დროშით) სავარაუდოდ შეიცავს დაშიფრულ შიფრირებულ ტექსტს. ქვემოთ მოცემულია სამი ტიპიური შეცდომის შემთხვევა, თუ ESP32 ჩატვირთულია უბრალო ტექსტური მონაცემებით:</p>
<ol class="arabic simple">
<li>იმ შემთხვევაში, თუ ჩამტვირთავი დანაყოფი ხელახლა განახლდება ჩამტვირთავი უბრალო ტექსტური გამოსახულებით, ROM ჩამტვირთავი ვერ შეძლებს ჩამტვირთავი ჩატვირთვას და გამოჩნდება შემდეგი ტიპის შეცდომა:</li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rst</span><span class="p">:</span><span class="mh">0x3</span> <span class="p">(</span><span class="n">SW_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">flash</span> <span class="n">read</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">ets_main</span><span class="o">.</span><span class="n">c</span> <span class="mi">371</span>
<span class="n">ets</span> <span class="n">Jun</span>  <span class="mi">8</span> <span class="mi">2016</span> <span class="mi">00</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">57</span>

<span class="n">rst</span><span class="p">:</span><span class="mh">0x7</span> <span class="p">(</span><span class="n">TG0WDT_SYS_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">flash</span> <span class="n">read</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">ets_main</span><span class="o">.</span><span class="n">c</span> <span class="mi">371</span>
<span class="n">ets</span> <span class="n">Jun</span>  <span class="mi">8</span> <span class="mi">2016</span> <span class="mi">00</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">57</span>

<span class="n">rst</span><span class="p">:</span><span class="mh">0x7</span> <span class="p">(</span><span class="n">TG0WDT_SYS_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">flash</span> <span class="n">read</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">ets_main</span><span class="o">.</span><span class="n">c</span> <span class="mi">371</span>
<span class="n">ets</span> <span class="n">Jun</span>  <span class="mi">8</span> <span class="mi">2016</span> <span class="mi">00</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">57</span>

<span class="n">rst</span><span class="p">:</span><span class="mh">0x7</span> <span class="p">(</span><span class="n">TG0WDT_SYS_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">flash</span> <span class="n">read</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">ets_main</span><span class="o">.</span><span class="n">c</span> <span class="mi">371</span>
<span class="n">ets</span> <span class="n">Jun</span>  <span class="mi">8</span> <span class="mi">2016</span> <span class="mi">00</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">57</span>

<span class="n">rst</span><span class="p">:</span><span class="mh">0x7</span> <span class="p">(</span><span class="n">TG0WDT_SYS_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">flash</span> <span class="n">read</span> <span class="n">err</span><span class="p">,</span> <span class="mi">1000</span>
<span class="n">ets_main</span><span class="o">.</span><span class="n">c</span> <span class="mi">371</span>
<span class="n">ets</span> <span class="n">Jun</span>  <span class="mi">8</span> <span class="mi">2016</span> <span class="mi">00</span><span class="p">:</span><span class="mi">22</span><span class="p">:</span><span class="mi">57</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ეს შეცდომა ასევე ჩნდება ფლეშ მეხსიერება ში, თუ შინაარსი წაშლილია ან დაზიანებულია.</p>
</div>
<ol class="arabic simple" start="2">
<li>იმ შემთხვევაში, თუ ჩამტვირთავი დაშიფრულია, მაგრამ დანაყოფების ცხრილი ხელახლა განახლდება დანაყოფების ცხრილი უბრალო ტექსტით, ჩამტვირთავი ვერ წაიკითხავს დანაყოფების ცხრილი და გამოჩნდება შემდეგი ტიპის შეცდომა:</li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rst:0x3 (SW_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0018,len:4
load:0x3fff001c,len:10464
ho 0 tail 12 room 4
load:0x40078000,len:19168
load:0x40080400,len:6664
entry 0x40080764
I (60) boot: ESP-IDF v4.0-dev-763-g2c55fae6c-dirty 2nd stage bootloader
I (60) boot: compile time 19:15:54
I (62) boot: Enabling RNG early entropy source...
I (67) boot: SPI Speed      : 40MHz
I (72) boot: SPI Mode       : DIO
I (76) boot: SPI Flash Size : 4MB
E (80) flash_parts: partition 0 invalid magic number 0x94f6
E (86) boot: Failed to verify partition table
E (91) boot: load partition table error!
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>იმ შემთხვევაში, თუ ჩამტვირთავი და დანაყოფების ცხრილი დაშიფრულია, მაგრამ აპლიკაცია ხელახლა განახლდება ტექსტური აპლიკაციის გამოსახულებით, ჩამტვირთავი ვერ შეძლებს ახალი აპლიკაციის ჩატვირთვას და გამოჩნდება შემდეგი ტიპის შეცდომა:</li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rst</span><span class="p">:</span><span class="mh">0x3</span> <span class="p">(</span><span class="n">SW_RESET</span><span class="p">),</span><span class="n">boot</span><span class="p">:</span><span class="mh">0x13</span> <span class="p">(</span><span class="n">SPI_FAST_FLASH_BOOT</span><span class="p">)</span>
<span class="n">configsip</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SPIWP</span><span class="p">:</span><span class="mh">0xee</span>
<span class="n">clk_drv</span><span class="p">:</span><span class="mh">0x00</span><span class="p">,</span><span class="n">q_drv</span><span class="p">:</span><span class="mh">0x00</span><span class="p">,</span><span class="n">d_drv</span><span class="p">:</span><span class="mh">0x00</span><span class="p">,</span><span class="n">cs0_drv</span><span class="p">:</span><span class="mh">0x00</span><span class="p">,</span><span class="n">hd_drv</span><span class="p">:</span><span class="mh">0x00</span><span class="p">,</span><span class="n">wp_drv</span><span class="p">:</span><span class="mh">0x00</span>
<span class="n">mode</span><span class="p">:</span><span class="n">DIO</span><span class="p">,</span> <span class="n">clock</span> <span class="n">div</span><span class="p">:</span><span class="mi">2</span>
<span class="n">load</span><span class="p">:</span><span class="mh">0x3fff0018</span><span class="p">,</span><span class="nb">len</span><span class="p">:</span><span class="mi">4</span>
<span class="n">load</span><span class="p">:</span><span class="mh">0x3fff001c</span><span class="p">,</span><span class="nb">len</span><span class="p">:</span><span class="mi">8452</span>
<span class="n">load</span><span class="p">:</span><span class="mh">0x40078000</span><span class="p">,</span><span class="nb">len</span><span class="p">:</span><span class="mi">13616</span>
<span class="n">load</span><span class="p">:</span><span class="mh">0x40080400</span><span class="p">,</span><span class="nb">len</span><span class="p">:</span><span class="mi">6664</span>
<span class="n">entry</span> <span class="mh">0x40080764</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">56</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">ESP</span><span class="o">-</span><span class="n">IDF</span> <span class="n">v4</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">dev</span><span class="o">-</span><span class="mi">850</span><span class="o">-</span><span class="n">gc4447462d</span><span class="o">-</span><span class="n">dirty</span> <span class="mi">2</span><span class="n">nd</span> <span class="n">stage</span> <span class="n">bootloader</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">56</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="nb">compile</span> <span class="n">time</span> <span class="mi">15</span><span class="p">:</span><span class="mi">37</span><span class="p">:</span><span class="mi">14</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">58</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">Enabling</span> <span class="n">RNG</span> <span class="n">early</span> <span class="n">entropy</span> <span class="n">source</span><span class="o">...</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">SPI</span> <span class="n">Speed</span>      <span class="p">:</span> <span class="mi">40</span><span class="n">MHz</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">68</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">SPI</span> <span class="n">Mode</span>       <span class="p">:</span> <span class="n">DIO</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">72</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">SPI</span> <span class="n">Flash</span> <span class="n">Size</span> <span class="p">:</span> <span class="mi">4</span><span class="n">MB</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">76</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">Partition</span> <span class="n">Table</span><span class="p">:</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">79</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="c1">## Label            Usage          Type ST Offset   Length</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">87</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span>  <span class="mi">0</span> <span class="n">nvs</span>              <span class="n">WiFi</span> <span class="n">data</span>        <span class="mi">01</span> <span class="mi">02</span> <span class="mi">0000</span><span class="n">a000</span> <span class="mi">00006000</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">94</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span>  <span class="mi">1</span> <span class="n">phy_init</span>         <span class="n">RF</span> <span class="n">data</span>          <span class="mi">01</span> <span class="mi">01</span> <span class="mi">00010000</span> <span class="mi">00001000</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">102</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span>  <span class="mi">2</span> <span class="n">factory</span>          <span class="n">factory</span> <span class="n">app</span>      <span class="mi">00</span> <span class="mi">00</span> <span class="mi">00020000</span> <span class="mi">00100000</span>
<span class="n">I</span> <span class="p">(</span><span class="mi">109</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">End</span> <span class="n">of</span> <span class="n">partition</span> <span class="n">table</span>
<span class="n">E</span> <span class="p">(</span><span class="mi">113</span><span class="p">)</span> <span class="n">esp_image</span><span class="p">:</span> <span class="n">image</span> <span class="n">at</span> <span class="mh">0x20000</span> <span class="n">has</span> <span class="n">invalid</span> <span class="n">magic</span> <span class="n">byte</span>
<span class="n">W</span> <span class="p">(</span><span class="mi">120</span><span class="p">)</span> <span class="n">esp_image</span><span class="p">:</span> <span class="n">image</span> <span class="n">at</span> <span class="mh">0x20000</span> <span class="n">has</span> <span class="n">invalid</span> <span class="n">SPI</span> <span class="n">mode</span> <span class="mi">108</span>
<span class="n">W</span> <span class="p">(</span><span class="mi">126</span><span class="p">)</span> <span class="n">esp_image</span><span class="p">:</span> <span class="n">image</span> <span class="n">at</span> <span class="mh">0x20000</span> <span class="n">has</span> <span class="n">invalid</span> <span class="n">SPI</span> <span class="n">size</span> <span class="mi">11</span>
<span class="n">E</span> <span class="p">(</span><span class="mi">132</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">Factory</span> <span class="n">app</span> <span class="n">partition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bootable</span>
<span class="n">E</span> <span class="p">(</span><span class="mi">138</span><span class="p">)</span> <span class="n">boot</span><span class="p">:</span> <span class="n">No</span> <span class="n">bootable</span> <span class="n">app</span> <span class="n">partitions</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">partition</span> <span class="n">table</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="key-points-about-flash-encryption">
<h2>ფლეშ დაშიფვრის შესახებ ძირითადი პუნქტები<a class="headerlink" href="flash-encryption.html#key-points-about-flash-encryption" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first">ფლეშ მეხსიერება ის შინაარსი დაშიფრულია AES-256-ის გამოყენებით. ფლეშ მეხსიერება დაშიფვრის გასაღები ინახება eFuse-ში, ჩიპის შიდა ნაწილში და (ნაგულისხმევად) დაცულია პროგრამული უზრუნველყოფის წვდომისგან.</p>
</li>
<li><p class="first">ის <cite>flash encryption algorithm</cite> არის AES-256, სადაც გასაღები „დახვეწილია“ ფლეშ მეხსიერება ის თითოეული 32 ბაიტიანი ბლოკის ოფსეტის მისამართით. ეს ნიშნავს, რომ ყველა 32 ბაიტიანი ბლოკი (ორი ზედიზედ 16 ბაიტიანი AES ბლოკი) დაშიფრულია ფლეშ მეხსიერება დაშიფვრის გასაღებიდან მიღებული უნიკალური გასაღებით.</p>
</li>
<li><p class="first">ფლეშ მეხსიერებაზე წვდომა გამჭვირვალეა ESP32-ის ფლეშ მეხსიერება ქეშის რუკების ფუნქციის მეშვეობით - ნებისმიერი ფლეშ მეხსიერება რეგიონი, რომელიც მიმაგრებულია მისამართების სივრცესთან, გამჭვირვალედ გაშიფრული იქნება წაკითხვის დროს.</p>
<blockquote>
<div><p>შესაძლოა სასურველი იყოს, რომ ზოგიერთი მონაცემთა დანაყოფი დაშიფრული დარჩეს მათზე წვდომის გასამარტივებლად, ან გამოიყენონ ფლეშ მეხსიერება თან თავსებადი განახლების ალგორითმები, რომლებიც არაეფექტურია, თუ მონაცემები დაშიფრულია. არასტაბილური შენახვისთვის განკუთვნილი NVS დანაყოფის დაშიფვრა შეუძლებელია, რადგან NVS ბიბლიოთეკა პირდაპირ თავსებადი არ არის ფლეშ მეხსიერება დაშიფვრასთან. იხილეთ <a class="reference internal" href="../api-reference/storage/nvs_flash.html#nvs-encryption"><span class="std std-ref">NVS დაშიფვრა</span></a> დამატებითი დეტალებისთვის.</p>
</div></blockquote>
</li>
<li><p class="first">თუ ფლეშ მეხსიერება დაშიფვრა შეიძლება ჩართული იყოს, პროგრამისტმა უნდა მიიღოს გარკვეული ზომები კოდის წერისას, რომელიც <a class="reference internal" href="flash-encryption.html#using-encrypted-flash"><span class="std std-ref">იყენებს დაშიფრულ ფლეშ მეხსიერება</span></a>.</p>
</li>
<li><p class="first">თუ უსაფრთხო ჩატვირთვა ჩართულია, დაშიფრული მოწყობილობის ჩამტვირთავი ხელახლა ფლეშ მეხსიერება სჭირდება „Re ფლეშ მეხსიერება able“ უსაფრთხო ჩატვირთვის დაიჯესტი (იხ. <a class="reference internal" href="flash-encryption.html#flash-encryption-and-secure-boot"><span class="std std-ref">ფლეშ დაშიფვრა და უსაფრთხო ჩატვირთვა</span></a>).</p>
</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ჩამტვირთავი აპლიკაციის ორობითი ფაილი <code class="docutils literal notranslate"><span class="pre">bootloader.bin</span></code> შეიძლება ძალიან დიდი გახდეს, როდესაც ჩართულია როგორც უსაფრთხო ჩატვირთვა, ასევე ფლეშ მეხსიერება დაშიფვრა. იხილეთ <a class="reference internal" href="secure-boot.html#secure-boot-bootloader-size"><span class="std std-ref">ჩატვირთვის ზომა</span></a>.</p>
</div>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">არ შეუწყვიტოთ ESP32-ის კვება პირველი ჩატვირთვის დაშიფვრის გავლისას. თუ კვება შეწყდება, ფლეშ მეხსიერება შინაარსი დაზიანდება და საჭირო გახდება ფლეშ მეხსიერება ხელახლა ჩართვა დაუშიფრავი მონაცემებით. ფლეშ მეხსიერება ასეთი ხელახლა ჩართვა არ ჩაითვლება ფლეშ მეხსიერება ჩატვირთვის ლიმიტში.</p>
</div>
</div>
<div class="section" id="using-encrypted-flash">
<span id="id1"></span><h2>დაშიფრული ფლეშ მეხსიერების გამოყენება<a class="headerlink" href="flash-encryption.html#using-encrypted-flash" title="Permalink to this headline">¶</a></h2>
<p>ESP32 აპლიკაციის კოდს შეუძლია შეამოწმოს, ჩართულია თუ არა ფლეშ მეხსიერება დაშიფვრა ამჟამად დარეკვით <a class="reference internal" href="../api-reference/storage/spi_flash.html#_CPPv428esp_flash_encryption_enabledv" title="esp_flash_encryption_enabled"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_encryption_enabled()</span></code></a>ასევე, მოწყობილობას შეუძლია ფლეშ მეხსიერება დაშიფვრის რეჟიმის იდენტიფიცირება გამოძახებით. <a class="reference internal" href="../api-reference/storage/spi_flash.html#_CPPv429esp_get_flash_encryption_modev" title="esp_get_flash_encryption_mode"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_get_flash_encryption_mode()</span></code></a>.</p>
<p>ფლეშ მეხსიერება დაშიფვრის ჩართვის შემდეგ, კოდიდან ფლეშ მეხსიერება შინაარსზე წვდომისას გარკვეული სიფრთხილეა საჭირო.</p>
<div class="section" id="scope-of-flash-encryption">
<h3>ფლეშ დაშიფვრის ფარგლები<a class="headerlink" href="flash-encryption.html#scope-of-flash-encryption" title="Permalink to this headline">¶</a></h3>
<p>როდესაც <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse-ს აქვს მნიშვნელობა კენტი რაოდენობის ბიტებით, ხოლო ფლეშ მეხსიერება ყველა კონტენტი, რომელზეც წვდომა ხდება MMU-ს ფლეშ მეხსიერება ქეშის საშუალებით, გამჭვირვალედ იშიფრება. ეს მოიცავს:</p>
<ul class="simple">
<li>შესრულებადი აპლიკაციის კოდი ფლეშ მეხსიერება ში (IROM).</li>
<li>ყველა მხოლოდ წასაკითხი მონაცემი ინახება ფლეშ მეხსიერება ში (DROM).</li>
<li>ნებისმიერი მონაცემი, რომლის საშუალებითაც წვდომა ხდება <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_mmap()</span></code>.</li>
<li>პროგრამული უზრუნველყოფის ჩამტვირთავი გამოსახულება, როდესაც ის წაიკითხება ROM ჩამტვირთავი მიერ.</li>
</ul>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">MMU ფლეშ მეხსიერება ქეში უპირობოდ გაშიფრავს ყველა მონაცემს. მონაცემები, რომლებიც ფლეშ მეხსიერება ში დაუშიფრავად ინახება, „გამჭვირვალედ გაშიფრული“ იქნება ფლეშ მეხსიერება ქეშის მეშვეობით და პროგრამული უზრუნველყოფისთვის შემთხვევითი ნაგვის მსგავსად გამოჩნდება.</p>
</div>
</div>
<div class="section" id="reading-encrypted-flash">
<h3>დაშიფრული ფლეშის წაკითხვა<a class="headerlink" href="flash-encryption.html#reading-encrypted-flash" title="Permalink to this headline">¶</a></h3>
<p>ფლეშ მეხსიერება ქეშის MMU-ს მიმაგრების გამოყენების გარეშე მონაცემების წასაკითხად, გირჩევთ გამოიყენოთ დანაყოფის წაკითხვის ფუნქცია. <a class="reference internal" href="../api-reference/storage/spi_flash.html#_CPPv418esp_partition_readPK15esp_partition_t6size_tPv6size_t" title="esp_partition_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_read()</span></code></a>ამ ფუნქციის გამოყენებისას, მონაცემები გაშიფრული იქნება მხოლოდ დაშიფრული დანაყოფიდან წაკითხვის შემდეგ. სხვა დანაყოფი წაიკითხავენ დაუშიფრავად. ამ გზით, პროგრამულ უზრუნველყოფას შეუძლია დაშიფრულ და დაუშიფრავ ფლეშ მეხსიერება წვდომა ერთნაირად.</p>
<p>მონაცემები, რომლებიც იკითხება სხვა SPI წაკითხვის API ის მეშვეობით, არ გაშიფრულია:</p>
<ul class="simple">
<li>მონაცემები წაკითხულია <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_read()</span></code> არ არის გაშიფრული.</li>
<li>მონაცემების წაკითხვა ROM ფუნქციის მეშვეობით <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">SPIRead()</span></code> არ არის გაშიფრული (ეს ფუნქცია არ არის მხარდაჭერილი esp-idf აპლიკაციებში).</li>
<li>არასტაბილური შენახვის (NVS) API გამოყენებით შენახული მონაცემები ყოველთვის ინახება და იკითხება გაშიფრული ფლეშ მეხსიერება დაშიფვრის პერსპექტივიდან. საჭიროების შემთხვევაში, დაშიფვრის ფუნქციის უზრუნველყოფა ბიბლიოთეკის მოვალეობაა. იხილეთ <a class="reference internal" href="../api-reference/storage/nvs_flash.html#nvs-encryption"><span class="std std-ref">NVS დაშიფვრა</span></a> დამატებითი დეტალებისთვის.</li>
</ul>
</div>
<div class="section" id="writing-encrypted-flash">
<h3>დაშიფრული ფლეშის ჩაწერა<a class="headerlink" href="flash-encryption.html#writing-encrypted-flash" title="Permalink to this headline">¶</a></h3>
<p>სადაც შესაძლებელია, გირჩევთ გამოიყენოთ დანაყოფის ჩაწერის ფუნქცია <code class="docutils literal notranslate"><span class="pre">esp_partition_write</span></code>ამ ფუნქციის გამოყენებისას, მონაცემები დაიშიფრება მხოლოდ დაშიფრულ დანაყოფებში ჩაწერისას. მონაცემები სხვა დანაყოფებში ჩაიწერება დაუშიფრავად. ამ გზით, პროგრამულ უზრუნველყოფას შეუძლია დაშიფრულ და დაუშიფრავ ფლეშ მეხსიერება წვდომა ერთნაირად.</p>
<p>ის <code class="docutils literal notranslate"><span class="pre">esp_spi_flash_write</span></code> ფუნქცია მონაცემებს ჩაწერს, როდესაც write_encrypted პარამეტრი true-ზეა დაყენებული. წინააღმდეგ შემთხვევაში, მონაცემები დაუშიფრავად ჩაიწერება.</p>
<p>ROM ფუნქცია <code class="docutils literal notranslate"><span class="pre">esp_rom_spiflash_write_encrypted</span></code> დაშიფრულ მონაცემებს ჩაწერს ფლეშ მეხსიერება ში, ROM ფუნქციაში. <code class="docutils literal notranslate"><span class="pre">SPIWrite</span></code> დაუშიფრავად ჩაიწერს ფლეშ მეხსიერება ში. (ეს ფუნქციები არ არის მხარდაჭერილი esp-idf აპლიკაციებში).</p>
<p>რადგან მონაცემები დაშიფრულია ბლოკებად, დაშიფრული მონაცემების მინიმალური ჩაწერის ზომაა 16 ბაიტი (და გასწორება 16 ბაიტი).</p>
</div>
</div>
<div class="section" id="updating-encrypted-flash">
<span id="id2"></span><h2>დაშიფრული ფლეშ მეხსიერების განახლება<a class="headerlink" href="flash-encryption.html#updating-encrypted-flash" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ota-updates">
<span id="updating-encrypted-flash-ota"></span><h3>OTA განახლებები<a class="headerlink" href="flash-encryption.html#ota-updates" title="Permalink to this headline">¶</a></h3>
<p>დაშიფრული დანაყოფების OTA განახლებები ავტომატურად ჩაიწერს დაშიფრულს, იმ პირობით, რომ <code class="docutils literal notranslate"><span class="pre">esp_partition_write</span></code> ფუნქცია გამოიყენება.</p>
<p>ნებისმიერი აპლიკაციის სურათი, რომელიც OTA-თი განახლდება მოწყობილობაზე, სადაც ფლეშ მეხსიერება დაშიფვრა ჩართულია, მოითხოვს <a class="reference internal" href="../api-reference/kconfig.html#config-secure-flash-enc-enabled"><span class="std std-ref">ჩატვირთვისას ფლეშ მეხსიერება დაშიფვრის ჩართვა</span></a> პარამეტრი, რომელიც ასევე უნდა ჩაირთოს აპლიკაციის კონფიგურაციაში, აპლიკაციის შექმნისას.</p>
<p>გთხოვთ, იხილოთ <a class="reference internal" href="../api-reference/system/ota.html"><span class="doc">ონლაინ რეჟიმში</span></a> ESP-IDF OTA განახლებების შესახებ ზოგადი ინფორმაციისთვის.</p>
</div>
</div>
<div class="section" id="disabling-flash-encryption">
<span id="updating-encrypted-flash-serial"></span><h2>ფლეშ დაშიფვრის გამორთვა<a class="headerlink" href="flash-encryption.html#disabling-flash-encryption" title="Permalink to this headline">¶</a></h2>
<p>თუ რაიმე მიზეზით შემთხვევით ჩართეთ ფლეშ მეხსიერება დაშიფვრა, შემდეგი ტექსტური მონაცემების ფლეშ მეხსიერება დაშიფვრა ESP32-ს დაბლოკავს (მოწყობილობა განუწყვეტლივ გადაიტვირთება და შეცდომას დაბეჭდავს). <code class="docutils literal notranslate"><span class="pre">flash</span> <span class="pre">read</span> <span class="pre">err,</span> <span class="pre">1000</span></code>).</p>
<p>თუ ფლეშ მეხსიერება დაშიფვრა ჩართულია განვითარების რეჟიმში, შეგიძლიათ კვლავ გამორთოთ ფლეშ მეხსიერება დაშიფვრა ჩაწერით <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CNT</span></code> eFuse. ეს შეიძლება გაკეთდეს მხოლოდ სამჯერ თითო ჩიპზე.</p>
<ul class="simple">
<li>პირველი, გახსენით <a class="reference internal" href="../api-reference/kconfig.html#project-configuration-menu"><span class="std std-ref">პროექტის კონფიგურაციის მენიუ</span></a> და გამორთვა <a class="reference internal" href="../api-reference/kconfig.html#config-secure-flash-enc-enabled"><span class="std std-ref">ფლეშ მეხსიერება დაშიფვრის ჩატვირთვის ჩართვა</span></a> &amp;quot;უსაფრთხოების მახასიათებლების&amp;quot; ქვეშ.</li>
<li>გამოდით menuconfig და შეინახეთ ახალი კონფიგურაცია.</li>
<li>სირბილი <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code> კიდევ ერთხელ და კიდევ ერთხელ გადაამოწმეთ, ნამდვილად გამორთეთ თუ არა ეს ვარიანტი! <em>თუ ეს პარამეტრი ჩართული დარჩება, ჩამტვირთავი ჩატვირთვისას დაუყოვნებლივ ხელახლა ჩართავს დაშიფვრას.</em>.</li>
<li>სირბილი <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">flash</span></code> ახალი ჩამტვირთავი და აპლიკაციის შესაქმნელად ფლეშ მეხსიერება , ფლეშ მეხსიერება დაშიფვრის ჩართვის გარეშე.</li>
<li><dl class="first docutils">
<dt>Run <code class="docutils literal notranslate"><span class="pre">espefuse.py</span></code> (in <code class="docutils literal notranslate"><span class="pre">components/esptool_py/esptool</span></code>) to disable the FLASH_CRYPT_CNT::</dt>
<dd>espefuse.py burn_efuse FLASH_CRYPT_CNT</dd>
</dl>
</li>
</ul>
<p>ESP32-ის გადატვირთვა და ფლეშ მეხსიერება დაშიფვრა გამორთული უნდა იყოს, ჩამტვირთავი ჩაირთვება ჩვეულებისამებრ.</p>
</div>
<div class="section" id="limitations-of-flash-encryption">
<span id="flash-encryption-limitations"></span><h2>ფლეშ დაშიფვრის შეზღუდვები<a class="headerlink" href="flash-encryption.html#limitations-of-flash-encryption" title="Permalink to this headline">¶</a></h2>
<p>ფლეშ დაშიფვრა ხელს უშლის დაშიფრული ფლეშ მეხსიერება ის უბრალო ტექსტის წაკითხვას, რათა დაიცვას პროგრამული უზრუნველყოფა არაავტორიზებული წაკითხვისა და მოდიფიკაციისგან. მნიშვნელოვანია გვესმოდეს ფლეშ მეხსიერება დაშიფვრის სისტემის შეზღუდვები:</p>
<ul class="simple">
<li>ფლეშ დაშიფვრა მხოლოდ გასაღების სიძლიერის ტოლია. ამ მიზეზით, ჩვენ გირჩევთ, რომ გასაღებები მოწყობილობაზე პირველი ჩატვირთვისას გენერირდეს (ნაგულისხმევი ქცევა). თუ გასაღებებს მოწყობილობიდან გარეთ გენერირებთ, დარწმუნდით, რომ დაცულია სწორი პროცედურა და არ გამოიყენოთ ერთი და იგივე გასაღები ყველა საწარმოო მოწყობილობას შორის.</li>
<li>ყველა მონაცემი დაშიფრული არ არის შენახული. თუ მონაცემებს ფლეშ მეხსიერება ზე ინახავთ, შეამოწმეთ, მხარს უჭერს თუ არა თქვენს მიერ გამოყენებული მეთოდი (ბიბლიოთეკა, API და ა.შ.) ფლეშ მეხსიერება დაშიფვრას.</li>
<li>ფლეშ დაშიფვრა თავდამსხმელს ხელს არ უშლის ფლეშ მეხსიერება ის მაღალი დონის განლაგების გაგებაში. ეს იმიტომ ხდება, რომ ერთი და იგივე AES გასაღები გამოიყენება მიმდებარე 16 ბაიტიანი AES ბლოკების ყველა წყვილისთვის. როდესაც ეს მიმდებარე 16 ბაიტიანი ბლოკები შეიცავს იდენტურ შინაარსს (მაგალითად, ცარიელ ან შევსების არეებს), ეს ბლოკები დაშიფრული იქნება დაშიფრული ბლოკების შესაბამისი წყვილების წარმოსაქმნელად. ამან შეიძლება თავდამსხმელს საშუალება მისცეს, განახორციელოს მაღალი დონის შედარებები დაშიფრულ მოწყობილობებს შორის (ანუ იმის დასადგენად, მუშაობს თუ არა ორი მოწყობილობა ერთი და იგივე პროგრამული უზრუნველყოფა ვერსიაზე).</li>
<li>იმავე მიზეზით, თავდამსხმელს ყოველთვის შეუძლია განსაზღვროს, თუ როდის შეიცავს მომიჯნავე 16 ბაიტიანი ბლოკების წყვილი (32 ბაიტი გასწორებული) ორ იდენტურ 16 ბაიტიან თანმიმდევრობას. გაითვალისწინეთ ეს, თუ მგრძნობიარე მონაცემებს ფლეშ მეხსიერება ზე ინახავთ, თქვენი ფლეშ მეხსიერება საცავი ისე დაგეგმეთ, რომ ეს არ მოხდეს (საკმარისია ყოველ 16 ბაიტზე მრიცხველი ბაიტის ან სხვა არაიდენტური მნიშვნელობის გამოყენება). <a class="reference internal" href="../api-reference/storage/nvs_flash.html#nvs-encryption"><span class="std std-ref">NVS დაშიფვრა</span></a> ამას უმკლავდება და მრავალი გამოყენებისთვისაა შესაფერისი.</li>
<li>მხოლოდ ფლეშ დაშიფვრა ვერ უშლის ხელს თავდამსხმელს მოწყობილობის პროგრამული უზრუნველყოფა ის შეცვლაში. მოწყობილობაზე არაავტორიზებული პროგრამული უზრუნველყოფა გაშვების თავიდან ასაცილებლად, გამოიყენეთ ფლეშ მეხსიერება დაშიფვრა <a class="reference internal" href="secure-boot.html"><span class="doc">უსაფრთხო ჩატვირთვა</span></a>.</li>
</ul>
</div>
<div class="section" id="flash-encryption-and-secure-boot">
<span id="id3"></span><h2>ფლეშ დაშიფვრა და უსაფრთხო ჩატვირთვა<a class="headerlink" href="flash-encryption.html#flash-encryption-and-secure-boot" title="Permalink to this headline">¶</a></h2>
<p>რეკომენდებულია ფლეშ მეხსიერება დაშიფვრის და უსაფრთხო ჩატვირთვის ერთად გამოყენება. თუმცა, თუ უსაფრთხო ჩატვირთვა ჩართულია, მოწყობილობის ხელახლა ფლეშ მეხსიერება დამატებითი შეზღუდვები ვრცელდება:</p>
<ul class="simple">
<li><a class="reference internal" href="flash-encryption.html#updating-encrypted-flash-ota"><span class="std std-ref">OTA განახლებები</span></a> არ არის შეზღუდული (იმ პირობით, რომ ახალი აპლიკაცია სწორად არის ხელმოწერილი Secure Boot ხელმოწერის გასაღებით).</li>
<li><a class="reference internal" href="flash-encryption.html#updating-encrypted-flash-serial"><span class="std std-ref">უბრალო ტექსტის სერიული ფლეშ მეხსიერება განახლებები</span></a> შესაძლებელია მხოლოდ იმ შემთხვევაში, თუ <a class="reference internal" href="../api-reference/kconfig.html#config-secure-bootloader-mode"><span class="std std-ref">ფლეშ მეხსიერება 3</span></a> არჩეულია უსაფრთხო ჩატვირთვის რეჟიმი და წინასწარ გენერირებულია უსაფრთხო ჩატვირთვის გასაღები, რომელიც ჩაწერილია ESP32-ზე (იხ. <a class="reference internal" href="secure-boot.html#secure-boot-reflashable"><span class="std std-ref">უსაფრთხო ჩატვირთვა</span></a> დოკუმენტაცია). ამ კონფიგურაციაში, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">bootloader</span></code> შექმნის წინასწარ გადამუშავებულ ჩამტვირთავი და უსაფრთხო ჩატვირთვის დაიჯესტ ფაილს ფლეშ მეხსიერება ისთვის 0x0 ოფსეტით. უბრალო ტექსტის სერიული ფლეშ მეხსიერება ნაბიჯების შესრულებისას, აუცილებელია ამ ფაილის ხელახლა ფლეშ მეხსიერება სხვა უბრალო ტექსტური მონაცემების ფლეშ მეხსიერება .</li>
<li><a class="reference internal" href="flash-encryption.html#pregenerated-flash-encryption-key"><span class="std std-ref">წინასწარ გენერირებული ფლეშ დაშიფვრის გასაღების მეშვეობით ფლეშ მეხსიერება ხელახლა გამოყენება</span></a> ჯერ კიდევ შესაძლებელია, იმ პირობით, რომ ჩამტვირთავი არ ფლეშ მეხსიერება . ჩამტვირთავი ხელახალი ფლეშ მეხსიერება იგივეს მოითხოვს. <a class="reference internal" href="../api-reference/kconfig.html#config-secure-bootloader-mode"><span class="std std-ref">ფლეშ მეხსიერება 3</span></a> პარამეტრი უნდა ჩაირთოს უსაფრთხო ჩატვირთვის კონფიგურაციაში.</li>
</ul>
</div>
<div class="section" id="flash-encryption-advanced-features">
<span id="id4"></span><h2>ფლეშ დაშიფვრის გაფართოებული ფუნქციები<a class="headerlink" href="flash-encryption.html#flash-encryption-advanced-features" title="Permalink to this headline">¶</a></h2>
<p>შემდეგი ინფორმაცია სასარგებლოა ფლეშ მეხსიერება დაშიფვრის გაფართოებული გამოყენებისთვის:</p>
<div class="section" id="encrypted-partition-flag">
<h3>დაშიფრული დანაყოფის დროშა<a class="headerlink" href="flash-encryption.html#encrypted-partition-flag" title="Permalink to this headline">¶</a></h3>
<p>ზოგიერთი დანაყოფი ნაგულისხმევად დაშიფრულია. წინააღმდეგ შემთხვევაში, შესაძლებელია ნებისმიერი დანაყოფის მონიშვნა, როგორც დაშიფვრის საჭიროების მქონე:</p>
<p>ში <a class="reference internal" href="../api-guides/partition-tables.html"><span class="doc">დანაყოფების ცხრილი</span></a> აღწერა CSV ფაილებში, არის ველი დროშებისთვის.</p>
<p>როგორც წესი, ველი ცარიელი რჩება, თუ ამ ველში დაწერთ „დაშიფრული“, მაშინ დანაყოფი დანაყოფების ცხრილი ში დაშიფრულად მონიშნული იქნება და აქ ჩაწერილი მონაცემები დაშიფრულად ჩაითვლება (იგივეა, რაც აპლიკაციის დანაყოფი):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Name,   Type, SubType, Offset,  Size, Flags</span>
<span class="n">nvs</span><span class="p">,</span>      <span class="n">data</span><span class="p">,</span> <span class="n">nvs</span><span class="p">,</span>     <span class="mh">0x9000</span><span class="p">,</span>  <span class="mh">0x6000</span>
<span class="n">phy_init</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span>     <span class="mh">0xf000</span><span class="p">,</span>  <span class="mh">0x1000</span>
<span class="n">factory</span><span class="p">,</span>  <span class="n">app</span><span class="p">,</span>  <span class="n">factory</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="mi">1</span><span class="n">M</span>
<span class="n">secret_data</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="mh">0x20000</span><span class="p">,</span> <span class="mi">256</span><span class="n">K</span><span class="p">,</span> <span class="n">encrypted</span>
</pre></div>
</div>
<ul class="simple">
<li>ნაგულისხმევი დანაყოფების ცხრილი ებიდან არცერთი არ შეიცავს დაშიფრულ მონაცემთა დანაყოფებს.</li>
<li>„აპლიკაციის“ დანაყოფების დაშიფრულად მონიშვნა აუცილებელი არ არის, ისინი ყოველთვის დაშიფრულად ითვლება.</li>
<li>„დაშიფრული“ დროშა არაფერს აკეთებს, თუ ფლეშ მეხსიერება დაშიფვრა არ არის ჩართული.</li>
<li>შესაძლებელია სურვილისამებრ მონიშვნა <code class="docutils literal notranslate"><span class="pre">phy</span></code> დანაყოფი <code class="docutils literal notranslate"><span class="pre">phy_init</span></code> მონაცემები დაშიფრულია, თუ გსურთ ამ მონაცემების დაცვა ფიზიკური წვდომისგან, წაკითხვისგან ან მოდიფიკაციისგან.</li>
<li>შეუძლებელია მონიშვნა, <code class="docutils literal notranslate"><span class="pre">nvs</span></code> დანაყოფი დაშიფრულია.</li>
</ul>
</div>
<div class="section" id="enabling-uart-bootloader-encryption-decryption">
<span id="uart-bootloader-encryption"></span><h3>UART Bootloader-ის დაშიფვრის/გაშიფვრის ჩართვა<a class="headerlink" href="flash-encryption.html#enabling-uart-bootloader-encryption-decryption" title="Permalink to this headline">¶</a></h3>
<p>ნაგულისხმევად, პირველი ჩატვირთვისას ფლეშ მეხსიერება დაშიფვრის პროცესი დაწვავს eFuse-ებს <code class="docutils literal notranslate"><span class="pre">DISABLE_DL_ENCRYPT</span></code>, <code class="docutils literal notranslate"><span class="pre">DISABLE_DL_DECRYPT</span></code> და <code class="docutils literal notranslate"><span class="pre">DISABLE_DL_CACHE</span></code>:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">DISABLE_DL_ENCRYPT</span></code> UART ჩამტვირთავი ჩატვირთვის რეჟიმში მუშაობისას გამორთავს ფლეშ მეხსიერება დაშიფვრის ოპერაციებს.</li>
<li><code class="docutils literal notranslate"><span class="pre">DISABLE_DL_DECRYPT</span></code> UART ჩამტვირთავი რეჟიმში მუშაობისას თიშავს გამჭვირვალე ფლეშ მეხსიერება გაშიფვრას, მაშინაც კი, თუ FLASH_CRYPT_CNT დაყენებულია ისე, რომ ჩართოს იგი ნორმალურ მუშაობაში.</li>
<li><code class="docutils literal notranslate"><span class="pre">DISABLE_DL_CACHE</span></code> UART ჩამტვირთავი რეჟიმში მუშაობისას ითიშება მთელი MMU ფლეშ მეხსიერება ქეში.</li>
</ul>
<p>მათი შესანარჩუნებლად, პირველ ჩატვირთვამდე შესაძლებელია მხოლოდ ზოგიერთი eFuse-ის ჩაწერა და დანარჩენის ჩაწერისგან დაცვა (0 მნიშვნელობის დაუყენებლად). მაგალითად:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">espefuse</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="n">PORT</span> <span class="n">burn_efuse</span> <span class="n">DISABLE_DL_DECRYPT</span>
<span class="n">espefuse</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">port</span> <span class="n">PORT</span> <span class="n">write_protect_efuse</span> <span class="n">DISABLE_DL_ENCRYPT</span>
</pre></div>
</div>
<p>(გაითვალისწინეთ, რომ ეს სამივე eFuse გამორთულია ერთი ჩაწერის დაცვის ბიტით, ამიტომ ერთი ჩაწერის დაცვა ყველა მათგანს ჩაწერის დაცვას მოუტანს. ამ მიზეზით, ჩაწერის დაცვამდე აუცილებელია ყველა ბიტის დაყენება.)</p>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">ამ eFuse-ების ჩაწერისგან დაცვა მათი დაუყენებლად შესანარჩუნებლად ამჟამად არც თუ ისე სასარგებლოა, რადგან <code class="docutils literal notranslate"><span class="pre">esptool.py</span></code> დაშიფრული ფლეშ მეხსიერება წაკითხვას არ უჭერს მხარს.</p>
</div>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">თუ <code class="docutils literal notranslate"><span class="pre">DISABLE_DL_DECRYPT</span></code> თუ მნიშვნელობა არ არის დაყენებული (0), ეს ფაქტობრივად ფლეშ მეხსიერება დაშიფვრას უსარგებლოს ხდის, რადგან ფიზიკური წვდომის მქონე თავდამსხმელს შეუძლია გამოიყენოს UART ჩამტვირთავი რეჟიმი (მორგებული stub კოდით) ფლეშ მეხსიერება შინაარსის წასაკითხად.</p>
</div>
</div>
<div class="section" id="setting-flash-crypt-config">
<span id="id5"></span><h3>FLASH_CRYPT_CONFIG-ის დაყენება<a class="headerlink" href="flash-encryption.html#setting-flash-crypt-config" title="Permalink to this headline">¶</a></h3>
<p>ის <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CONFIG</span></code> eFuse განსაზღვრავს ფლეშ მეხსიერება დაშიფვრის გასაღებში იმ ბიტების რაოდენობას, რომლებიც „შეცვლილია“ ბლოკის ოფსეტით. იხილეთ <a class="reference internal" href="flash-encryption.html#flash-encryption-algorithm"><span class="std std-ref">ფლეშ დაშიფვრის ალგორითმი</span></a> დეტალებისთვის.</p>
<p>ჩამტვირთავი ის პირველი ჩატვირთვა ყოველთვის ამ მნიშვნელობას მაქსიმუმზე აყენებს. <cite>0xF</cite>.</p>
<p>შესაძლებელია ამ eFuse-ების ხელით ჩაწერა და პირველი ჩატვირთვის წინ მისი protect-ის ჩაწერა სხვადასხვა tweak მნიშვნელობების შესარჩევად. ეს არ არის რეკომენდებული.</p>
<p>მკაცრად რეკომენდებულია, რომ არასდროს დაწეროთ დაცვა. <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CONFIG</span></code> როდესაც მისი მნიშვნელობა ნულია. თუ ეს eFuse დაყენებულია ნულზე, ფლეშ მეხსიერება დაშიფვრის გასაღებში ბიტები არ შეიცვლება და ფლეშ მეხსიერება დაშიფვრის ალგორითმი AES ECB რეჟიმის ეკვივალენტურია.</p>
</div>
</div>
<div class="section" id="technical-details">
<h2>ტექნიკური დეტალები<a class="headerlink" href="flash-encryption.html#technical-details" title="Permalink to this headline">¶</a></h2>
<p>შემდეგ ნაწილებში მოცემულია გარკვეული საცნობარო ინფორმაცია ფლეშ მეხსიერება დაშიფვრის მუშაობის შესახებ.</p>
<div class="section" id="flash-encryption-algorithm">
<span id="id6"></span><h3>ფლეშ დაშიფვრის ალგორითმი<a class="headerlink" href="flash-encryption.html#flash-encryption-algorithm" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">AES-256 მუშაობს მონაცემთა 16 ბაიტიან ბლოკებზე. ფლეშ მეხსიერება დაშიფვრის ძრავა მონაცემებს შიფრავს და გაშიფრავს 32 ბაიტიან ბლოკებში, ორ AES ბლოკში, რომლებიც მიმდევრობითაა განლაგებული.</p>
</li>
<li><p class="first">main ფლეშ მეხსიერება დაშიფვრის გასაღები ინახება eFuse-ში (BLOCK1) და სტანდარტულად დაცულია შემდგომი ჩაწერის ან პროგრამული უზრუნველყოფის წაკითხვისგან.</p>
</li>
<li><p class="first">AES-256 გასაღების ზომაა 256 ბიტი (32 ბაიტი), წაკითხულია eFuse ბლოკი 1-დან. აპარატურის AES ძრავა იყენებს გასაღებს უკუღმა ბაიტური თანმიმდევრობით, eFuse ბლოკში შენახული თანმიმდევრობით. - თუ <code class="docutils literal notranslate"><span class="pre">CODING_SCHEME</span></code> eFuse დაყენებულია 0-ზე (ნაგულისხმევი კოდირების სქემა „None“), მაშინ eFuse-ის გასაღების ბლოკი 256 ბიტიანია და გასაღები ინახება ისე, როგორც არის (შებრუნებული ბაიტების თანმიმდევრობით). - თუ <code class="docutils literal notranslate"><span class="pre">CODING_SCHEME</span></code> eFuse დაყენებულია 1-ზე (3/4 კოდირება), მაშინ eFuse გასაღების ბლოკი არის 192 ბიტი (შებრუნებული ბაიტების თანმიმდევრობით), ამიტომ საერთო ენტროპია მცირდება. აპარატურული ფლეშ მეხსიერება დაშიფვრა კვლავ მუშაობს 256-ბიტიან გასაღებზე, წაკითხვის (და შებრუნების გაუქმების) შემდეგ, გასაღები გაფართოვდება როგორც <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">key[0:255]</span> <span class="pre">+</span> <span class="pre">key[64:127]</span></code>.</p>
</li>
<li><p class="first">AES ალგორითმი ფლეშ მეხსიერება დაშიფვრაში ინვერსიულად გამოიყენება, ამიტომ ფლეშ მეხსიერება დაშიფვრის „დაშიფვრის“ ოპერაცია არის AES გაშიფვრა, ხოლო „გაშიფვრის“ ოპერაცია არის AES დაშიფვრა. ეს კეთდება შესრულების მიზნით და არ ცვლის ალგორითმის ეფექტურობას.</p>
</li>
<li><p class="first">თითოეული 32 ბაიტიანი ბლოკი (ორი მომიჯნავე 16 ბაიტიანი AES ბლოკი) დაშიფრულია უნიკალური გასაღებით. გასაღები მიღებულია eFuse-ში ფლეშ მეხსიერება მთავარი დაშიფვრის გასაღებიდან, რომელიც XOR-ით არის დამუშავებული ფლეშ მეხსიერება ში ამ ბლოკის ოფსეტით („გასაღების შეცვლა“).</p>
</li>
<li><p class="first">კონკრეტული პარამეტრი დამოკიდებულია პარამეტრზე <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CONFIG</span></code> eFuse. ეს არის 4 ბიტიანი eFuse, სადაც თითოეული ბიტი საშუალებას იძლევა გასაღები ბიტების კონკრეტული დიაპაზონის XOR-ის გამოყენების:</p>
<ul class="simple">
<li>გასაღების 1 ბიტი, 0-66 ბიტები XOR-ით არის დამუშავებული.</li>
<li>გასაღების მე-2 ბიტი, 67-131 ბიტები XOR-ით არის დამუშავებული.</li>
<li>გასაღების მე-3 ბიტი, 132-194 ბიტები XOR-ით არის დამუშავებული.</li>
<li>გასაღების მე-4 ბიტი, 195-256 ბიტები XOR-ით არის დამუშავებული.</li>
</ul>
<p>რეკომენდებულია, რომ <code class="docutils literal notranslate"><span class="pre">FLASH_CRYPT_CONFIG</span></code> ყოველთვის რჩება ნაგულისხმევი მნიშვნელობის დასაყენებლად <cite>0xF</cite>, ისე, რომ ყველა გასაღების ბიტი XOR-ით იყოს დამუშავებული ბლოკის ოფსეტით. იხილეთ <a class="reference internal" href="flash-encryption.html#setting-flash-crypt-config"><span class="std std-ref">FLASH_CRYPT_CONFIG-ის დაყენება</span></a> დეტალებისთვის.</p>
</li>
<li><p class="first">ბლოკის ოფსეტის ზედა 19 ბიტი (ბიტი 5-დან ბიტ 23-მდე) XOR-ით კონტროლდება ფლეშ მეხსიერება ძირითადი დაშიფვრის გასაღებით. ეს დიაპაზონი ორი მიზეზის გამოა შერჩეული: ფლეშ მეხსიერება მაქსიმალური ზომაა 16 მბ (24 ბიტი) და თითოეული ბლოკი 32 ბაიტია, ამიტომ ყველაზე ნაკლებად მნიშვნელოვანი 5 ბიტი ყოველთვის ნულის ტოლია.</p>
</li>
<li><p class="first">ფლეშ მეხსიერება დაშიფვრის გასაღების 256 ბიტთან 19 ბლოკ-ოფსეტის ბიტიდან თითოეული კონკრეტული შესაბამისობაა, რათა დადგინდეს, რომელი ბიტი რომელით არის XOR-ით დამუშავებული. იხილეთ ცვლადი <code class="docutils literal notranslate"><span class="pre">_FLASH_ENCRYPTION_TWEAK_PATTERN</span></code> ში <code class="docutils literal notranslate"><span class="pre">espsecure.py</span></code> სრული რუკების წყაროს კოდი.</p>
</li>
<li><p class="first">Python-ში დანერგილი ფლეშ მეხსიერება დაშიფვრის სრული ალგორითმის სანახავად იხილეთ <cite>_flash_encryption_operation()</cite> ფუნქცია <code class="docutils literal notranslate"><span class="pre">espsecure.py</span></code> საწყისი კოდი.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="../api-guides/freertos-smp.html" rel="next" title="ESP-IDF FreeRTOS SMP Changes">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="../api-guides/fatal-errors.html" rel="prev" title="Fatal Errors"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>