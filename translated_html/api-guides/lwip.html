
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>lwIP — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js" type="text/javascript"></script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../about.html" rel="author" title="About these documents"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="partition-tables.html" rel="next" title="Partition Tables"/>
<link href="linker-script-generation.html" rel="prev" title="Linker Script Generation"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/lwip.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-guides/lwip"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-guides/lwip.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API სახელმძღვანელოები</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="blufi.html">BluFi</a></li>
<li class="toctree-l2"><a class="reference internal" href="bootloader.html">ჩატვირთვის სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">სისტემის შექმნა</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system-legacy.html">სისტემის შექმნა (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">კონსოლის კომპონენტი</a></li>
<li class="toctree-l2"><a class="reference internal" href="deep-sleep-stub.html">ღრმა ძილის გაღვიძების სტატიები</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">შეცდომების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="esp-ble-mesh/ble-mesh-index.html">ESP-BLE-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="mesh.html">ESP-MESH ( Wi-Fi )</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_dump.html">ESP32 ბირთვის ნაგავსაყრელი</a></li>
<li class="toctree-l2"><a class="reference internal" href="event-handling.html">მოვლენების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-ram.html">გარე SPI-თან დაკავშირებული ოპერატიული მეხსიერება</a></li>
<li class="toctree-l2"><a class="reference internal" href="fatal-errors.html">ფატალური შეცდომები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/flash-encryption.html">ფლეშ დაშიფვრა</a></li>
<li class="toctree-l2"><a class="reference internal" href="freertos-smp.html">უფასო RTOS SMP ცვლილებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="general-notes.html">ზოგადი შენიშვნები</a></li>
<li class="toctree-l2"><a class="reference internal" href="hlinterrupts.html">მაღალი დონის შეფერხებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="jtag-debugging/index.html">JTAG-ის გამართვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="linker-script-generation.html">ლინკერის სკრიპტის გენერირება</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="lwip.html#">lwIP TCP/IP სტეკი</a><ul>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#supported-apis">მხარდაჭერილი API წმ</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#adapted-apis">ადაპტირებული API წმ</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#bsd-sockets-api">BSD სოკეტები API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#references">ცნობები</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#examples">მაგალითები</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#supported-functions">მხარდაჭერილი ფუნქციები</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#socket-error-handling">სოკეტის შეცდომების დამუშავება</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#socket-options">სოკეტის პარამეტრები</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#fcntl">fcntl</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#ioctls">ioctls</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#netconn-api">Netconn API</a></li>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#lwip-freertos-task">lwIP უფასო RTOS დავალება</a></li>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#esp-lwip-custom-modifications">esp-lwip-ის მორგებული მოდიფიკაციები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#additions">დამატებები</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#limitations">შეზღუდვები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lwip.html#performance-optimization">შესრულების ოპტიმიზაცია</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#maximum-throughput">მაქსიმალური გამტარუნარიანობა</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#minimum-latency">მინიმალური შეყოვნება</a></li>
<li class="toctree-l4"><a class="reference internal" href="lwip.html#minimum-ram-usage">მინიმალური ოპერატიული მეხსიერების გამოყენება</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="partition-tables.html">დანაყოფის ცხრილები</a></li>
<li class="toctree-l2"><a class="reference internal" href="RF_calibration.html">რადიოსიხშირული კალიბრაცია</a></li>
<li class="toctree-l2"><a class="reference internal" href="romconsole.html">ROM გამართვა კონსოლი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/secure-boot.html">უსაფრთხო ჩატვირთვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread-local-storage.html">ძაფების ლოკალური საცავი</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools/index.html">ხელსაწყოები</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp.html">ULP კოპროცესორი</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp-legacy.html">ULP კოპროცესორი (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests-legacy.html">ერთეულის ტესტირება (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests.html">ერთეულის ტესტირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi.html">WiFi დრაივერი</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../index.html">დოკუმენტები</a> »</li>
<li><a href="index.html">API სახელმძღვანელოები</a> »</li>
<li>lwIP</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-guides/lwip.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="lwip">
<h1>lwIP<a class="headerlink" href="lwip.html#lwip" title="Permalink to this headline">¶</a></h1>
<p>ESP-IDF იყენებს ღია კოდს <a class="reference external" href="https://savannah.nongnu.org/projects/lwip/">lwIP მსუბუქი TCP/IP სტეკი</a>. lwIP-ის ESP-IDF ვერსია (<a class="reference external" href="https://github.com/espressif/esp-lwip">esp-lwip</a>)-ს აქვს გარკვეული ცვლილებები და დამატებები ზედა დინების პროექტთან შედარებით.</p>
<div class="section" id="supported-apis">
<h2>მხარდაჭერილი API წმ<a class="headerlink" href="lwip.html#supported-apis" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF მხარს უჭერს შემდეგ lwIP TCP/IP დასტის ფუნქციებს:</p>
<ul class="simple">
<li><a class="reference internal" href="lwip.html#bsd-sockets-api">BSD სოკეტები API</a></li>
<li><a class="reference internal" href="lwip.html#netconn-api">Netconn API</a> ჩართულია, მაგრამ ოფიციალურად არ არის მხარდაჭერილი ESP-IDF აპლიკაციებისთვის</li>
</ul>
<div class="section" id="adapted-apis">
<h3>ადაპტირებული API წმ<a class="headerlink" href="lwip.html#adapted-apis" title="Permalink to this headline">¶</a></h3>
<p>ზოგიერთი გავრცელებული lwIP „აპლიკაციის“ API ირიბად მხარდაჭერილია ESP-IDF მიერ:</p>
<ul class="simple">
<li>DHCP სერვერი და კლიენტი მხარდაჭერილია არაპირდაპირი გზით <a class="reference internal" href="../api-reference/network/esp_netif.html"><span class="doc">ESP-NETIF</span></a> ფუნქციონალურობა</li>
<li>მარტივი ქსელის დროის პროტოკოლი (SNTP) მხარდაჭერილია <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/lwip/include/apps/sntp/sntp.h">lwip/include/apps/sntp/sntp.h</a> <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/lwip/lwip/src/inlude/lwip/apps/sntp.h">lwip/lwip/src/inlude/lwip/apps/sntp.h</a> ფუნქციები (იხილეთ აგრეთვე <a class="reference internal" href="../api-reference/system/system_time.html#system-time-sntp-sync"><span class="std std-ref">SNTP დროის სინქრონიზაცია</span></a>)</li>
<li>ICMP პინგი მხარდაჭერილია lwIP ping API ვარიაციის გამოყენებით8. იხილეთ <a class="reference internal" href="../api-reference/protocols/icmp_echo.html"><span class="doc">ICMP Echo</span></a>.</li>
<li>NetBIOS-ის ძიება ხელმისაწვდომია სტანდარტული lwIP API გამოყენებით. <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/http_server/restful_server">პროტოკოლები/http_სერვერი/restful_სერვერი</a> აქვს NetBIOS-ის გამოყენებით ლოკალურ ქსელში ჰოსტის მოსაძებნად დემონსტრირების ვარიანტი.</li>
<li>mDNS იყენებს lwIP-ის ნაგულისხმევი mDNS-ისგან განსხვავებულ იმპლემენტაციას (იხ. <a class="reference internal" href="../api-reference/protocols/mdns.html"><span class="doc">mDNS სერვისი</span></a>), მაგრამ lwIP-ს შეუძლია mDNS ჰოსტების მოძიება სტანდარტული API ის გამოყენებით, როგორიცაა <code class="docutils literal notranslate"><span class="pre">gethostbyname()</span></code> და კონვენცია <code class="docutils literal notranslate"><span class="pre">hostname.local</span></code>, იმ პირობით, რომ <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-dns-support-mdns-queries"><span class="std std-ref">CONFIG_LWIP_DNS_SUPPORT_MDNS_QUERIES</span></a> პარამეტრი ჩართულია.</li>
</ul>
</div>
</div>
<div class="section" id="bsd-sockets-api">
<h2>BSD სოკეტები API<a class="headerlink" href="lwip.html#bsd-sockets-api" title="Permalink to this headline">¶</a></h2>
<p>BSD სოკეტები API არის გავრცელებული პლატფორმული TCP/IP სოკეტი API , რომელიც წარმოიშვა UNIX-ის Berkeley Standard Distribution-ში, მაგრამ ამჟამად სტანდარტიზებულია POSIX სპეციფიკაციის ნაწილში. BSD სოკეტებს ზოგჯერ POSIX სოკეტებს ან Berkeley Sockets-ს უწოდებენ.</p>
<p>როგორც ESP-IDF შია დანერგილი, lwIP მხარს უჭერს BSD სოკეტების API ყველა გავრცელებულ გამოყენებას.</p>
<div class="section" id="references">
<h3>ცნობები<a class="headerlink" href="lwip.html#references" title="Permalink to this headline">¶</a></h3>
<p>ხელმისაწვდომია BSD Sockets-ის საცნობარო მასალების ფართო სპექტრი, მათ შორის:</p>
<ul class="simple">
<li><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/007908799/xnsix.html">ერთიანი UNIX სპეციფიკაციის BSD სოკეტების გვერდი</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Berkeley_sockets">ბერკლის სოკეტების ვიკიპედიის გვერდი</a></li>
</ul>
</div>
<div class="section" id="examples">
<h3>მაგალითები<a class="headerlink" href="lwip.html#examples" title="Permalink to this headline">¶</a></h3>
<p>ESP-IDF ის რამდენიმე მაგალითი გვიჩვენებს, თუ როგორ გამოვიყენოთ BSD სოკეტები API s:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/sockets/tcp_server">პროტოკოლები/სოკეტები/tcp_სერვერი</a></li>
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/sockets/tcp_client">პროტოკოლები/სოკეტები/tcp_კლიენტი</a></li>
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/sockets/udp_server">პროტოკოლები/სოკეტები/udp_server</a></li>
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/sockets/udp_client">პროტოკოლები/სოკეტები/udp_კლიენტი</a></li>
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/sockets/udp_multicast">პროტოკოლები/სოკეტები/udp_multicast</a></li>
<li><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/http_request">პროტოკოლები/http_მოთხოვნა</a> (შენიშვნა: ეს არის TCP სოკეტის HTTP მოთხოვნის გასაგზავნად გამოყენების გამარტივებული მაგალითი. <a class="reference internal" href="../api-reference/protocols/esp_http_client.html"><span class="doc">ESP HTTP კლიენტი</span></a> HTTP მოთხოვნების გასაგზავნად გაცილებით უკეთესი ვარიანტია.)</li>
</ul>
</div>
<div class="section" id="supported-functions">
<h3>მხარდაჭერილი ფუნქციები<a class="headerlink" href="lwip.html#supported-functions" title="Permalink to this headline">¶</a></h3>
<p>მხარდაჭერილია შემდეგი BSD socket API ფუნქციები. სრული დეტალებისთვის იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/lwip/lwip/src/include/lwip/sockets.h">lwip/lwip/src/include/lwip/sockets.h</a>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">socket()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">bind()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">accept()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">getpeername()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">getsockopt()</span></code> და <code class="docutils literal notranslate"><span class="pre">setsockopt()</span></code> (იხ. <a class="reference internal" href="lwip.html#socket-options">სოკეტის პარამეტრები</a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">close()</span></code> (მეშვეობით <a class="reference internal" href="../api-reference/storage/vfs.html"><span class="doc">ვირტუალური ფაილური სისტემა კომპონენტი</span></a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">read()</span></code>, <code class="docutils literal notranslate"><span class="pre">readv()</span></code>, <code class="docutils literal notranslate"><span class="pre">write()</span></code>, <code class="docutils literal notranslate"><span class="pre">writev()</span></code> (მეშვეობით <a class="reference internal" href="../api-reference/storage/vfs.html"><span class="doc">ვირტუალური ფაილური სისტემა კომპონენტი</span></a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">recv()</span></code>, <code class="docutils literal notranslate"><span class="pre">recvmsg()</span></code>, <code class="docutils literal notranslate"><span class="pre">recvfrom()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">send()</span></code>, <code class="docutils literal notranslate"><span class="pre">sendmsg()</span></code>, <code class="docutils literal notranslate"><span class="pre">sendto()</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">select()</span></code> (მეშვეობით <a class="reference internal" href="../api-reference/storage/vfs.html"><span class="doc">ვირტუალური ფაილური სისტემა კომპონენტი</span></a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">poll()</span></code> (შენიშვნა: ESP-IDF -ზე, <code class="docutils literal notranslate"><span class="pre">poll()</span></code> იმპლემენტირებულია select-ის შიდა გამოძახებით, ამიტომ გამოიყენება <code class="docutils literal notranslate"><span class="pre">select()</span></code> პირდაპირ რეკომენდებულია, თუ მეთოდების არჩევანი ხელმისაწვდომია.)</li>
<li><code class="docutils literal notranslate"><span class="pre">fcntl()</span></code> (იხ. <a class="reference internal" href="lwip.html#fcntl">fcntl</a>)</li>
</ul>
<p>არასტანდარტული ფუნქციები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> (იხ. <a class="reference internal" href="lwip.html#ioctls">ioctls</a>)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ზოგიერთი lwIP აპლიკაციის ნიმუშის კოდი იყენებს BSD API ის პრეფიქსირებულ ვერსიებს, მაგალითად <code class="docutils literal notranslate"><span class="pre">lwip_socket()</span></code> სტანდარტის ნაცვლად <code class="docutils literal notranslate"><span class="pre">socket()</span></code>ორივე ფორმის გამოყენება შესაძლებელია ESP-IDF თან ერთად, თუმცა რეკომენდებულია სტანდარტული სახელების გამოყენება.</p>
</div>
</div>
<div class="section" id="socket-error-handling">
<h3>სოკეტის შეცდომების დამუშავება<a class="headerlink" href="lwip.html#socket-error-handling" title="Permalink to this headline">¶</a></h3>
<p>BSD სოკეტის შეცდომების დამუშავების კოდი ძალიან მნიშვნელოვანია საიმედო სოკეტის აპლიკაციებისთვის. როგორც წესი, სოკეტის შეცდომების დამუშავება მოიცავს შემდეგ ასპექტებს:</p>
<ul class="simple">
<li>შეცდომის აღმოჩენა.</li>
<li>შეცდომის მიზეზის კოდის მიღება.</li>
<li>შეცდომა დაამუშავეთ მიზეზის კოდის მიხედვით.</li>
</ul>
<p>lwIP-ში, სოკეტის შეცდომების დამუშავების ორი განსხვავებული სცენარი გვაქვს:</p>
<ul class="simple">
<li>Socket API აბრუნებს შეცდომას. დამატებითი ინფორმაციისთვის იხილეთ <a class="reference internal" href="lwip.html#socket-api-errors">Socket API შეცდომები</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">select(int</span> <span class="pre">maxfdp1,</span> <span class="pre">fd_set</span> <span class="pre">*readset,</span> <span class="pre">fd_set</span> <span class="pre">*writeset,</span> <span class="pre">fd_set</span> <span class="pre">*exceptset,</span> <span class="pre">struct</span> <span class="pre">timeval</span> <span class="pre">*timeout)</span></code> აქვს გამონაკლისის აღწერილობა, რომელიც მიუთითებს, რომ სოკეტს შეცდომა აქვს. დამატებითი ინფორმაციისთვის იხილეთ <a class="reference internal" href="lwip.html#select-errors">select() შეცდომები</a>.</li>
</ul>
<div class="section" id="socket-api-errors">
<h4>Socket API შეცდომები<a class="headerlink" href="lwip.html#socket-api-errors" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>The error detection</dt>
<dd><ul class="first last simple">
<li>ჩვენ შეგვიძლია ვიცოდეთ, რომ socket API ვერ ხერხდება მისი დაბრუნებული მნიშვნელობის მიხედვით.</li>
</ul>
</dd>
<dt>Get the error reason code</dt>
<dd><ul class="first last simple">
<li>როდესაც socket API ვერ ხერხდება, დაბრუნებული მნიშვნელობა არ შეიცავს შეცდომის მიზეზს და აპლიკაციას შეუძლია მიიღოს შეცდომის მიზეზის კოდი errno-ზე წვდომით. სხვადასხვა მნიშვნელობა სხვადასხვა მნიშვნელობას მიუთითებს. დამატებითი ინფორმაციისთვის იხილეთ<a class="reference internal" href="lwip.html#socket-error-reason-code">სოკეტის შეცდომის მიზეზის კოდი</a>&amp;gt;</li>
</ul>
</dd>
</dl>
<p>მაგალითი:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">err</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">sockfd</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">error</span> <span class="n">code</span> <span class="ow">is</span> <span class="n">obtained</span> <span class="kn">from</span> <span class="nn">errno</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="select-errors">
<h4>select() შეცდომები<a class="headerlink" href="lwip.html#select-errors" title="Permalink to this headline">¶</a></h4>
<dl class="docutils">
<dt>The error detection</dt>
<dd><ul class="first last simple">
<li>სოკეტის შეცდომა, როდესაც <code class="docutils literal notranslate"><span class="pre">select()</span></code> აქვს გამონაკლისის აღმწერი</li>
</ul>
</dd>
<dt>Get the error reason code</dt>
<dd><ul class="first last simple">
<li>თუ <code class="docutils literal notranslate"><span class="pre">select</span></code> მიუთითებს, რომ სოკეტი ვერ მუშაობს, errno-ს გამოყენებით შეცდომის მიზეზის კოდს ვერ ვიღებთ, ამის ნაცვლად უნდა გამოვიძახოთ <code class="docutils literal notranslate"><span class="pre">getsockopt()</span></code> წარუმატებლობის მიზეზის კოდის მისაღებად. იმიტომ, რომ <code class="docutils literal notranslate"><span class="pre">select()</span></code> გამონაკლისის აღმწერი აქვს, შეცდომის კოდი errno-ს არ მიენიჭება.</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">getsockopt</span></code> ფუნქციის პროტოტიპი <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">getsockopt(int</span> <span class="pre">s,</span> <span class="pre">int</span> <span class="pre">level,</span> <span class="pre">int</span> <span class="pre">optname,</span> <span class="pre">void</span> <span class="pre">*optval,</span> <span class="pre">socklen_t</span> <span class="pre">*optlen)</span></code>მისი ფუნქციაა ნებისმიერი ტიპის, ნებისმიერი მდგომარეობის სოკეტის ოფციის მიმდინარე მნიშვნელობის მიღება და შედეგის optval-ში შენახვა. მაგალითად, როდესაც სოკეტზე შეცდომის კოდს იღებთ, მისი მიღება შეგიძლიათ შემდეგნაირად: <code class="docutils literal notranslate"><span class="pre">getsockopt(sockfd,</span> <span class="pre">SOL_SOCKET,</span> <span class="pre">SO_ERROR,</span> <span class="pre">&amp;err,</span> <span class="pre">&amp;optlen)</span></code>.</p>
</div>
<p>მაგალითი:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">int</span> <span class="n">err</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">sockfd</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exfds</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tval</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exfds</span><span class="p">))</span> <span class="p">{</span>
        <span class="o">//</span> <span class="n">select</span><span class="p">()</span> <span class="n">exception</span> <span class="nb">set</span> <span class="n">using</span> <span class="n">getsockopt</span><span class="p">()</span>
        <span class="nb">int</span> <span class="n">optlen</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">);</span>
        <span class="n">getsockopt</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_ERROR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optlen</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="socket-error-reason-code">
<h4>სოკეტის შეცდომის მიზეზის კოდი<a class="headerlink" href="lwip.html#socket-error-reason-code" title="Permalink to this headline">¶</a></h4>
<p>ქვემოთ მოცემულია გავრცელებული შეცდომების კოდების სია. უფრო დეტალური შეცდომების კოდებისთვის, გთხოვთ, მიმართოთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/components/newlib/include/sys/errno.h">newlib/include/sys/errno.h</a></p>
<table border="1" class="docutils">
<colgroup>
<col width="31%"/>
<col width="69%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">შეცდომის კოდი</th>
<th class="head">აღწერა</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ეკონმა უარი თქვა</td>
<td>დაკავშირება უარყოფილია</td>
</tr>
<tr class="row-odd"><td>EADDRINUSE</td>
<td>მისამართი უკვე გამოიყენება</td>
</tr>
<tr class="row-even"><td>ეკონაბორტედი</td>
<td>პროგრამულმა უზრუნველყოფამ კავშირის შეწყვეტა გამოიწვია</td>
</tr>
<tr class="row-odd"><td>ენეტუნრიჩი</td>
<td>ქსელი მიუწვდომელია</td>
</tr>
<tr class="row-even"><td>ENETDOWN</td>
<td>ქსელის ინტერფეისი არ არის კონფიგურირებული</td>
</tr>
<tr class="row-odd"><td>ETIMEDAUT</td>
<td>კავშირის დრო ამოიწურა</td>
</tr>
<tr class="row-even"><td>ელექტრონული ჰოსტდაუნი</td>
<td>მასპინძელი გათიშულია</td>
</tr>
<tr class="row-odd"><td>ეჰოსტანრიჩი</td>
<td>მასპინძელი მიუწვდომელია</td>
</tr>
<tr class="row-even"><td>EINPROGRESS</td>
<td>კავშირი უკვე მიმდინარეობს</td>
</tr>
<tr class="row-odd"><td>უკვე</td>
<td>სოკეტი უკვე დაკავშირებულია</td>
</tr>
<tr class="row-even"><td>EDESTADDRREQ</td>
<td>დანიშნულების მისამართი სავალდებულოა</td>
</tr>
<tr class="row-odd"><td>EPROTONOSUPPORT</td>
<td>უცნობი პროტოკოლი</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="socket-options">
<h3>სოკეტის პარამეტრები<a class="headerlink" href="lwip.html#socket-options" title="Permalink to this headline">¶</a></h3>
<p>ის <code class="docutils literal notranslate"><span class="pre">getsockopt()</span></code> და <code class="docutils literal notranslate"><span class="pre">setsockopt()</span></code> ფუნქციები საშუალებას იძლევა თითოეული სოკეტის პარამეტრების მიღების/დაყენების.</p>
<p>lwIP ESP-IDF ში ყველა სტანდარტული სოკეტის ოფციას არ უჭერს მხარს. მხარდაჭერილია შემდეგი სოკეტის ოფციები:</p>
<div class="section" id="common-options">
<h4>საერთო ვარიანტები<a class="headerlink" href="lwip.html#common-options" title="Permalink to this headline">¶</a></h4>
<p>გამოიყენება დონის არგუმენტთან ერთად <code class="docutils literal notranslate"><span class="pre">SOL_SOCKET</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SO_REUSEADDR</span></code> (ხელმისაწვდომია თუ <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-so-reuse"><span class="std std-ref">CONFIG_LWIP_SO_REUSE</span></a> დაყენებულია, ქცევის მორგება შესაძლებელია დაყენებით <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-so-reuse-rxtoall"><span class="std std-ref">CONFIG_LWIP_SO_REUSE_RXTOALL</span></a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">SO_KEEPALIVE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SO_BROADCAST</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SO_ACCEPTCONN</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SO_RCVBUF</span></code> (ხელმისაწვდომია თუ <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-so-rcvbuf"><span class="std std-ref">CONFIG_LWIP_SO_RCVBUF</span></a> დაყენებულია)</li>
<li><code class="docutils literal notranslate"><span class="pre">SO_SNDTIMEO</span></code> / <code class="docutils literal notranslate"><span class="pre">SO_RCVTIMEO</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SO_ERROR</span></code> (ეს ვარიანტი გამოიყენება მხოლოდ <code class="docutils literal notranslate"><span class="pre">select()</span></code>, იხილეთ <a class="reference internal" href="lwip.html#socket-error-handling">სოკეტის შეცდომების დამუშავება</a>)</li>
<li><code class="docutils literal notranslate"><span class="pre">SO_TYPE</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">SO_NO_CHECK</span></code> (მხოლოდ UDP სოკეტებისთვის)</li>
</ul>
</div>
<div class="section" id="ip-options">
<h4>IP პარამეტრები<a class="headerlink" href="lwip.html#ip-options" title="Permalink to this headline">¶</a></h4>
<p>გამოიყენება დონის არგუმენტთან ერთად <code class="docutils literal notranslate"><span class="pre">IPPROTO_IP</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IP_TOS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_TTL</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_PKTINFO</span></code> (ხელმისაწვდომია თუ <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-netbuf-recvinfo"><span class="std std-ref">CONFIG_LWIP_NETBUF_RECVINFO</span></a> დაყენებულია)</li>
</ul>
<p>მულტიკასტ UDP სოკეტებისთვის:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IP_MULTICAST_IF</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_MULTICAST_LOOP</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_MULTICAST_TTL</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_ADD_MEMBERSHIP</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IP_DROP_MEMBERSHIP</span></code></li>
</ul>
</div>
<div class="section" id="tcp-options">
<h4>TCP-ის პარამეტრები<a class="headerlink" href="lwip.html#tcp-options" title="Permalink to this headline">¶</a></h4>
<p>მხოლოდ TCP სოკეტები. გამოიყენება level არგუმენტთან ერთად <code class="docutils literal notranslate"><span class="pre">IPPROTO_TCP</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code></li>
</ul>
<p>TCP keepalive ზონდებთან დაკავშირებული ვარიანტები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">TCP_KEEPALIVE</span></code> (int მნიშვნელობა, TCP-ის შენახვის პერიოდი მილიწამებში)</li>
<li><code class="docutils literal notranslate"><span class="pre">TCP_KEEPIDLE</span></code> (იგივეა, რაც <code class="docutils literal notranslate"><span class="pre">TCP_KEEPALIVE</span></code>, მაგრამ მნიშვნელობა წამებშია)</li>
<li><code class="docutils literal notranslate"><span class="pre">TCP_KEEPINTVL</span></code> (int მნიშვნელობა, keepalive ზონდებს შორის ინტერვალი წამებში)</li>
<li><code class="docutils literal notranslate"><span class="pre">TCP_KEEPCNT</span></code> (int მნიშვნელობა, keepalive ზონდების რაოდენობა ვადის ამოწურვამდე)</li>
</ul>
</div>
<div class="section" id="ipv6-options">
<h4>IPv6 პარამეტრები<a class="headerlink" href="lwip.html#ipv6-options" title="Permalink to this headline">¶</a></h4>
<p>მხოლოდ IPv6 სოკეტები. გამოიყენება level არგუმენტთან ერთად <code class="docutils literal notranslate"><span class="pre">IPPROTO_IPV6</span></code></p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IPV6_CHECKSUM</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IPV6_V6ONLY</span></code></li>
</ul>
<p>მულტიკასტ IPv6 UDP სოკეტებისთვის:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">IPV6_JOIN_GROUP</span></code> / <code class="docutils literal notranslate"><span class="pre">IPV6_ADD_MEMBERSHIP</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IPV6_LEAVE_GROUP</span></code> / <code class="docutils literal notranslate"><span class="pre">IPV6_DROP_MEMBERSHIP</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IPV6_MULTICAST_IF</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IPV6_MULTICAST_HOPS</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">IPV6_MULTICAST_LOOP</span></code></li>
</ul>
</div>
</div>
<div class="section" id="fcntl">
<h3>fcntl<a class="headerlink" href="lwip.html#fcntl" title="Permalink to this headline">¶</a></h3>
<p>ის <code class="docutils literal notranslate"><span class="pre">fcntl()</span></code> ფუნქცია არის სტანდარტული API ფაილის აღმწერთან დაკავშირებული პარამეტრების მანიპულირებისთვის. ESP-IDF -ში, <a class="reference internal" href="../api-reference/storage/vfs.html"><span class="doc">ვირტუალური ფაილური სისტემა კომპონენტი</span></a> ფენა გამოიყენება ამ ფუნქციის განსახორციელებლად.</p>
<p>როდესაც ფაილის აღწერილობა სოკეტია, მხოლოდ შემდეგი <code class="docutils literal notranslate"><span class="pre">fcntl()</span></code> მხარდაჭერილია შემდეგი მნიშვნელობები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code> არაბლოკირებადი შემავალი/გამომავალი რეჟიმის დასაყენებლად/გასაუქმებლად. ასევე მხარს უჭერს <code class="docutils literal notranslate"><span class="pre">O_NDELAY</span></code>, რომელიც იდენტურია <code class="docutils literal notranslate"><span class="pre">O_NONBLOCK</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">O_RDONLY</span></code>, <code class="docutils literal notranslate"><span class="pre">O_WRONLY</span></code>, <code class="docutils literal notranslate"><span class="pre">O_RDWR</span></code> სხვადასხვა წაკითხვის/ჩაწერის რეჟიმების დროშები. მათი წაკითხვა შესაძლებელია <code class="docutils literal notranslate"><span class="pre">F_GETFL</span></code> მხოლოდ, მათი დაყენება შეუძლებელია გამოყენებით <code class="docutils literal notranslate"><span class="pre">F_SETFL</span></code>TCP სოკეტი დააბრუნებს განსხვავებულ რეჟიმს იმის მიხედვით, კავშირი დაიხურა რომელიმე ბოლოში თუ კვლავ ღიაა ორივე ბოლოში. UDP სოკეტები ყოველთვის აბრუნებენ <code class="docutils literal notranslate"><span class="pre">O_RDWR</span></code>.</li>
</ul>
</div>
<div class="section" id="ioctls">
<h3>ioctls<a class="headerlink" href="lwip.html#ioctls" title="Permalink to this headline">¶</a></h3>
<p>ის <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> ფუნქცია უზრუნველყოფს ნახევრად სტანდარტულ გზას TCP/IP დასტის ზოგიერთ შიდა ფუნქციაზე წვდომისთვის. ESP-IDF ში, <a class="reference internal" href="../api-reference/storage/vfs.html"><span class="doc">ვირტუალური ფაილური სისტემა კომპონენტი</span></a> ფენა გამოიყენება ამ ფუნქციის განსახორციელებლად.</p>
<p>როდესაც ფაილის აღწერილობა სოკეტია, მხოლოდ შემდეგი <code class="docutils literal notranslate"><span class="pre">ioctl()</span></code> მხარდაჭერილია შემდეგი მნიშვნელობები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">FIONREAD</span></code> აბრუნებს სოკეტის ქსელურ ბუფერში უკვე მიღებული მოლოდინის რეჟიმში მყოფი მონაცემების ბაიტების რაოდენობას.</li>
<li><code class="docutils literal notranslate"><span class="pre">FIONBIO</span></code> არის სოკეტისთვის არაბლოკირებადი შეყვანის/გამოყვანის სტატუსის დაყენების/გასუფთავების ალტერნატიული გზა, ექვივალენტურია <code class="docutils literal notranslate"><span class="pre">fcntl(fd,</span> <span class="pre">F_SETFL,</span> <span class="pre">O_NONBLOCK,</span> <span class="pre">...)</span></code>.</li>
</ul>
</div>
</div>
<div class="section" id="netconn-api">
<h2>Netconn API<a class="headerlink" href="lwip.html#netconn-api" title="Permalink to this headline">¶</a></h2>
<p>lwIP მხარს უჭერს ორ ქვედა დონის API ს, ასევე BSD სოკეტებს API : Netconn API და Raw API .</p>
<p>lwIP Raw API შექმნილია ერთძაფიანი მოწყობილობებისთვის და არ არის მხარდაჭერილი ESP-IDF ში.</p>
<p>Netconn API გამოიყენება BSD Sockets API lwIP-ში იმპლემენტაციისთვის და მისი გამოძახება ასევე შესაძლებელია პირდაპირ ESP-IDF აპლიკაციებიდან. ამ API უფრო ნაკლები რესურსი აქვს, ვიდრე BSD Sockets API ს, კერძოდ, მას შეუძლია მონაცემების გაგზავნა და მიღება მათი შიდა lwIP ბუფერებში კოპირების გარეშე.</p>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">Espressif არ ამოწმებს Netconn API ESP-IDF ში. შესაბამისად, ეს ფუნქციონალი <em>ჩართულია, მაგრამ არ არის მხარდაჭერილი</em>ზოგიერთი ფუნქცია შეიძლება სწორად მხოლოდ BSD Sockets API დან გამოყენებისას იმუშაოს.</p>
</div>
<p>Netconn API შესახებ დამატებითი ინფორმაციისთვის იხილეთ <a class="reference external" href="http://www.nongnu.org/lwip/2_0_x/api_8h.html">lwip/lwip/src/include/lwip/api.h</a> და <a class="reference external" href="https://lwip.fandom.com/wiki/Netconn_API">ეს ვიკი გვერდი, რომელიც lwIP აპლიკაციების შემქმნელების არაოფიციალური სახელმძღვანელოს ნაწილია</a>.</p>
</div>
<div class="section" id="lwip-freertos-task">
<h2>lwIP უფასო RTOS დავალება<a class="headerlink" href="lwip.html#lwip-freertos-task" title="Permalink to this headline">¶</a></h2>
<p>lwIP ქმნის სპეციალურ TCP/IP Free RTOS დავალებას სხვა დავალებებიდან socket API მოთხოვნების დასამუშავებლად.</p>
<p>TCP/IP დავალებიდან მონაცემების გასაგზავნად/გასაგზავნად გამოყენებული რიგების („საფოსტო ყუთები“) შესაცვლელად ხელმისაწვდომია კონფიგურაციის რამდენიმე ელემენტი:</p>
<ul class="simple">
<li><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcpip-recvmbox-size"><span class="std std-ref">CONFIG_LWIP_TCPIP_RECVMBOX_SIZE</span></a></li>
<li><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcpip-task-stack-size"><span class="std std-ref">CONFIG_LWIP_TCPIP_TASK_STACK_SIZE</span></a></li>
<li><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcpip-task-affinity"><span class="std std-ref">CONFIG_LWIP_TCPIP_TASK_AFFINITY</span></a></li>
</ul>
</div>
<div class="section" id="esp-lwip-custom-modifications">
<h2>esp-lwip-ის მორგებული მოდიფიკაციები<a class="headerlink" href="lwip.html#esp-lwip-custom-modifications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="additions">
<h3>დამატებები<a class="headerlink" href="lwip.html#additions" title="Permalink to this headline">¶</a></h3>
<p>დამატებულია შემდეგი კოდი, რომელიც არ არის lwIP-ის ახალ ვერსიაში:</p>
<div class="section" id="thread-safe-sockets">
<h4>ხრახნიანი უსაფრთხო ბუდეები<a class="headerlink" href="lwip.html#thread-safe-sockets" title="Permalink to this headline">¶</a></h4>
<p>შესაძლებელია <code class="docutils literal notranslate"><span class="pre">close()</span></code> სოკეტი, რომელიც შექმნილია იმ ძაფისგან განსხვავებული ძაფისგან. <code class="docutils literal notranslate"><span class="pre">close()</span></code> გამოძახება დაიბლოკება მანამ, სანამ სხვა დავალებებიდან ამ სოკეტის გამოყენებით მიმდინარე ფუნქციის გამოძახებები არ დაბრუნდება.</p>
</div>
<div class="section" id="on-demand-timers">
<h4>მოთხოვნისამებრ ტაიმერები<a class="headerlink" href="lwip.html#on-demand-timers" title="Permalink to this headline">¶</a></h4>
<p>lwIP IGMP-ისა და MLD6-ის ფუნქციები ორივე ინიციალიზაციას უკეთებს ტაიმერს, რათა გარკვეულ დროს ტაიმ-აუტის მოვლენები გააქტიურდეს.</p>
<p>lwIP-ის ნაგულისხმევი იმპლემენტაცია ამ ტაიმერებს მუდმივად ჩართული ყოფნის საშუალებას აძლევს, მაშინაც კი, თუ ტაიმ-აუტის მოვლენები არ არის აქტიური. ეს ზრდის პროცესორის გამოყენებას და ენერგიის მოხმარებას ავტომატური მსუბუქი ძილის რეჟიმის გამოყენებისას. <code class="docutils literal notranslate"><span class="pre">esp-lwip</span></code> ნაგულისხმევი ქცევაა თითოეული ტაიმერის „მოთხოვნისამებრ“ დაყენება, რათა ის მხოლოდ მაშინ ჩაირთოს, როდესაც მოვლენა მოლოდინშია.</p>
<p>lwIP-ის ნაგულისხმევ ქცევაზე (ყოველთვის ჩართული ტაიმერები) დასაბრუნებლად, გამორთეთ <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-timers-ondemand"><span class="std std-ref">CONFIG_LWIP_TIMERS_ONDEMAND</span></a>.</p>
</div>
<div class="section" id="abort-tcp-connections-when-ip-changes">
<h4>TCP კავშირების შეწყვეტა IP მისამართის შეცვლისას<a class="headerlink" href="lwip.html#abort-tcp-connections-when-ip-changes" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcp-keep-connection-when-ip-changes"><span class="std std-ref">CONFIG_LWIP_TCP_KEEP_CONNECTION_WHEN_IP_CHANGES</span></a> ნაგულისხმევად გამორთულია. ეს გამორთავს lwIP-ის ნაგულისხმევ ქცევას, რომელიც TCP კავშირების ღიად შენარჩუნებას გულისხმობს, თუ ინტერფეისის IP მისამართი შეიცვლება, იმ შემთხვევაში, თუ ინტერფეისის IP მისამართი ისევ შეიცვლება (მაგალითად, თუ ინტერფეისის კავშირი გაითიშება და შემდეგ ისევ აღდგება). ჩართეთ ეს პარამეტრი, რათა TCP კავშირები ღიად დარჩეს ამ შემთხვევაში, სანამ მათი დრო ნორმალურად არ ამოიწურება. ამან შეიძლება გაზარდოს გამოყენებული სოკეტების რაოდენობა, თუ ქსელის ინტერფეისი დროებით გაითიშება.</p>
</div>
<div class="section" id="additional-socket-options">
<h4>დამატებითი სოკეტის პარამეტრები<a class="headerlink" href="lwip.html#additional-socket-options" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>დანერგილია IPV4 და IPV6 მულტიკასტ სოკეტის რამდენიმე სტანდარტული ვარიანტი (იხ. <cite>Socket Options</cite>).</li>
<li>შესაძლებელია მხოლოდ IPV6-ისთვის განკუთვნილი UDP და TCP სოკეტების დაყენება <code class="docutils literal notranslate"><span class="pre">IPV6_V6ONLY</span></code> სოკეტის ვარიანტი (ჩვეულებრივი lwIP მხოლოდ TCP-ია).</li>
</ul>
</div>
<div class="section" id="ip-layer-features">
<h4>IP ფენის მახასიათებლები<a class="headerlink" href="lwip.html#ip-layer-features" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>IPV4 წყაროზე დაფუძნებული მარშრუტიზაციის იმპლემენტაცია განსხვავებულია.</li>
<li>მხარდაჭერილია IPV4-თან დაკავშირებული IPV6 მისამართები.</li>
</ul>
</div>
</div>
<div class="section" id="limitations">
<h3>შეზღუდვები<a class="headerlink" href="lwip.html#limitations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>ზარი <code class="docutils literal notranslate"><span class="pre">send()</span></code> ან <code class="docutils literal notranslate"><span class="pre">sendto()</span></code> UDP სოკეტზე განმეორებით გამოყენებამ შესაძლოა საბოლოოდ გაფუჭდეს <code class="docutils literal notranslate"><span class="pre">errno</span></code> ტოლია <code class="docutils literal notranslate"><span class="pre">ENOMEM</span></code>ეს არის ბუფერების ზომების შეზღუდვა ქვედა ფენის ქსელური ინტერფეისის დრაივერებში. თუ დრაივერის ყველა გადაცემის ბუფერი სავსეა, მაშინ UDP გადაცემა ვერ მოხერხდება. აპლიკაციებმა, რომლებიც აგზავნიან UDP დატაგრამების დიდ რაოდენობას და არ სურთ, რომ გამგზავნმა რომელიმე მათგანი წაშალოს, უნდა შეამოწმონ ეს შეცდომის კოდი და მოკლე შეფერხების შემდეგ ხელახლა გაგზავნონ დატაგრამა. TX ბუფერების რაოდენობის გაზრდა <a class="reference internal" href="../api-reference/kconfig.html#config-esp32-wifi-tx-buffer"><span class="std std-ref">Wi-Fi</span></a> ან <a class="reference internal" href="../api-reference/kconfig.html#config-eth-dma-tx-buffer-num"><span class="std std-ref">Ethernet</span></a> პროექტის კონფიგურაცია (შესაბამისად) შეიძლება ასევე დაგეხმაროთ.</li>
</ul>
</div>
</div>
<div class="section" id="performance-optimization">
<h2>შესრულების ოპტიმიზაცია<a class="headerlink" href="lwip.html#performance-optimization" title="Permalink to this headline">¶</a></h2>
<p>TCP/IP-ის მუშაობა რთული საკითხია და მისი ოპტიმიზაცია შესაძლებელია მრავალი მიზნის მისაღწევად. ESP-IDF ის ნაგულისხმევი პარამეტრები მორგებულია გამტარუნარიანობას, შეყოვნებას და მეხსიერების ზომიერ გამოყენებას შორის კომპრომისზე.</p>
<div class="section" id="maximum-throughput">
<h3>მაქსიმალური გამტარუნარიანობა<a class="headerlink" href="lwip.html#maximum-throughput" title="Permalink to this headline">¶</a></h3>
<p>Espressif ამოწმებს ESP-IDF TCP/IP გამტარუნარიანობას <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/wifi/iperf">wifi/iperf</a> მაგალითად, RF დალუქულ კორპუსში.</p>
<p>ის <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/examples/wifi/iperf/sdkconfig.defaults">wifi/iperf/sdkconfig.defaults</a> iperf-ის მაგალითის ფაილი შეიცავს პარამეტრებს, რომლებიც ცნობილია TCP/IP გამტარუნარიანობის მაქსიმიზაციისთვის, როგორც წესი, ოპერატიული მეხსიერების გამოყენების გაზრდის ხარჯზე. აპლიკაციაში TCP/IP გამტარუნარიანობის მაქსიმალური მისაღებად სხვა ფაქტორების ხარჯზე, რეკომენდებულია ამ ფაილიდან პარამეტრების გამოყენება პროექტის sdkconfig ფაილში.</p>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last">შემოგვთავაზეთ ცვლილებების ერთდროულად რამდენჯერმე გამოყენება და თითოეული კონკრეტული აპლიკაციის დატვირთვისას მუშაობის შემოწმება.</p>
</div>
<ul class="simple">
<li>თუ სისტემაში ბევრი დავალება ერთმანეთს პროცესორის დროისთვის ეჯიბრება, გაითვალისწინეთ, რომ lwIP დავალებას აქვს კონფიგურირებადი CPU მსგავსება (<a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcpip-task-affinity"><span class="std std-ref">CONFIG_LWIP_TCPIP_TASK_AFFINITY</span></a>) და მუშაობს ფიქსირებული პრიორიტეტით <code class="docutils literal notranslate"><span class="pre">ESP_TASK_TCPIP_PRIO</span></code> (18). კონფიგურირება გაუკეთეთ კონკურენტ დავალებებს ისე, რომ ისინი სხვა ბირთვზე იყოს მიმაგრებული ან უფრო დაბალი პრიორიტეტით შესრულდეს.</li>
<li>თუ იყენებთ <code class="docutils literal notranslate"><span class="pre">select()</span></code> ფუნქცია მხოლოდ სოკეტის არგუმენტებით, პარამეტრით <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-use-only-lwip-select"><span class="std std-ref">CONFIG_LWIP_USE_ONLY_LWIP_SELECT</span></a> გააკეთებს <code class="docutils literal notranslate"><span class="pre">select()</span></code> უფრო სწრაფად რეკავს.</li>
</ul>
<p>თუ იყენებთ Wi-Fi ქსელის ინტერფეისს, ასევე იხილეთ <a class="reference internal" href="wifi.html#wifi-buffer-usage"><span class="std std-ref">Wi-Fi ბუფერის გამოყენება</span></a>.</p>
</div>
<div class="section" id="minimum-latency">
<h3>მინიმალური შეყოვნება<a class="headerlink" href="lwip.html#minimum-latency" title="Permalink to this headline">¶</a></h3>
<p>ბუფერის ზომის გაზრდის გარდა, გამტარუნარიანობის გაზრდის ცვლილებების უმეტესობა ასევე შეამცირებს შეყოვნებას lwIP ფუნქციებში CPU-ს მიერ დახარჯული დროის შემცირებით.</p>
<ul class="simple">
<li>TCP სოკეტებისთვის, lwIP მხარს უჭერს სტანდარტის დაყენებას <code class="docutils literal notranslate"><span class="pre">TCP_NODELAY</span></code> Nagle-ის ალგორითმის გამოსართავად გამოიყენეთ დროშა.</li>
</ul>
</div>
<div class="section" id="minimum-ram-usage">
<span id="lwip-ram-usage"></span><h3>მინიმალური ოპერატიული მეხსიერების გამოყენება<a class="headerlink" href="lwip.html#minimum-ram-usage" title="Permalink to this headline">¶</a></h3>
<p>lwIP ოპერატიული მეხსიერების გამოყენების უმეტესი ნაწილი მოთხოვნისამებრ ხორციელდება, რადგან ოპერატიული მეხსიერება საჭიროებისამებრ გამოიყოფა გროვიდან. ამიტომ, RAM-ის გამოყენების შესამცირებლად lwIP პარამეტრების შეცვლამ შესაძლოა არ შეცვალოს ოპერატიული მეხსიერების გამოყენება უმოქმედობის მდგომარეობაში, მაგრამ შეიძლება შეცვალოს ის პიკური პერიოდის განმავლობაში.</p>
<ul class="simple">
<li>შემცირება <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-max-sockets"><span class="std std-ref">CONFIG_LWIP_MAX_სოკეტები</span></a> ამცირებს სისტემაში სოკეტების მაქსიმალურ რაოდენობას. ეს ასევე გამოიწვევს TCP სოკეტების წარმოქმნას <code class="docutils literal notranslate"><span class="pre">WAIT_CLOSE</span></code> მდგომარეობა უფრო სწრაფად დაიხუროს და გადამუშავდეს (საჭიროების შემთხვევაში, ახალი სოკეტის გასახსნელად), რაც კიდევ უფრო ამცირებს ოპერატიული მეხსიერების პიკურ გამოყენებას.</li>
<li>შემცირება <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcpip-recvmbox-size"><span class="std std-ref">CONFIG_LWIP_TCPIP_RECVMBOX_SIZE</span></a>, <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-tcp-recvmbox-size"><span class="std std-ref">CONFIG_LWIP_TCP_RECVMBOX_SIZE</span></a> და <a class="reference internal" href="../api-reference/kconfig.html#config-lwip-udp-recvmbox-size"><span class="std std-ref">CONFIG_LWIP_UDP_RECVMBOX_SIZE</span></a> მეხსიერების გამოყენების შემცირება გამტარუნარიანობის ხარჯზე, გამოყენების მიხედვით.</li>
</ul>
<p>თუ იყენებთ Wi-Fi , გთხოვთ, ასევე იხილოთ <a class="reference internal" href="wifi.html#wifi-buffer-usage"><span class="std std-ref">Wi-Fi ბუფერის გამოყენება</span></a>.</p>
<div class="section" id="peak-buffer-usage">
<h4>პიკური ბუფერის გამოყენება<a class="headerlink" href="lwip.html#peak-buffer-usage" title="Permalink to this headline">¶</a></h4>
<p>პიკური გროვის მეხსიერება, რომელსაც lwIP მოიხმარს, არის <strong>თეორიულად მაქსიმალური მეხსიერება</strong> რომელსაც lwIP დრაივერი მოიხმარს. როგორც წესი, პიკური გროვის მეხსიერება, რომელსაც lwIP მოიხმარს, დამოკიდებულია:</p>
<blockquote>
<div><ul class="simple">
<li>UDP კავშირის შესაქმნელად საჭირო მეხსიერება: lwip_udp_conn</li>
<li>TCP კავშირის შესაქმნელად საჭირო მეხსიერება: lwip_tcp_conn</li>
<li>აპლიკაციას აქვს UDP კავშირების რაოდენობა: lwip_udp_con_num</li>
<li>აპლიკაციას აქვს TCP კავშირების რაოდენობა: lwip_tcp_con_num</li>
<li>TCP TX ფანჯრის ზომა: lwip_tcp_tx_win_size</li>
<li>TCP RX ფანჯრის ზომა: lwip_tcp_rx_win_size</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt><strong>ამგვარად, LwIP-ის მიერ გამოყენებული პიკური გროვის მეხსიერების გამოთვლა შესაძლებელია შემდეგი ფორმულით:</strong></dt>
<dd>lwip_dynamic_peek_memory =  (lwip_udp_con_num * lwip_udp_conn)  + (lwip_tcp_con_num * (lwip_tcp_tx_win_size + lwip_tcp_rx_win_size + lwip_tcp_conn))</dd>
</dl>
<p>ზოგიერთ TCP-ზე დაფუძნებულ აპლიკაციას მხოლოდ ერთი TCP კავშირი სჭირდება. თუმცა, შეცდომის (მაგალითად, გაგზავნის შეცდომის) შემთხვევაში, მათ შეიძლება აირჩიონ ამ TCP კავშირის დახურვა და ახლის შექმნა. ამან შეიძლება გამოიწვიოს სისტემაში ერთდროულად რამდენიმე TCP კავშირის არსებობა, რადგან TCP მდგომარეობის მანქანის მიხედვით, TCP კავშირის დახურვას შეიძლება დიდი დრო დასჭირდეს (იხილეთ RFC793).</p>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="partition-tables.html" rel="next" title="Partition Tables">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="linker-script-generation.html" rel="prev" title="Linker Script Generation"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>