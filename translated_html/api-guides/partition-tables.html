
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>დანაყოფების ცხრილები — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js" type="text/javascript"></script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../about.html" rel="author" title="About these documents"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="RF_calibration.html" rel="next" title="RF calibration"/>
<link href="lwip.html" rel="prev" title="lwIP"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/partition-tables.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-guides/partition-tables"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-guides/partition-tables.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API სახელმძღვანელოები</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="blufi.html">BluFi</a></li>
<li class="toctree-l2"><a class="reference internal" href="bootloader.html">ჩატვირთვის სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system.html">სისტემის შექმნა</a></li>
<li class="toctree-l2"><a class="reference internal" href="build-system-legacy.html">სისტემის შექმნა (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">კონსოლის კომპონენტი</a></li>
<li class="toctree-l2"><a class="reference internal" href="deep-sleep-stub.html">ღრმა ძილის გაღვიძების სტატიები</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">შეცდომების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="esp-ble-mesh/ble-mesh-index.html">ESP-BLE-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="mesh.html">ESP-MESH ( Wi-Fi )</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_dump.html">ESP32 ბირთვის ნაგავსაყრელი</a></li>
<li class="toctree-l2"><a class="reference internal" href="event-handling.html">მოვლენების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-ram.html">გარე SPI-თან დაკავშირებული ოპერატიული მეხსიერება</a></li>
<li class="toctree-l2"><a class="reference internal" href="fatal-errors.html">ფატალური შეცდომები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/flash-encryption.html">ფლეშ დაშიფვრა</a></li>
<li class="toctree-l2"><a class="reference internal" href="freertos-smp.html">უფასო RTOS SMP ცვლილებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="general-notes.html">ზოგადი შენიშვნები</a></li>
<li class="toctree-l2"><a class="reference internal" href="hlinterrupts.html">მაღალი დონის შეფერხებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="jtag-debugging/index.html">JTAG-ის გამართვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="linker-script-generation.html">ლინკერის სკრიპტის გენერირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="lwip.html">lwIP TCP/IP სტეკი</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="partition-tables.html#">დანაყოფის ცხრილები</a><ul>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#overview">მიმოხილვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#built-in-partition-tables">ჩაშენებული დანაყოფის ცხრილები</a></li>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#creating-custom-tables">საკუთარი ცხრილების შექმნა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#name-field">სახელის ველი</a></li>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#type-field">ტიპის ველი</a></li>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#subtype">ქვეტიპი</a></li>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#offset-size">ოფსეტი და ზომა</a></li>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#flags">დროშები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#generating-binary-partition-table">ორობითი დაყოფის ცხრილის გენერირება</a><ul>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#md5-checksum">MD5 ჩეკის ჯამი</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#flashing-the-partition-table">ტერმინის ციმციმი დანაყოფების ცხრილი</a></li>
<li class="toctree-l3"><a class="reference internal" href="partition-tables.html#partition-tool-parttool-py">დაყოფის ინსტრუმენტი (parttool.py)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#python-api">Python API</a></li>
<li class="toctree-l4"><a class="reference internal" href="partition-tables.html#command-line-interface">ბრძანების ხაზის ინტერფეისი</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="RF_calibration.html">რადიოსიხშირული კალიბრაცია</a></li>
<li class="toctree-l2"><a class="reference internal" href="romconsole.html">ROM გამართვა კონსოლი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/secure-boot.html">უსაფრთხო ჩატვირთვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread-local-storage.html">ძაფების ლოკალური საცავი</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools/index.html">ხელსაწყოები</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp.html">ULP კოპროცესორი</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp-legacy.html">ULP კოპროცესორი (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests-legacy.html">ერთეულის ტესტირება (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests.html">ერთეულის ტესტირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi.html">WiFi დრაივერი</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../index.html">დოკუმენტები</a> »</li>
<li><a href="index.html">API სახელმძღვანელოები</a> »</li>
<li>დანაყოფის ცხრილები</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-guides/partition-tables.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="partition-tables">
<h1>დანაყოფის ცხრილები<a class="headerlink" href="partition-tables.html#partition-tables" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/api-guides/partition-tables.html">[中文]</a></p>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="partition-tables.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ერთი ESP32-ის ფლეშ მეხსიერება შეიძლება შეიცავდეს რამდენიმე აპლიკაციას, ასევე სხვადასხვა სახის მონაცემებს (კალიბრაციის მონაცემები, ფაილური სისტემები, პარამეტრების შენახვა და ა.შ.). ამ მიზეზით, დანაყოფების ცხრილი გამოიყენება ფლეშ მეხსიერება სახით (<a class="reference internal" href="../api-reference/kconfig.html#config-partition-table-offset"><span class="std std-ref">ნაგულისხმევი ოფსეტი</span></a>) 0x8000 ფლეშ მეხსიერება ში.</p>
<p>დანაყოფების ცხრილის სიგრძეა 0xC00 ბაიტი (მაქსიმუმ 95 დანაყოფების ცხრილი ჩანაწერი). MD5 ჩეკის ჯამი, რომელიც გამოიყენება დანაყოფების ცხრილი ის მთლიანობის შესამოწმებლად, ემატება ცხრილის მონაცემებს. თუ დანაყოფების ცხრილი ხელმოწერილია შემდეგი მიზეზის გამო: <cite>secure boot</cite>, ხელმოწერა დართულია დანაყოფების ცხრილი შემდეგ.</p>
<p>დანაყოფების ცხრილი ში თითოეულ ჩანაწერს აქვს სახელი (ეტიკეტი), ტიპი (აპლიკაცია, მონაცემები ან სხვა რამ), ქვეტიპი და ფლეშ მეხსიერება ში ოფსეტი, სადაც დანაყოფი იტვირთება.</p>
<p>დანაყოფების ცხრილი ის გამოყენების უმარტივესი გზაა პროექტის კონფიგურაცია მენიუს გახსნა (<code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code>) და აირჩიეთ ერთ-ერთი მარტივი წინასწარ განსაზღვრული დანაყოფების ცხრილი -დან ქვემოთ <a class="reference internal" href="../api-reference/kconfig.html#config-partition-table-type"><span class="std std-ref">CONFIG_PARTITION_TABLE_TYPE</span></a>:</p>
<ul class="simple">
<li>„ერთი ქარხნული აპლიკაცია, OTA-ს გარეშე“</li>
<li>„ქარხნული აპლიკაცია, ორი OTA განმარტება“</li>
</ul>
<p>ორივე შემთხვევაში, ქარხნული აპლიკაცია ფლეშ მეხსიერება ით არის რედაქტირებული ოფსეტით 0x10000. თუ შეასრულებთ <cite>idf.py partition_table</cite> შემდეგ ის დაბეჭდავს დანაყოფების ცხრილი ის შეჯამებას.</p>
</div>
<div class="section" id="built-in-partition-tables">
<h2>ჩაშენებული დანაყოფის ცხრილები<a class="headerlink" href="partition-tables.html#built-in-partition-tables" title="Permalink to this headline">¶</a></h2>
<p>აქ მოცემულია „ერთი ქარხნული აპლიკაციის, OTA-ს გარეშე“ კონფიგურაციის შეჯამება:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Espressif ESP32 Partition Table</span>
<span class="c1"># Name,   Type, SubType, Offset,  Size, Flags</span>
<span class="n">nvs</span><span class="p">,</span>      <span class="n">data</span><span class="p">,</span> <span class="n">nvs</span><span class="p">,</span>     <span class="mh">0x9000</span><span class="p">,</span>  <span class="mh">0x6000</span><span class="p">,</span>
<span class="n">phy_init</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span>     <span class="mh">0xf000</span><span class="p">,</span>  <span class="mh">0x1000</span><span class="p">,</span>
<span class="n">factory</span><span class="p">,</span>  <span class="n">app</span><span class="p">,</span>  <span class="n">factory</span><span class="p">,</span> <span class="mh">0x10000</span><span class="p">,</span> <span class="mi">1</span><span class="n">M</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li>ფლეშ მეხსიერება ში 0x10000 (64 კბ) ოფსეტზე განთავსებულია აპლიკაცია, რომელსაც აწერია „ქარხნული“. ჩამტვირთავი ამ აპლიკაციას სტანდარტულად გაუშვებს.</li>
<li>ასევე, დანაყოფების ცხრილი ში განსაზღვრულია ორი მონაცემთა რეგიონი NVS ბიბლიოთეკის დანაყოფისა და PHY init მონაცემების შესანახად.</li>
</ul>
<p>აქ მოცემულია „ქარხნული აპლიკაციის, ორი OTA განმარტების“ კონფიგურაციის შეჯამება:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Espressif ESP32 Partition Table</span>
<span class="c1"># Name,   Type, SubType, Offset,  Size, Flags</span>
<span class="n">nvs</span><span class="p">,</span>      <span class="n">data</span><span class="p">,</span> <span class="n">nvs</span><span class="p">,</span>     <span class="mh">0x9000</span><span class="p">,</span>  <span class="mh">0x4000</span><span class="p">,</span>
<span class="n">otadata</span><span class="p">,</span>  <span class="n">data</span><span class="p">,</span> <span class="n">ota</span><span class="p">,</span>     <span class="mh">0xd000</span><span class="p">,</span>  <span class="mh">0x2000</span><span class="p">,</span>
<span class="n">phy_init</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span>     <span class="mh">0xf000</span><span class="p">,</span>  <span class="mh">0x1000</span><span class="p">,</span>
<span class="n">factory</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>       <span class="mh">0x10000</span><span class="p">,</span> <span class="mi">1</span><span class="n">M</span><span class="p">,</span>
<span class="n">ota_0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="n">ota_0</span><span class="p">,</span>  <span class="mh">0x110000</span><span class="p">,</span> <span class="mi">1</span><span class="n">M</span><span class="p">,</span>
<span class="n">ota_1</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="n">ota_1</span><span class="p">,</span>  <span class="mh">0x210000</span><span class="p">,</span> <span class="mi">1</span><span class="n">M</span><span class="p">,</span>
</pre></div>
</div>
<ul class="simple">
<li>ახლა უკვე არსებობს აპლიკაციის დანაყოფის სამი განმარტება. ქარხნული აპლიკაციის ტიპი (0x10000-ზე) და შემდეგი ორი „OTA“ აპლიკაციის ტიპი დაყენებულია „app“-ზე, მაგრამ მათი ქვეტიპები განსხვავებულია.</li>
<li>ასევე არის ახალი „otadata“ სლოტი, რომელიც ინახავს OTA განახლებების მონაცემებს. ჩამტვირთავი ამ მონაცემებს განიხილავს იმის გასარკვევად, თუ რომელი აპლიკაცია უნდა გაუშვას. თუ „ota data“ ცარიელია, ის გაუშვებს ქარხნულ აპლიკაციას.</li>
</ul>
</div>
<div class="section" id="creating-custom-tables">
<h2>საკუთარი ცხრილების შექმნა<a class="headerlink" href="partition-tables.html#creating-custom-tables" title="Permalink to this headline">¶</a></h2>
<p>თუ menuconfig ში აირჩევთ „Custom დანაყოფების ცხრილი CSV“-ს, მაშინ ასევე შეგიძლიათ შეიყვანოთ CSV ფაილის სახელი (პროექტის დირექტორიაში), რომელიც გამოყენებული იქნება თქვენი დანაყოფების ცხრილი ისთვის. CSV ფაილს შეუძლია აღწეროს თქვენთვის საჭირო ცხრილის ნებისმიერი რაოდენობის განმარტება.</p>
<p>CSV ფორმატი იგივე ფორმატია, რაც ზემოთ ნაჩვენებ რეზიუმეებშია დაბეჭდილი. თუმცა, CSV ფაილში ყველა ველი სავალდებულო არ არის. მაგალითად, აქ მოცემულია OTA დანაყოფების ცხრილი „შეყვანის“ CSV ფაილი22:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Name,   Type, SubType,  Offset,   Size,  Flags</span>
<span class="n">nvs</span><span class="p">,</span>      <span class="n">data</span><span class="p">,</span> <span class="n">nvs</span><span class="p">,</span>      <span class="mh">0x9000</span><span class="p">,</span>  <span class="mh">0x4000</span>
<span class="n">otadata</span><span class="p">,</span>  <span class="n">data</span><span class="p">,</span> <span class="n">ota</span><span class="p">,</span>      <span class="mh">0xd000</span><span class="p">,</span>  <span class="mh">0x2000</span>
<span class="n">phy_init</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">phy</span><span class="p">,</span>      <span class="mh">0xf000</span><span class="p">,</span>  <span class="mh">0x1000</span>
<span class="n">factory</span><span class="p">,</span>  <span class="n">app</span><span class="p">,</span>  <span class="n">factory</span><span class="p">,</span>  <span class="mh">0x10000</span><span class="p">,</span>  <span class="mi">1</span><span class="n">M</span>
<span class="n">ota_0</span><span class="p">,</span>    <span class="n">app</span><span class="p">,</span>  <span class="n">ota_0</span><span class="p">,</span>    <span class="p">,</span>         <span class="mi">1</span><span class="n">M</span>
<span class="n">ota_1</span><span class="p">,</span>    <span class="n">app</span><span class="p">,</span>  <span class="n">ota_1</span><span class="p">,</span>    <span class="p">,</span>         <span class="mi">1</span><span class="n">M</span>
<span class="n">nvs_key</span><span class="p">,</span>  <span class="n">data</span><span class="p">,</span> <span class="n">nvs_keys</span><span class="p">,</span> <span class="p">,</span>        <span class="mh">0x1000</span>
</pre></div>
</div>
<ul class="simple">
<li>ველებს შორის ცარიელი სივრცეები იგნორირებულია, ისევე როგორც ნებისმიერი ხაზი, რომელიც იწყება #-ით (კომენტარები).</li>
<li>CSV ფაილში თითოეული არაკომენტარული ხაზი დანაყოფის განმარტებას წარმოადგენს.</li>
<li>თითოეული დანაყოფის „ოფსეტის“ ველი ცარიელია. gen_esp32part.py ინსტრუმენტი ავსებს თითოეულ ცარიელ ოფსეტს, დაწყებული დანაყოფების ცხრილი შემდეგ და ამოწმებს, რომ თითოეული დანაყოფი სწორად არის გასწორებული.</li>
</ul>
<div class="section" id="name-field">
<h3>სახელის ველი<a class="headerlink" href="partition-tables.html#name-field" title="Permalink to this headline">¶</a></h3>
<p>სახელის ველი შეიძლება იყოს ნებისმიერი მნიშვნელოვანი სახელი. ეს არ არის მნიშვნელოვანი ESP32-ისთვის. 16 სიმბოლოზე გრძელი სახელები შემოკლდება.</p>
</div>
<div class="section" id="type-field">
<h3>ტიპის ველი<a class="headerlink" href="partition-tables.html#type-field" title="Permalink to this headline">¶</a></h3>
<p>დანაყოფის ტიპის ველი შეიძლება მითითებული იყოს როგორც app (0) ან data (1). ან შეიძლება იყოს რიცხვი 0-254 (ან როგორც hex 0x00-0xFE). 0x00-0x3F ტიპები დაჯავშნილია esp-idf core ფუნქციებისთვის.</p>
<p>თუ თქვენს აპლიკაციას მონაცემების შენახვა სჭირდება, გთხოვთ, დაამატოთ მორგებული დანაყოფის ტიპი 0x40-0xFE დიაპაზონში.</p>
<p>ჩამტვირთავი უგულებელყოფს app (0) და data (1)-ის გარდა სხვა დანაყოფების ტიპებს.</p>
</div>
<div class="section" id="subtype">
<h3>ქვეტიპი<a class="headerlink" href="partition-tables.html#subtype" title="Permalink to this headline">¶</a></h3>
<p>8-ბიტიანი ქვეტიპის ველი სპეციფიკურია მოცემული დანაყოფის ტიპისთვის. esp-idf ამჟამად მხოლოდ „app“ და „data“ დანაყოფის ტიპებისთვის განსაზღვრავს ქვეტიპის ველის მნიშვნელობას.</p>
<ul class="simple">
<li>როდესაც ტიპი არის „app“, ქვეტიპის ველი შეიძლება მიეთითოს, როგორც factory (0), ota_0 (0x10) … ota_15 (0x1F) ან test (0x20).<ul>
<li>factory (0) არის აპლიკაციის ნაგულისხმევი დანაყოფი. ჩამტვირთავი შეასრულებს factory აპლიკაციას, თუ იქ არ ხედავს data/ota ტიპის დანაყოფის არსებობას, ამ შემთხვევაში ის კითხულობს ამ დანაყოფის ვერსიებს, რათა დაადგინოს, რომელი OTA იმიჯი ჩაიტვირთოს.<ul>
<li>OTA არასდროს აახლებს ქარხნულ დანაყოფს.</li>
<li>თუ გსურთ, რომ OTA პროექტში ფლეშ მეხსიერება გამოყენება დაზოგოთ, შეგიძლიათ წაშალოთ ქარხნული დანაყოფი და მის ნაცვლად გამოიყენოთ ota_0.</li>
</ul>
</li>
<li>ota_0 (0x10) … ota_15 (0x1F) არის OTA აპლიკაციის სლოტები. იხილეთ <a class="reference internal" href="../api-reference/system/ota.html"><span class="doc">ონლაინ დოკუმენტაცია</span></a> დამატებითი დეტალებისთვის, რომლებიც შემდეგ იყენებენ OTA მონაცემთა დანაყოფის გამოყენებით, თუ რომელი აპლიკაციის სლოტი უნდა ჩაიტვირთოს ჩამტვირთავი . თუ იყენებთ OTA-ს, აპლიკაციას უნდა ჰქონდეს მინიმუმ ორი OTA აპლიკაციის სლოტი (ota_0 და ota_1). იხილეთ <a class="reference internal" href="../api-reference/system/ota.html"><span class="doc">ონლაინ დოკუმენტაცია</span></a> დამატებითი დეტალებისთვის.</li>
<li>test (0x20) არის ქარხნული ტესტირების პროცედურებისთვის დაჯავშნილი ქვეტიპი. ის გამოყენებული იქნება როგორც სარეზერვო ჩატვირთვის დანაყოფი, თუ სხვა ვალიდური აპლიკაციის დანაყოფი ვერ მოიძებნება. ასევე შესაძლებელია ჩამტვირთავი კონფიგურაცია ისე, რომ ყოველი ჩატვირთვის დროს წაიკითხოს GPIO შეყვანა და ჩატვირთოს ეს დანაყოფი, თუ GPIO დაბალ ნიშნულზეა, იხილეთ <a class="reference internal" href="bootloader.html#bootloader-boot-from-test-firmware"><span class="std std-ref">ჩატვირთვა TEST პროგრამული უზრუნველყოფა დან</span></a>.</li>
</ul>
</li>
<li>როდესაც ტიპი არის „მონაცემები“, ქვეტიპის ველი შეიძლება მიეთითოს, როგორც ota (0), phy (1), nvs (2) ან nvs_keys (4).<ul>
<li>ოტა (0) არის <a class="reference internal" href="../api-reference/system/ota.html#ota-data-partition"><span class="std std-ref">OTA მონაცემთა დანაყოფი</span></a> რომელიც ინახავს ინფორმაციას ამჟამად არჩეული OTA აპლიკაციის შესახებ. ამ დანაყოფის ზომა უნდა იყოს 0x2000 ბაიტი. იხილეთ <a class="reference internal" href="../api-reference/system/ota.html#ota-data-partition"><span class="std std-ref">ონლაინ დოკუმენტაცია</span></a> დამატებითი დეტალებისთვის.</li>
<li>phy (1) განკუთვნილია PHY ინიციალიზაციის მონაცემების შესანახად. ეს საშუალებას იძლევა PHY კონფიგურირებული იყოს თითოეული მოწყობილობისთვის, პროგრამული უზრუნველყოფა ში კონფიგურირების ნაცვლად.<ul>
<li>ნაგულისხმევ კონფიგურაციაში, phy დანაყოფი არ გამოიყენება და PHY ინიციალიზაციის მონაცემები კომპილაცია d-ია თავად აპლიკაციაში. შესაბამისად, სივრცის დაზოგვის მიზნით, ამ დანაყოფის ამოღება შესაძლებელია დანაყოფების ცხრილი დან.</li>
<li>ამ დანაყოფიდან PHY მონაცემების ჩასატვირთად, გახსენით პროექტის კონფიგურაცია მენიუ (<code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code>) და ჩართეთ <a class="reference internal" href="../api-reference/kconfig.html#config-esp32-phy-init-data-in-partition"><span class="std std-ref">CONFIG_ESP32_PHY_INIT_DATA_IN_PARTITION</span></a> ვარიანტი. ასევე დაგჭირდებათ თქვენი მოწყობილობებისთვის phy init მონაცემებით ფლეშ მეხსიერება გამოყენება, რადგან esp-idf build სისტემა ამას ავტომატურად არ აკეთებს.</li>
</ul>
</li>
<li>nvs (2) განკუთვნილია <a class="reference internal" href="../api-reference/storage/nvs_flash.html"><span class="doc">არასტაბილური შენახვის (NVS) API</span></a>.<ul>
<li>NVS გამოიყენება თითოეული მოწყობილობის PHY კალიბრაციის მონაცემების შესანახად (განსხვავებულია ინიციალიზაციის მონაცემებისგან).</li>
<li>NVS გამოიყენება WiFi მონაცემების შესანახად, თუ <a class="reference internal" href="../api-reference/network/esp_wifi.html"><span class="doc">esp_wifi_set_storage(WIFI_STORAGE_FLASH)</span></a> ინიციალიზაციის ფუნქცია გამოიყენება.</li>
<li>NVS API ასევე შეიძლება გამოყენებულ იქნას სხვა აპლიკაციის მონაცემებისთვის.</li>
<li>მკაცრად რეკომენდებულია, რომ თქვენს პროექტში ჩართოთ მინიმუმ 0x3000 ბაიტის NVS დანაყოფი.</li>
<li>თუ დიდი რაოდენობით მონაცემების შესანახად NVS API იყენებთ, გაზარდეთ NVS დანაყოფის ზომა ნაგულისხმევი 0x6000 ბაიტიდან.</li>
</ul>
</li>
<li>nvs_keys (4) NVS გასაღების დანაყოფისთვისაა. იხილეთ <a class="reference internal" href="../api-reference/storage/nvs_flash.html"><span class="doc">არასტაბილური შენახვის (NVS) API</span></a> დამატებითი დეტალებისთვის.<ul>
<li>ის გამოიყენება NVS დაშიფვრის გასაღებების შესანახად, როდესაც <cite>NVS Encryption</cite> ფუნქცია ჩართულია.</li>
<li>ამ დანაყოფის ზომა უნდა იყოს 4096 ბაიტი (დანაყოფის მინიმალური ზომა).</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>სხვა მონაცემთა ქვეტიპები დაცულია esp-idf-ის მომავალი გამოყენებისთვის.</p>
</div>
<div class="section" id="offset-size">
<h3>ოფსეტი და ზომა<a class="headerlink" href="partition-tables.html#offset-size" title="Permalink to this headline">¶</a></h3>
<p>ცარიელი ოფსეტებით დანაყოფი დაიწყება წინა დანაყოფის შემდეგ, ან პირველი დანაყოფის შემთხვევაში დანაყოფების ცხრილი ის შემდეგ.</p>
<p>აპლიკაციის დანაყოფები უნდა იყოს 0x10000-ზე (64K) გასწორებული ოფსეტებით. თუ ოფსეტის ველს ცარიელს დატოვებთ,  <code class="docutils literal notranslate"><span class="pre">gen_esp32part.py</span></code> ავტომატურად გაასწორებს დანაყოფს. თუ აპლიკაციის დანაყოფისთვის მიუთითებთ არაგასწორებულ ოფსეტს, ინსტრუმენტი დააბრუნებს შეცდომას.</p>
<p>ზომები და ოფსეტები შეიძლება მიეთითოს ათობითი რიცხვების, თექვსმეტობითი რიცხვების სახით 0x პრეფიქსით, ან ზომის მამრავლების სახით K ან M (1024 და 1024*1024 ბაიტი).</p>
<p>თუ გსურთ, რომ დანაყოფების ცხრილი ში დანაყოფებმა იმუშაონ ნებისმიერი საწყისი ოფსეტით (<a class="reference internal" href="../api-reference/kconfig.html#config-partition-table-offset"><span class="std std-ref">CONFIG_PARTITION_TABLE_OFFSET</span></a>) თავად ცხრილის შემთხვევაში, ყველა დანაყოფისთვის ოფსეტის ველი (CSV ფაილში) ცარიელი დატოვეთ. ანალოგიურად, თუ დანაყოფების ცხრილი ოფსეტს ცვლით, გაითვალისწინეთ, რომ ყველა ცარიელი დანაყოფის ოფსეტი შეიძლება შეიცვალოს შესაბამისობისთვის და რომ ნებისმიერი ფიქსირებული ოფსეტი შეიძლება ახლა დანაყოფების ცხრილი ს შეეჯახოს (რაც შეცდომას გამოიწვევს).</p>
</div>
<div class="section" id="flags">
<h3>დროშები<a class="headerlink" href="partition-tables.html#flags" title="Permalink to this headline">¶</a></h3>
<p>ამჟამად მხოლოდ ერთი დროშაა მხარდაჭერილი, <code class="docutils literal notranslate"><span class="pre">encrypted</span></code>თუ ეს ველი დაყენებულია <code class="docutils literal notranslate"><span class="pre">encrypted</span></code>, ეს დანაყოფი დაშიფრული იქნება, თუ <a class="reference internal" href="../security/flash-encryption.html"><span class="doc">ფლეშ დაშიფვრა</span></a> ჩართულია.</p>
<p>(გაითვალისწინეთ, რომ <code class="docutils literal notranslate"><span class="pre">app</span></code> ტიპის ტიხრები ყოველთვის დაშიფრული იქნება, მიუხედავად იმისა, დაყენებულია თუ არა ეს დროშა.)</p>
</div>
</div>
<div class="section" id="generating-binary-partition-table">
<h2>ორობითი დაყოფის ცხრილის გენერირება<a class="headerlink" href="partition-tables.html#generating-binary-partition-table" title="Permalink to this headline">¶</a></h2>
<p>დანაყოფების ცხრილი , რომელიც ფლეშ მეხსიერება არის გადატანილი ESP32-ში, არის ორობით ფორმატში და არა CSV. ინსტრუმენტი <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/partition_table/gen_esp32part.py">დანაყოფის_ცხრილი/gen_esp32part.py</a> გამოიყენება CSV და ორობით ფორმატებს შორის კონვერტაციისთვის.</p>
<p>თუ დანაყოფების ცხრილი პროექტის კონფიგურაცია (<code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code>) და შემდეგ შექმენით პროექტი ან გაუშვით <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">partition_table</span></code>, ეს კონვერტაცია აწყობის პროცესის ნაწილად ხორციელდება.</p>
<p>CSV ფაილის ორობით ფორმატში ხელით გადასაყვანად:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">gen_esp32part</span><span class="o">.</span><span class="n">py</span> <span class="n">input_partitions</span><span class="o">.</span><span class="n">csv</span> <span class="n">binary_partitions</span><span class="o">.</span><span class="n">bin</span>
</pre></div>
</div>
<p>ორობითი ფორმატის CSV ფორმატში ხელით გადასაყვანად:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">gen_esp32part</span><span class="o">.</span><span class="n">py</span> <span class="n">binary_partitions</span><span class="o">.</span><span class="n">bin</span> <span class="n">input_partitions</span><span class="o">.</span><span class="n">csv</span>
</pre></div>
</div>
<p>ორობითი დანაყოფების ცხრილი ის შინაარსის stdout-ზე საჩვენებლად (ასე ჩანს შეჯამებები გაშვებისას) <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">partition_table</span></code> წარმოიქმნება:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">gen_esp32part</span><span class="o">.</span><span class="n">py</span> <span class="n">binary_partitions</span><span class="o">.</span><span class="n">bin</span>
</pre></div>
</div>
<div class="section" id="md5-checksum">
<h3>MD5 ჩეკის ჯამი<a class="headerlink" href="partition-tables.html#md5-checksum" title="Permalink to this headline">¶</a></h3>
<p>დანაყოფების ცხრილი ის ორობითი ფორმატი შეიცავს დანაყოფების ცხრილი საფუძველზე გამოთვლილ MD5 ჩეკსუმს. ეს ჩეკსუმი გამოიყენება ჩატვირთვის დროს დანაყოფების ცხრილი ის მთლიანობის შესამოწმებლად.</p>
<p>MD5 ჩეკის ჯამის გენერირების გამორთვა შესაძლებელია შემდეგი გზით: <code class="docutils literal notranslate"><span class="pre">--disable-md5sum</span></code> ვარიანტი <code class="docutils literal notranslate"><span class="pre">gen_esp32part.py</span></code> ან <a class="reference internal" href="../api-reference/kconfig.html#config-partition-table-md5"><span class="std std-ref">CONFIG_PARTITION_TABLE_MD5</span></a> ვარიანტი. ეს სასარგებლოა, მაგალითად, როდესაც გამოიყენება მემკვიდრეობით მიღებული ჩამტვირთავი , რომელსაც არ შეუძლია MD5 ჩეკების დამუშავება და ჩატვირთვა ვერ ხერხდება შეცდომის შეტყობინებით. <code class="docutils literal notranslate"><span class="pre">invalid</span> <span class="pre">magic</span> <span class="pre">number</span> <span class="pre">0xebeb</span></code>.</p>
</div>
</div>
<div class="section" id="flashing-the-partition-table">
<h2>ტერმინის ციმციმი დანაყოფების ცხრილი<a class="headerlink" href="partition-tables.html#flashing-the-partition-table" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">partition_table-flash</span></code>: esptool.py-ის გამოყენებით ფლეშ მეხსიერება დანაყოფების ცხრილი ს დააკავშირებს.</li>
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">flash</span></code>: ფლეშ მეხსიერება ყველაფერს მოიცავს, დანაყოფების ცხრილი ჩათვლით.</li>
</ul>
<p>ასევე, ნაწილად იბეჭდება ფლეშ მეხსიერება ხელით შესრულების ბრძანება. <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">partition_table</span></code> გამომავალი.</p>
<p>გაითვალისწინეთ, რომ დანაყოფების ცხრილი ის განახლება არ წაშლის მონაცემებს, რომლებიც შესაძლოა ძველი დანაყოფების ცხრილი მიხედვით იყო შენახული. შეგიძლიათ გამოიყენოთ <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">erase_flash</span></code> (ან <code class="docutils literal notranslate"><span class="pre">esptool.py</span> <span class="pre">erase_flash</span></code>) ფლეშ მეხსიერება მთელი შინაარსის წასაშლელად.</p>
</div>
<div class="section" id="partition-tool-parttool-py">
<h2>დაყოფის ინსტრუმენტი (parttool.py)<a class="headerlink" href="partition-tables.html#partition-tool-parttool-py" title="Permalink to this headline">¶</a></h2>
<p>კომპონენტი <cite>partition_table</cite> უზრუნველყოფს ინსტრუმენტს <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/partition_table/parttool.py">parttool.py</a> სამიზნე მოწყობილობაზე დანაყოფებთან დაკავშირებული ოპერაციების შესასრულებლად. ინსტრუმენტის გამოყენებით შესაძლებელია შემდეგი ოპერაციების შესრულება:</p>
<blockquote>
<div><ul class="simple">
<li>დანაყოფის წაკითხვა და შინაარსის ფაილში შენახვა (read_partition)</li>
<li>ფაილის შინაარსის ჩაწერა დანაყოფზე (write_partition)</li>
<li>დანაყოფის წაშლა (erase_partition)</li>
<li>ინფორმაციის მოძიება, როგორიცაა მოცემული დანაყოფის ოფსეტი და ზომა (get_partition_info)</li>
</ul>
</div></blockquote>
<p>ინსტრუმენტის იმპორტირება და გამოყენება შესაძლებელია სხვა Python სკრიპტიდან ან შელის სკრიპტიდან გამოძახება იმ მომხმარებლებისთვის, რომელთაც სურთ ოპერაციების პროგრამულად შესრულება. ამას ხელს უწყობს ინსტრუმენტის Python API და ბრძანების ხაზის ინტერფეისი, შესაბამისად.</p>
<div class="section" id="python-api">
<h3>Python API<a class="headerlink" href="partition-tables.html#python-api" title="Permalink to this headline">¶</a></h3>
<p>ყველაფერზე ადრე, დარწმუნდით, რომ <cite>parttool</cite> მოდული იმპორტირებულია.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="n">idf_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">"IDF_PATH"</span><span class="p">]</span>  <span class="c1"># get value of IDF_PATH from environment</span>
<span class="n">parttool_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">idf_path</span><span class="p">,</span> <span class="s2">"components"</span><span class="p">,</span> <span class="s2">"partition_table"</span><span class="p">)</span>  <span class="c1"># parttool.py lives in $IDF_PATH/components/partition_table</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parttool_dir</span><span class="p">)</span>  <span class="c1"># this enables Python to find parttool module</span>
<span class="kn">from</span> <span class="nn">parttool</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># import all names inside parttool module</span>
</pre></div>
</div>
<p>ინსტრუმენტის Python API გამოყენების საწყისი წერტილი არის შექმნა <cite>ParttoolTarget</cite> ობიექტი:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a partool.py target device connected on serial port /dev/ttyUSB1</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">ParttoolTarget</span><span class="p">(</span><span class="s2">"/dev/ttyUSB1"</span><span class="p">)</span>
</pre></div>
</div>
<p>შექმნილი ობიექტის გამოყენება ახლა შესაძლებელია სამიზნე მოწყობილობაზე ოპერაციების შესასრულებლად:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Erase partition with name 'storage'</span>
<span class="n">target</span><span class="o">.</span><span class="n">erase_partition</span><span class="p">(</span><span class="n">PartitionName</span><span class="p">(</span><span class="s2">"storage"</span><span class="p">))</span>

<span class="c1"># Read partition with type 'data' and subtype 'spiffs' and save to file 'spiffs.bin'</span>
<span class="n">target</span><span class="o">.</span><span class="n">read_partition</span><span class="p">(</span><span class="n">PartitionType</span><span class="p">(</span><span class="s2">"data"</span><span class="p">,</span> <span class="s2">"spiffs"</span><span class="p">),</span> <span class="s2">"spiffs.bin"</span><span class="p">)</span>

<span class="c1"># Write to partition 'factory' the contents of a file named 'factory.bin'</span>
<span class="n">target</span><span class="o">.</span><span class="n">write_partition</span><span class="p">(</span><span class="n">PartitionName</span><span class="p">(</span><span class="s2">"factory"</span><span class="p">),</span> <span class="s2">"factory.bin"</span><span class="p">)</span>

<span class="c1"># Print the size of default boot partition</span>
<span class="n">storage</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">get_partition_info</span><span class="p">(</span><span class="n">PARTITION_BOOT_DEFAULT</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">storage</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
</pre></div>
</div>
<p>დანაყოფი, რომელზეც უნდა იმუშაოთ, მითითებულია გამოყენებით <cite>PartitionName</cite> ან <cite>PartitionType</cite> ან PARTITION_BOOT_DEFAULT. როგორც სახელიდან ჩანს, მათი გამოყენება შესაძლებელია კონკრეტული სახელის, ტიპი-ქვეტიპის კომბინაციის ან ნაგულისხმევი ჩატვირთვის დანაყოფის აღსანიშნავად.</p>
<p>Python API შესახებ დამატებითი ინფორმაცია ხელმისაწვდომია ინსტრუმენტის docstrings-ში.</p>
</div>
<div class="section" id="command-line-interface">
<h3>ბრძანების ხაზის ინტერფეისი<a class="headerlink" href="partition-tables.html#command-line-interface" title="Permalink to this headline">¶</a></h3>
<p>ბრძანების ხაზის ინტერფეისი <cite>parttool.py</cite> აქვს შემდეგი სტრუქტურა:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>parttool.py <span class="o">[</span>command-args<span class="o">]</span> <span class="o">[</span>subcommand<span class="o">]</span> <span class="o">[</span>subcommand-args<span class="o">]</span>

- command-args - These are arguments that are needed <span class="k">for</span> executing the main <span class="nb">command</span> <span class="o">(</span>parttool.py<span class="o">)</span>, mostly pertaining to the target device
- subcommand - This is the operation to be performed
- subcommand-args - These are arguments that are specific to the chosen operation
</pre></div>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Erase partition with name 'storage'</span>
parttool.py --port <span class="s2">"/dev/ttyUSB1"</span> erase_partition --partition-name<span class="o">=</span>storage

<span class="c1"># Read partition with type 'data' and subtype 'spiffs' and save to file 'spiffs.bin'</span>
parttool.py --port <span class="s2">"/dev/ttyUSB1"</span> read_partition --partition-type<span class="o">=</span>data --partition-subtype<span class="o">=</span>spiffs <span class="s2">"spiffs.bin"</span>

<span class="c1"># Write to partition 'factory' the contents of a file named 'factory.bin'</span>
parttool.py --port <span class="s2">"/dev/ttyUSB1"</span> write_partition --partition-name<span class="o">=</span>factory <span class="s2">"factory.bin"</span>

<span class="c1"># Print the size of default boot partition</span>
parttool.py --port <span class="s2">"/dev/ttyUSB1"</span> get_partition_info --partition-boot-default --info size
</pre></div>
</div>
<p>დამატებითი ინფორმაციის მიღება შესაძლებელია მითითებით <cite>–help</cite> როგორც არგუმენტი:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Display possible subcommands and show main command argument descriptions</span>
parttool.py --help

<span class="c1"># Show descriptions for specific subcommand arguments</span>
parttool.py <span class="o">[</span>subcommand<span class="o">]</span> --help
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="RF_calibration.html" rel="next" title="RF calibration">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="lwip.html" rel="prev" title="lwIP"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>