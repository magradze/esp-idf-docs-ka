
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>სისტემის შექმნა — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js" type="text/javascript"></script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<script src="../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../_static/js/theme.js" type="text/javascript"></script>
<link href="../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../about.html" rel="author" title="About these documents"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="build-system-legacy.html" rel="next" title="Build System (Legacy GNU Make)"/>
<link href="bootloader.html" rel="prev" title="Bootloader"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-guides/build-system.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-guides/build-system"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-guides/build-system.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api-reference/index.html">API მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">API სახელმძღვანელოები</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="blufi.html">BluFi</a></li>
<li class="toctree-l2"><a class="reference internal" href="bootloader.html">ჩატვირთვის სისტემა</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="build-system.html#">სისტემის შექმნა</a><ul>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#overview">მიმოხილვა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#concepts">კონცეფციები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#using-the-build-system">შექმნის სისტემის გამოყენება</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#idf-py">idf.py</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#using-cmake-directly">CMake-ის პირდაპირ გამოყენება</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#using-cmake-in-an-ide">CMake-ის გამოყენება IDE-ში</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#setting-the-python-interpreter">Python-ის ინტერპრეტატორის დაყენება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#example-project">პროექტის მაგალითი</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#project-cmakelists-file">პროექტის CMakeLists ფაილი</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#minimal-example-cmakelists">მინიმალური CMakeLists-ის მაგალითები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#mandatory-parts">სავალდებულო ნაწილები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#optional-project-variables">პროექტის არჩევითი ცვლადები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#renaming-main-component">გადარქმევა <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#component-cmakelists-files">კომპონენტის CMakeLists ფაილები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#searching-for-components">კომპონენტების ძიება</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#multiple-components-with-the-same-name">ერთი და იგივე სახელის მქონე მრავალი კომპონენტი 19</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#minimal-component-cmakelists">მინიმალური კომპონენტების CMakeLists</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#preset-component-variables">წინასწარ დაყენებული კომპონენტის ცვლადები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#build-project-variables">შექმნის/პროექტის ცვლადები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#controlling-component-compilation">კომპონენტების კომპილაციის კონტროლი</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#component-configuration">კომპონენტის კონფიგურაცია</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#preprocessor-definitions">წინასწარი პროცესორის განმარტებები</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#component-requirements">კომპონენტის მოთხოვნები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#when-writing-a-component">კომპონენტი წერისას19</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#example-of-component-requirements">კომპონენტი მოთხოვნების მაგალითი</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#source-file-include-directories">წყაროს ფაილის ჩართვის დირექტორიები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#main-component-requirements">ძირითადი კომპონენტი მოთხოვნები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#common-component-requirements">კომპონენტი საერთო მოთხოვნები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#including-components-in-the-build">აწყობაში კომპონენტი ის ჩათვლით</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#requirements-in-the-build-system-implementation">მოთხოვნები სისტემის შექმნისას</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#overriding-parts-of-the-project">პროექტის გადამწყვეტი ნაწილები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#project-include-cmake">project_include.cmake</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#kconfig-projbuild">KConfig.projbuild</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#configuration-only-components">მხოლოდ კონფიგურაციის კომპონენტები</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#debugging-cmake">CMake-ის გამართვა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#warning-on-undefined-variables">გაფრთხილება განუსაზღვრელი ცვლადების შესახებ</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#example-component-cmakelists">მაგალითის კომპონენტი CMakeLists</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#adding-conditional-configuration">პირობითი კონფიგურაციის დამატება</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#conditions-which-depend-on-the-target">პირობები, რომლებიც დამოკიდებულია მიზანზე</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#source-code-generation">საწყისი კოდის გენერირება</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#embedding-binary-data">ორობითი მონაცემების ჩასმა</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#code-and-data-placements">კოდისა და მონაცემების განთავსება</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#fully-overriding-the-component-build-process">კომპონენტის შექმნის პროცესის სრულად უგულებელყოფა</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#custom-sdkconfig-defaults">sdkconfig-ის მორგებული ნაგულისხმევი პარამეტრები</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#target-dependent-sdkconfig-defaults">სამიზნეზე დამოკიდებული sdkconfig-ის ნაგულისხმევი პარამეტრები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#flash-arguments">ფლეშ არგუმენტები</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#building-the-bootloader">Bootloader-ის შექმნა</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#selecting-the-target">სამიზნის შერჩევა</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#writing-pure-cmake-components">სუფთა CMake კომპონენტების წერა</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#using-third-party-cmake-projects-with-components">მესამე მხარის CMake პროექტების გამოყენება კომპონენტებთან ერთად</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#using-esp-idf-components-from-external-libraries">გარე ბიბლიოთეკებიდან ESP-IDF კომპონენტი ის გამოყენება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#using-prebuilt-libraries-with-components">წინასწარ აშენებული ბიბლიოთეკების გამოყენება კომპონენტებთან ერთად</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#using-esp-idf-in-custom-cmake-projects">ESP-IDF გამოყენება CMake-ის პროექტებში</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#esp-idf-cmake-build-system-api">ESP-IDF CMake Build System API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#idf-build-commands">idf-build-ბრძანებები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#cmake-build-properties">idf-build-properties</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#idf-component-commands">idf- კომპონენტი -ბრძანებები</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#cmake-component-properties">idf- კომპონენტი -თვისებები</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#file-globbing-incremental-builds">ფაილების გლობაცია და ინკრემენტული აწყობა</a></li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#build-system-metadata">სისტემის მეტამონაცემების შექმნა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#json-configuration-server">JSON კონფიგურაციის სერვერი</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#build-system-internals">სისტემის შიდა ელემენტების შექმნა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#build-scripts">სკრიპტების შექმნა</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#build-process">შექმნის პროცესი</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="build-system.html#migrating-from-esp-idf-gnu-make-system">ESP-IDF GNU Make System-დან მიგრაცია</a><ul>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#automatic-conversion-tool">ავტომატური კონვერტაციის ინსტრუმენტი</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#no-longer-available-in-cmake">CMake-ში აღარ არის ხელმისაწვდომი</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#no-default-values">ნაგულისხმევი მნიშვნელობები არ არის</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#no-longer-necessary">აღარ არის საჭირო</a></li>
<li class="toctree-l4"><a class="reference internal" href="build-system.html#flashing-from-make">მარკის ციმციმი</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="build-system-legacy.html">სისტემის შექმნა (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="console.html">კონსოლის კომპონენტი</a></li>
<li class="toctree-l2"><a class="reference internal" href="deep-sleep-stub.html">ღრმა ძილის გაღვიძების სტატიები</a></li>
<li class="toctree-l2"><a class="reference internal" href="error-handling.html">შეცდომების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="esp-ble-mesh/ble-mesh-index.html">ESP-BLE-MESH</a></li>
<li class="toctree-l2"><a class="reference internal" href="mesh.html">ESP-MESH ( Wi-Fi )</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_dump.html">ESP32 ბირთვის ნაგავსაყრელი</a></li>
<li class="toctree-l2"><a class="reference internal" href="event-handling.html">მოვლენების დამუშავება</a></li>
<li class="toctree-l2"><a class="reference internal" href="external-ram.html">გარე SPI-თან დაკავშირებული ოპერატიული მეხსიერება</a></li>
<li class="toctree-l2"><a class="reference internal" href="fatal-errors.html">ფატალური შეცდომები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/flash-encryption.html">ფლეშ დაშიფვრა</a></li>
<li class="toctree-l2"><a class="reference internal" href="freertos-smp.html">უფასო RTOS SMP ცვლილებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="general-notes.html">ზოგადი შენიშვნები</a></li>
<li class="toctree-l2"><a class="reference internal" href="hlinterrupts.html">მაღალი დონის შეფერხებები</a></li>
<li class="toctree-l2"><a class="reference internal" href="jtag-debugging/index.html">JTAG-ის გამართვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="linker-script-generation.html">ლინკერის სკრიპტის გენერირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="lwip.html">lwIP TCP/IP სტეკი</a></li>
<li class="toctree-l2"><a class="reference internal" href="partition-tables.html">დანაყოფის ცხრილები</a></li>
<li class="toctree-l2"><a class="reference internal" href="RF_calibration.html">რადიოსიხშირული კალიბრაცია</a></li>
<li class="toctree-l2"><a class="reference internal" href="romconsole.html">ROM გამართვა კონსოლი</a></li>
<li class="toctree-l2"><a class="reference internal" href="../security/secure-boot.html">უსაფრთხო ჩატვირთვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="thread-local-storage.html">ძაფების ლოკალური საცავი</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools/index.html">ხელსაწყოები</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp.html">ULP კოპროცესორი</a></li>
<li class="toctree-l2"><a class="reference internal" href="ulp-legacy.html">ULP კოპროცესორი (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests-legacy.html">ერთეულის ტესტირება (Legacy GNU Make)</a></li>
<li class="toctree-l2"><a class="reference internal" href="unit-tests.html">ერთეულის ტესტირება</a></li>
<li class="toctree-l2"><a class="reference internal" href="wifi.html">WiFi დრაივერი</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../index.html">დოკუმენტები</a> »</li>
<li><a href="index.html">API სახელმძღვანელოები</a> »</li>
<li>სისტემის შექმნა</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-guides/build-system.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="build-system">
<h1>სისტემის შექმნა<a class="headerlink" href="build-system.html#build-system" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/api-guides/build-system.html">[中文]</a></p>
<p>ეს დოკუმენტი განმარტავს ESP-IDF build სისტემის იმპლემენტაციას და „ კომპონენტი “-ის კონცეფციას. წაიკითხეთ ეს დოკუმენტი, თუ გსურთ იცოდეთ, თუ როგორ უნდა ორგანიზება გაუკეთოთ და შექმნათ ახალი ESP-IDF პროექტი ან კომპონენტი .</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ეს დოკუმენტი აღწერს CMake-ზე დაფუძნებულ აწყობის სისტემას, რომელიც ESP-IDF V4.0-დან ნაგულისხმევია. ESP-IDF ასევე მხარს უჭერს <a class="reference internal" href="build-system-legacy.html"><span class="doc">GNU Make-ზე დაფუძნებული მემკვიდრეობითი აწყობის სისტემა</span></a>, რომელიც ESP-IDF V4.0-მდე ნაგულისხმევი იყო.</p>
</div>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="build-system.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF პროექტი შეიძლება განვიხილოთ, როგორც კომპონენტი ის რამდენიმე პროექტის გაერთიანება. მაგალითად, ვებ სერვერისთვის, რომელიც მიმდინარე ტენიანობას აჩვენებს, შეიძლება არსებობდეს:</p>
<ul class="simple">
<li>ESP32 ბაზის ბიბლიოთეკები (libc, ROM ბმულები და ა.შ.)</li>
<li>WiFi-ის დრაივერები</li>
<li>TCP/IP დასტა</li>
<li>Free RTOS ოპერაციული სისტემა</li>
<li>ვებ სერვერი</li>
<li>ტენიანობის სენსორის დრაივერი</li>
<li>მთავარი კოდი, რომელიც ყველაფერს აერთიანებს</li>
</ul>
<p>ESP-IDF ამ კომპონენტი ებს ცალსახად და კონფიგურირებადს ხდის. ამისათვის, როდესაც პროექტი კომპილაცია d-ია, შექმნის სისტემა მოძებნის ყველა კომპონენტი ს ESP-IDF დირექტორიებში, პროექტის დირექტორიებში და (სურვილისამებრ) დამატებით მორგებულ კომპონენტი დირექტორიებში. შემდეგ ის საშუალებას აძლევს მომხმარებელს დააკონფიგურიროს ESP-IDF პროექტი ტექსტზე დაფუძნებული მენიუს სისტემის გამოყენებით, რათა თითოეული კომპონენტი მორგებული იყოს. პროექტში კომპონენტი ების კონფიგურაციის შემდეგ, შექმნის სისტემა კომპილაცია პროექტს მოახდენს.</p>
<div class="section" id="concepts">
<h3>კონცეფციები<a class="headerlink" href="build-system.html#concepts" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>„პროექტი“ არის დირექტორია, რომელიც შეიცავს ყველა ფაილს და კონფიგურაციას ერთი „აპლიკაციის“ (შესრულებელი ფაილის) შესაქმნელად, ასევე დამატებით დამხმარე ელემენტებს, როგორიცაა დანაყოფების ცხრილი , მონაცემთა/ფაილური სისტემის დანაყოფები და ჩამტვირთავი .</li>
<li>„პროექტის კონფიგურაცია“ ინახება ერთ ფაილში, სახელწოდებით <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> პროექტის root დირექტორიაში. ეს კონფიგურაციის ფაილი შეცვლილია <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code> პროექტის კონფიგურაციის პერსონალიზებისთვის. ერთი პროექტი შეიცავს ზუსტად ერთ პროექტის კონფიგურაცია .</li>
<li>„აპლიკაცია“ არის შესრულებადი ფაილი, რომელიც შექმნილია ESP-IDF მიერ. ერთი პროექტი, როგორც წესი, ქმნის ორ აპლიკაციას - „პროექტის აპლიკაციას“ (ძირითადი შესრულებადი ფაილი, ანუ თქვენი მორგებული პროგრამული უზრუნველყოფა ) და „ ჩამტვირთავი აპლიკაციას“ (საწყისი ჩამტვირთავი პროგრამა, რომელიც რთავს პროექტის აპლიკაციას).</li>
<li>„ კომპონენტი “ არის ცალკეული კოდის მოდულური ნაწილები, რომლებიც კომპილაცია შია ჩასმული სტატიკურ ბიბლიოთეკებში (.a ფაილებში) და დაკავშირებულია აპლიკაციასთან. ზოგიერთი მათგანი მოწოდებულია თავად ESP-IDF მიერ, ზოგი კი შეიძლება სხვა წყაროებიდან იყოს აღებული.</li>
<li>„Target“ არის აპარატურა, რომლისთვისაც აპლიკაციაა აგებული. ამ ეტაპზე, ESP-IDF მხარს უჭერს <code class="docutils literal notranslate"><span class="pre">esp32</span></code> და <code class="docutils literal notranslate"><span class="pre">esp32s2</span></code> სამიზნეები.</li>
</ul>
<p>ზოგიერთი რამ პროექტის ნაწილი არ არის:</p>
<ul class="simple">
<li>„ ESP-IDF “ პროექტის ნაწილი არ არის. ის დამოუკიდებელია და პროექტთან დაკავშირებულია შემდეგი გზით: <code class="docutils literal notranslate"><span class="pre">IDF_PATH</span></code> გარემოს ცვლადი, რომელიც ინახავს გზას <code class="docutils literal notranslate"><span class="pre">esp-idf</span></code> დირექტორია. ეს საშუალებას იძლევა IDF ჩარჩო გამოეყოს თქვენი პროექტიდან.</li>
<li>კომპილაციისთვის განკუთვნილი ინსტრუმენტების ნაკრები პროექტის ნაწილი არ არის. ინსტრუმენტების ნაკრები უნდა დაინსტალირდეს სისტემის ბრძანების ხაზში PATH.</li>
</ul>
</div>
</div>
<div class="section" id="using-the-build-system">
<h2>შექმნის სისტემის გამოყენება<a class="headerlink" href="build-system.html#using-the-build-system" title="Permalink to this headline">¶</a></h2>
<div class="section" id="idf-py">
<span id="id1"></span><h3>idf.py<a class="headerlink" href="build-system.html#idf-py" title="Permalink to this headline">¶</a></h3>
<p>ის <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> ბრძანების ხაზის ინსტრუმენტი უზრუნველყოფს წინა პანელს თქვენი პროექტის აწყობის მარტივად სამართავად. ის მართავს შემდეგ ინსტრუმენტებს:</p>
<ul class="simple">
<li><a class="reference external" href="https://cmake.org">CMake</a>, რომელიც განსაზღვრავს ასაშენებელ პროექტს</li>
<li>ბრძანების ხაზის შექმნის ინსტრუმენტი (ან <a class="reference external" href="https://ninja-build.org">ნინძა</a> ააშენე ან <cite>GNU Make</cite>)</li>
<li><a class="reference external" href="https://github.com/espressif/esptool/#readme">esptool.py</a> ფლეშ მეხსიერება , ESP32-ის ჩათვლით.</li>
</ul>
<p>ის <a class="reference internal" href="../get-started/index.html#get-started-configure"><span class="std std-ref">დაწყების სახელმძღვანელო</span></a> შეიცავს მოკლე შესავალს, თუ როგორ უნდა დააყენოთ <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> კონფიგურაციისთვის, ასაშენებლად და ფლეშ მეხსიერება პროექტებისთვის.</p>
<p><code class="docutils literal notranslate"><span class="pre">idf.py</span></code> უნდა გაშვებული იყოს ESP-IDF „project“ დირექტორიაში, ანუ ისეთში, რომელიც შეიცავს <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი. Makefile-ით ძველი სტილის პროექტები არ იმუშავებს <code class="docutils literal notranslate"><span class="pre">idf.py</span></code>.</p>
<p>ტიპი <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">--help</span></code> ბრძანებების სიისთვის. აქ მოცემულია ყველაზე სასარგებლო ბრძანებების შეჯამება:</p>
<ul>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">set-target</span> <span class="pre">&lt;target&gt;</span></code> ადგენს სამიზნეს (ჩიპს), რომლისთვისაც პროექტი აგებულია. იხილეთ <a class="reference internal" href="build-system.html#selecting-idf-target"><span class="std std-ref">სამიზნის შერჩევა</span></a>.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code> პროექტის კონფიგურაციისთვის იყენებს „ menuconfig “ ინსტრუმენტს.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">build</span></code> მიმდინარე დირექტორიაში ნაპოვნი პროექტის შექმნა მოხდება. ეს შეიძლება რამდენიმე ნაბიჯს მოიცავდეს:</p>
<ul class="simple">
<li>საჭიროების შემთხვევაში შექმენით შექმნის დირექტორია. ქვედირექტორია <code class="docutils literal notranslate"><span class="pre">build</span></code> გამოიყენება აწყობის გამომავალი მონაცემების შესანახად, თუმცა ეს შეიძლება შეიცვალოს <code class="docutils literal notranslate"><span class="pre">-B</span></code> ვარიანტი.</li>
<li>სირბილი <a class="reference external" href="https://cmake.org">CMake</a> საჭიროებისამებრ, პროექტის კონფიგურაციისთვის და ძირითადი აწყობის ინსტრუმენტისთვის აწყობის ფაილების გენერირებისთვის.</li>
<li>გაუშვით მთავარი აწყობის ინსტრუმენტი (<a class="reference external" href="https://ninja-build.org">ნინძა</a> ან <cite>GNU Make</cite>). ნაგულისხმევად, შექმნის ინსტრუმენტი ავტომატურად ფიქსირდება, მაგრამ მისი ცალსახად დაყენება შესაძლებელია <code class="docutils literal notranslate"><span class="pre">-G</span></code> ვარიანტი <code class="docutils literal notranslate"><span class="pre">idf.py</span></code>.</li>
</ul>
<p>აწყობა ინკრემენტულია, ამიტომ თუ ბოლო აწყობის შემდეგ არცერთი საწყისი ფაილი ან კონფიგურაცია არ შეცვლილა, არაფერი შესრულდება.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">clean</span></code> პროექტს „გაწმენდს“ აწყობის დირექტორიიდან აწყობის გამომავალი ფაილების წაშლით, რაც პროექტის შემდეგი აწყობის დროს „სრულ აღდგენას“ გამოიწვევს. გასუფთავება არ წაშლის CMake კონფიგურაციის გამომავალ მონაცემებს და ზოგიერთ სხვა ფაილს.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">fullclean</span></code> წაშლის „build“ დირექტორიის მთელ შინაარსს. ეს მოიცავს CMake კონფიგურაციის ყველა გამომავალს. შემდეგ ჯერზე, როდესაც პროექტი აშენდება, CMake მას ნულიდან დააკონფიგურირებს. გაითვალისწინეთ, რომ ეს პარამეტრი რეკურსიულად წაშლის <em>ყველა</em> ფაილები build დირექტორიაში, ამიტომ გამოიყენეთ სიფრთხილით. პროექტის კონფიგურაცია არ წაიშლება.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">flash</span></code> საჭიროების შემთხვევაში, ავტომატურად ააშენებს პროექტს და შემდეგ ფლეშ მეხსიერება მას ESP32-ში. <code class="docutils literal notranslate"><span class="pre">-p</span></code> და <code class="docutils literal notranslate"><span class="pre">-b</span></code> პარამეტრების გამოყენება შესაძლებელია შესაბამისად, სერიული პორტი სახელის და ფლეშ მეხსიერება ან ბოდის სიჩქარე დასაყენებლად.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">monitor</span></code> აჩვენებს ESP32-ის სერიულ გამომავალს. <code class="docutils literal notranslate"><span class="pre">-p</span></code> ოფციის გამოყენება შესაძლებელია სერიული პორტი სახელის დასაყენებლად. ტიპი <code class="docutils literal notranslate"><span class="pre">Ctrl-]</span></code> მონიტორიდან გასასვლელად. იხილეთ <a class="reference internal" href="tools/idf-monitor.html"><span class="doc">IDF მონიტორი</span></a> მონიტორის გამოყენების შესახებ დამატებითი ინფორმაციისთვის.</p>
</li>
</ul>
<p>მრავალჯერადი <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> ბრძანებების გაერთიანება შესაძლებელია ერთში. მაგალითად, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">-p</span> <span class="pre">COM4</span> <span class="pre">clean</span> <span class="pre">flash</span> <span class="pre">monitor</span></code> გაწმენდს წყაროს ხეს, შემდეგ ააშენებს პროექტს და ფლეშ მეხსიერება მას ESP32-თან სერიული მონიტორის გაშვებამდე.</p>
<p>უცნობი ბრძანებებისთვის <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> განხორციელდება მცდელობა, რომ ისინი შესრულდეს, როგორც სისტემის შექმნის სამიზნე.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">გარემოს ცვლადები <code class="docutils literal notranslate"><span class="pre">ESPPORT</span></code> და <code class="docutils literal notranslate"><span class="pre">ESPBAUD</span></code> შეიძლება გამოყენებულ იქნას ნაგულისხმევი მნიშვნელობების დასაყენებლად <code class="docutils literal notranslate"><span class="pre">-p</span></code> და <code class="docutils literal notranslate"><span class="pre">-b</span></code> შესაბამისად, პარამეტრები. ამ პარამეტრების ბრძანების ხაზზე მითითება ცვლის ნაგულისხმევ პარამეტრებს.</p>
</div>
<div class="section" id="advanced-commands">
<span id="idf-py-size"></span><h4>გაფართოებული ბრძანებები<a class="headerlink" href="build-system.html#advanced-commands" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">app</span></code>, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">bootloader</span></code>, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">partition_table</span></code> შესაძლებელია მისი გამოყენება პროექტიდან მხოლოდ აპლიკაციის, ჩამტვირთავი ან დანაყოფების ცხრილი ასაგებად, შესაბამის შემთხვევაში.</li>
<li>არსებობს შესაბამისი ბრძანებები <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">app-flash</span></code>და ა.შ., ფლეშ მეხსიერება პროექტის მხოლოდ ეს ერთი ნაწილი, ESP32-მდე კი -.</li>
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">-p</span> <span class="pre">PORT</span> <span class="pre">erase_flash</span></code> esptool.py-ს გამოიყენებს ESP32-ის ფლეშ მეხსიერება ჩიპის მთლიანად წასაშლელად.</li>
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">size</span></code> ბეჭდავს აპლიკაციის ზომის შესახებ გარკვეულ ინფორმაციას. <code class="docutils literal notranslate"><span class="pre">size-components</span></code> და <code class="docutils literal notranslate"><span class="pre">size-files</span></code> მსგავსი ბრძანებებია, რომლებიც შესაბამისად, უფრო დეტალურ ინფორმაციას ბეჭდავენ per- კომპონენტი ან per-source-file-ის შესახებ. თუ განსაზღვრავთ ცვლადს <code class="docutils literal notranslate"><span class="pre">-DOUTPUT_JSON=1</span></code> CMake-ის გაშვებისას (ან <code class="docutils literal notranslate"><span class="pre">idf.py</span></code>), გამომავალი ფაილი ფორმატირებული იქნება JSON ფორმატში და არა ადამიანისთვის წასაკითხი ტექსტის სახით.</li>
<li><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">reconfigure</span></code> განმეორებითი გაშვება <a class="reference external" href="https://cmake.org">CMake</a> მაშინაც კი, თუ, როგორც ჩანს, ხელახლა გაშვება არ არის საჭირო. ეს არ არის აუცილებელი ნორმალური გამოყენების დროს, მაგრამ შეიძლება სასარგებლო იყოს ფაილების დამატების/წაშლის შემდეგ საწყისი ხიდან, ან CMake ქეშის ცვლადების შეცვლისას. მაგალითად, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">-DNAME='VALUE'</span> <span class="pre">reconfigure</span></code> შეიძლება გამოყენებულ იქნას ცვლადის დასაყენებლად <code class="docutils literal notranslate"><span class="pre">NAME</span></code> CMake ქეშში მნიშვნელობად <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>.</li>
</ul>
<p>მრავლობითის თანმიმდევრობა <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> ერთი და იგივე გამოძახებისას ბრძანებების გამოყენება მნიშვნელოვანი არ არის, ისინი ავტომატურად შესრულდება სწორი თანმიმდევრობით, რათა ყველაფერი ამოქმედდეს (მაგ., ფლეშ მეხსიერება ის გამოყენებამდე აწყობა, ფლეშ მეხსიერება ის გამოყენებამდე წაშლა და ა.შ.).</p>
</div>
<div class="section" id="idf-py-options">
<h4>idf.py-ის პარამეტრები<a class="headerlink" href="build-system.html#idf-py-options" title="Permalink to this headline">¶</a></h4>
<p>ყველა ხელმისაწვდომი root დონის ვარიანტის სანახავად, გაუშვით <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">--help</span></code>ქვებრძანებისთვის სპეციფიკური ვარიანტების ჩამოსათვლელად, გაუშვით <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">&lt;command&gt;</span> <span class="pre">--help</span></code>მაგალითად, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">monitor</span> <span class="pre">--help</span></code>აქ მოცემულია რამდენიმე სასარგებლო ვარიანტის სია:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">-C</span> <span class="pre">&lt;dir&gt;</span></code> საშუალებას იძლევა პროექტის დირექტორია გადაიტანოს ნაგულისხმევი მიმდინარე სამუშაო დირექტორიიდან.</li>
<li><code class="docutils literal notranslate"><span class="pre">-B</span> <span class="pre">&lt;dir&gt;</span></code> საშუალებას იძლევა, ნაგულისხმევიდან გადაუხვიოს შექმნის დირექტორიას <code class="docutils literal notranslate"><span class="pre">build</span></code> პროექტის დირექტორიის ქვედირექტორია.</li>
<li><code class="docutils literal notranslate"><span class="pre">--ccache</span></code> დროშის გამოყენება შესაძლებელია ჩართვისთვის <a class="reference external" href="https://ccache.dev/">CCache</a> საწყისი ფაილების კომპილაციისას, თუ <a class="reference external" href="https://ccache.dev/">CCache</a> ინსტრუმენტი დამონტაჟებულია. ამან შეიძლება მნიშვნელოვნად შეამციროს აწყობის დრო.</li>
</ul>
<p>გაითვალისწინეთ, რომ CCache-ის ზოგიერთ ძველ ვერსიაში შესაძლოა ზოგიერთ პლატფორმაზე შეცდომები გამოვლინდეს, ამიტომ თუ ფაილები მოსალოდნელის შესაბამისად არ აღდგება, სცადეთ ccache-ის გამორთვა და ხელახლა აწყობა. CCache-ის ჩართვა შესაძლებელია ნაგულისხმევად, თუ დააყენებთ <code class="docutils literal notranslate"><span class="pre">IDF_ENABLE_CCACHE</span></code> გარემოს ცვლადის არანულოვან მნიშვნელობად გადაყვანა. - <code class="docutils literal notranslate"><span class="pre">-v</span></code> დროშა ორივეს იწვევს <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> და აწყობის სისტემას დეტალური აწყობის გამოსავლის შესაქმნელად. ეს შეიძლება სასარგებლო იყოს გამართვა ging აწყობის პრობლემებისთვის.</p>
</div>
</div>
<div class="section" id="using-cmake-directly">
<h3>CMake-ის პირდაპირ გამოყენება<a class="headerlink" href="build-system.html#using-cmake-directly" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="build-system.html#idf-py"><span class="std std-ref">idf.py</span></a> არის გარს შემოვლებული <a class="reference external" href="https://cmake.org">CMake</a> მოხერხებულობისთვის. თუმცა, თუ გსურთ, შეგიძლიათ CMake-ის პირდაპირ გამოძახებაც.</p>
<p>როდესაც <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> აკეთებს რაღაცას, ის ბეჭდავს თითოეულ ბრძანებას, რომელსაც ასრულებს, მარტივი მითითებისთვის. მაგალითად, <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">build</span></code> ბრძანება იგივეა, რაც ამ ბრძანებების გაშვება bash shell-ში (ან მსგავსი ბრძანებების Windows Command Prompt-ისთვის):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir -p build
<span class="nb">cd</span> build
cmake .. -G Ninja   <span class="c1"># or 'Unix Makefiles'</span>
ninja
</pre></div>
</div>
<p>ზემოთ მოცემულ სიაში, <code class="docutils literal notranslate"><span class="pre">cmake</span></code> ბრძანება ახდენს პროექტის კონფიგურაციას და ქმნის აწყობის ფაილებს საბოლოო აწყობის ინსტრუმენტთან გამოსაყენებლად. ამ შემთხვევაში, საბოლოო აწყობის ინსტრუმენტია <a class="reference external" href="https://ninja-build.org">ნინძა</a>: სირბილი <code class="docutils literal notranslate"><span class="pre">ninja</span></code> რეალურად აშენებს პროექტს.</p>
<p>სირბილი არ არის საჭირო <code class="docutils literal notranslate"><span class="pre">cmake</span></code> ერთზე მეტჯერ. პირველი აწყობის შემდეგ, თქვენ მხოლოდ გაშვება დაგჭირდებათ <code class="docutils literal notranslate"><span class="pre">ninja</span></code> ყოველ ჯერზე. <code class="docutils literal notranslate"><span class="pre">ninja</span></code> ავტომატურად ხელახლა გამოიძახებს <code class="docutils literal notranslate"><span class="pre">cmake</span></code> თუ პროექტს რეკონფიგურაცია სჭირდება.</p>
<p>თუ CMake-ს იყენებთ <code class="docutils literal notranslate"><span class="pre">ninja</span></code> ან <code class="docutils literal notranslate"><span class="pre">make</span></code>ასევე არსებობს მიზნები მეტისთვის <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> ქვებრძანებები - მაგალითად, გაშვება <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">menuconfig</span></code> ან <code class="docutils literal notranslate"><span class="pre">ninja</span> <span class="pre">menuconfig</span></code> build დირექტორიაში იმუშავებს ისევე, როგორც <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">თუ უკვე იცნობთ <a class="reference external" href="https://cmake.org">CMake</a>შესაძლოა, CMake-ზე დაფუძნებული აწყობის სისტემა ESP-IDF უჩვეულოდ მოგეჩვენოთ, რადგან ის CMake-ის ფუნქციონალურობის დიდ ნაწილს მოიცავს სტანდარტული ვერსიის შესამცირებლად. იხილეთ <a class="reference internal" href="build-system.html#writing-pure-cmake-components">სუფთა CMake-ის კომპონენტი წერა</a> „CMake სტილის“ წერის შესახებ დამატებითი ინფორმაციისთვის კომპონენტი 19.</p>
</div>
<div class="section" id="flashing-with-ninja-or-make">
<span id="flash-with-ninja-or-make"></span><h4>ნინძასთან ან მაკასთან ერთად ფლეშინგი<a class="headerlink" href="build-system.html#flashing-with-ninja-or-make" title="Permalink to this headline">¶</a></h4>
<p>შესაძლებელია ფლეშ მეხსიერება აწყობა პირდაპირ ნინძადან ან შექმნა ისეთი სამიზნის გაშვებით, როგორიცაა:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>ninja flash
</pre></div>
</div>
<p>ან:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make app-flash
</pre></div>
</div>
<p>ხელმისაწვდომი სამიზნეებია: <code class="docutils literal notranslate"><span class="pre">flash</span></code>, <code class="docutils literal notranslate"><span class="pre">app-flash</span></code> (მხოლოდ აპლიკაცია), <code class="docutils literal notranslate"><span class="pre">bootloader-flash</span></code> (მხოლოდ ჩამტვირთავი ).</p>
<p>როდესაც ფლეშ მეხსიერება ამ გზით მუშაობს, სურვილისამებრ დააყენეთ <code class="docutils literal notranslate"><span class="pre">ESPPORT</span></code> და <code class="docutils literal notranslate"><span class="pre">ESPBAUD</span></code> გარემოს ცვლადები სერიული პორტი და ბოდის სიჩქარე მითითებისთვის. გარემოს ცვლადების დაყენება შეგიძლიათ თქვენს ოპერაციულ სისტემაში ან IDE პროექტში. ალტერნატიულად, მათი დაყენება პირდაპირ ბრძანების ხაზზეა შესაძლებელი:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">ESPPORT</span><span class="o">=</span>/dev/ttyUSB0 ninja flash
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ბრძანების დასაწყისში გარემოს ცვლადების ასეთი სახით მიწოდება Bash shell-ის სინტაქსია. ის Linux-სა და macOS-ზე იმუშავებს. ის არ იმუშავებს Windows Command Prompt-ის გამოყენებისას, მაგრამ იმუშავებს Windows-ზე Bash-ის მსგავსი shell-ების გამოყენებისას.</p>
</div>
<p>ან:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make -j3 app-flash <span class="nv">ESPPORT</span><span class="o">=</span>COM4 <span class="nv">ESPBAUD</span><span class="o">=</span><span class="m">2000000</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ბრძანების ხაზის ბოლოს ცვლადების მიწოდებაა <code class="docutils literal notranslate"><span class="pre">make</span></code> სინტაქსი და მუშაობს <code class="docutils literal notranslate"><span class="pre">make</span></code> ყველა პლატფორმაზე.</p>
</div>
</div>
</div>
<div class="section" id="using-cmake-in-an-ide">
<h3>CMake-ის გამოყენება IDE-ში<a class="headerlink" href="build-system.html#using-cmake-in-an-ide" title="Permalink to this headline">¶</a></h3>
<p>ასევე შეგიძლიათ გამოიყენოთ CMake ინტეგრაციით IDE. IDE-ს დასჭირდება პროექტისკენ მიმავალი გზის ცოდნა. <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი. CMake ინტეგრაციის მქონე IDE-ები ხშირად უზრუნველყოფენ საკუთარ შექმნის ინსტრუმენტებს (CMake მათ „გენერატორებს“ უწოდებს) საწყისი ფაილების IDE-ს ნაწილად შესაქმნელად.</p>
<p>IDE-ში ისეთი არა-build ნაბიჯების დამატებისას, როგორიცაა „ ფლეშ მეხსიერება “, რეკომენდებულია მისი შესრულება <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> ამ „სპეციალური“ ბრძანებებისთვის.</p>
<p>ESP-IDF CMake-თან IDE-ში ინტეგრირების შესახებ უფრო დეტალური ინფორმაციისთვის იხილეთ <a class="reference internal" href="build-system.html#build-system-metadata">სისტემის მეტამონაცემების შექმნა</a>.</p>
</div>
<div class="section" id="setting-the-python-interpreter">
<span id="setting-python-interpreter"></span><h3>Python-ის ინტერპრეტატორის დაყენება<a class="headerlink" href="build-system.html#setting-the-python-interpreter" title="Permalink to this headline">¶</a></h3>
<p>ამჟამად, ESP-IDF მხოლოდ Python 2.7-თან მუშაობს. თუ თქვენ გაქვთ სისტემა, სადაც ნაგულისხმევი <code class="docutils literal notranslate"><span class="pre">python</span></code> ინტერპრეტატორი არის Python 3.x, ამან შეიძლება პრობლემები გამოიწვიოს.</p>
<p>თუ იყენებთ <code class="docutils literal notranslate"><span class="pre">idf.py</span></code>, სირბილი <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> როგორც <code class="docutils literal notranslate"><span class="pre">python2</span> <span class="pre">$IDF_PATH/tools/idf.py</span> <span class="pre">...</span></code> ამ პრობლემას გადაჭრის (<code class="docutils literal notranslate"><span class="pre">idf.py</span></code> სხვა Python პროცესებს ეტყვის, გამოიყენონ იგივე Python ინტერპრეტატორი). ბრძანების გასამარტივებლად შეგიძლიათ დააყენოთ shell-ის მეტსახელი ან სხვა სკრიპტი.</p>
<p>თუ CMake-ს პირდაპირ იყენებთ, გაშვებულია <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">-D</span> <span class="pre">PYTHON=python2</span> <span class="pre">...</span></code> გამოიწვევს CMake-ის მიერ Python-ის ნაგულისხმევი ინტერპრეტატორის გადახედვას.</p>
<p>თუ იყენებთ IDE-ს CMake-ით, დააყენეთ <code class="docutils literal notranslate"><span class="pre">PYTHON</span></code> IDE UI-ში CMake ქეშის გადაფარვის მნიშვნელობა გადაფარავს Python-ის ნაგულისხმევ ინტერპრეტატორს.</p>
<p>Python-ის ვერსიის უფრო ზოგადად ბრძანების ხაზის მეშვეობით სამართავად, გაეცანით ინსტრუმენტებს <a class="reference external" href="https://github.com/pyenv/pyenv#README">პიენვი</a> ან <a class="reference external" href="https://virtualenv.pypa.io/en/stable/">ვირტუალური გარემო</a>ეს საშუალებას გაძლევთ შეცვალოთ Python-ის ნაგულისხმევი ვერსია.</p>
</div>
</div>
<div class="section" id="example-project">
<span id="example-project-structure"></span><h2>პროექტის მაგალითი<a class="headerlink" href="build-system.html#example-project" title="Permalink to this headline">¶</a></h2>
<p>პროექტის დირექტორიის ხის მაგალითი შეიძლება ასე გამოიყურებოდეს:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- myProject/
             - CMakeLists.txt
             - sdkconfig
             - components/ - component1/ - CMakeLists.txt
                                         - Kconfig
                                         - src1.c
                           - component2/ - CMakeLists.txt
                                         - Kconfig
                                         - src1.c
                                         - include/ - component2.h
             - main/       - CMakeLists.txt
                           - src1.c
                           - src2.c

             - build/
</pre></div>
</div>
<p>ეს მაგალითი „ჩემი პროექტი“ შეიცავს შემდეგ ელემენტებს:</p>
<ul class="simple">
<li>პროექტის CMakeLists.txt ფაილი, რომელიც უმაღლესი დონისაა. ეს არის ძირითადი ფაილი, რომელსაც CMake იყენებს პროექტის აგების შესასწავლად; და შეიძლება დააყენოს პროექტის მასშტაბით CMake ცვლადები. ის მოიცავს ფაილს <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/project.cmake">/tools/cmake/project.cmake</a> რომელიც ახორციელებს აწყობის სისტემის დანარჩენ ნაწილს. და ბოლოს, ის ადგენს პროექტის სახელს და განსაზღვრავს პროექტს.</li>
<li>„sdkconfig“ პროექტის კონფიგურაცია ფაილი. ეს ფაილი იქმნება/განახლდება, როდესაც <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">menuconfig</span></code> გაშვებულია და ინახავს პროექტში არსებული ყველა კომპონენტი ფაილის კონფიგურაციას (თავად ESP-IDF ჩათვლით). „sdkconfig“ ფაილი შეიძლება დაემატოს ან არ დაემატოს პროექტის საწყისი კონტროლის სისტემას.</li>
<li>სურვილისამებრ „ კომპონენტი s“ დირექტორია შეიცავს კომპონენტი ს, რომლებიც პროექტის ნაწილია. პროექტი არ უნდა შეიცავდეს ამ ტიპის მორგებულ კომპონენტი ს, მაგრამ ის შეიძლება სასარგებლო იყოს მრავალჯერადი გამოყენების კოდის სტრუქტურირებისთვის ან მესამე მხარის კომპონენტი ების ჩართვისთვის, რომლებიც არ არიან ESP-IDF ის ნაწილი. ალტერნატიულად, <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENT_DIRS</span></code> შეიძლება დაყენდეს CMakeLists.txt-ის ზედა დონის ფაილში, რათა სხვა ადგილებშიც მოიძებნოს კომპონენტი s. იხილეთ <a class="reference internal" href="build-system.html#rename-main"><span class="std std-ref">მთავარი სახელის გადარქმევა</span></a> დამატებითი ინფორმაციისთვის იხილეთ განყოფილება. თუ თქვენს პროექტში ბევრი საწყისი ფაილი გაქვთ, გირჩევთ, რომ მათი უმეტესობა კომპონენტი s-ში დააჯგუფოთ, ყველა „main“-ში მოთავსების ნაცვლად.</li>
<li>„main“ დირექტორია არის სპეციალური კომპონენტი , რომელიც შეიცავს თავად პროექტის საწყის კოდს. „main“ არის ნაგულისხმევი სახელი, CMake ცვლადი. <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code> მოიცავს ამ კომპონენტი , მაგრამ შეგიძლიათ შეცვალოთ ეს ცვლადი.</li>
<li>„build“ დირექტორია არის ის, სადაც იქმნება build-ის შედეგი. ეს დირექტორია შექმნილია <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> თუ ის უკვე არ არსებობს. CMake ახდენს პროექტის კონფიგურაციას და ამ დირექტორიაში შუალედური აწყობის ფაილებს წარმოქმნის. შემდეგ, ძირითადი აწყობის პროცესის გაშვების შემდეგ, ეს დირექტორია ასევე შეიცავს შუალედურ ობიექტის ფაილებს და ბიბლიოთეკებს, ასევე საბოლოო ორობით გამომავალ ფაილებს. ეს დირექტორია, როგორც წესი, არ ემატება წყაროს კონტროლს და არ ნაწილდება პროექტის წყაროს კოდთან ერთად.</li>
</ul>
<p>კომპონენტების დირექტორიები შეიცავს კომპონენტი <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი. ეს ფაილი შეიცავს ცვლადების განმარტებებს კომპონენტი ის შექმნის პროცესის გასაკონტროლებლად და მისი მთლიან პროექტში ინტეგრაციისთვის. იხილეთ <a class="reference internal" href="build-system.html#component-cmakelists-files">კომპონენტის CMakeLists ფაილები</a> დამატებითი დეტალებისთვის.</p>
<p>თითოეული კომპონენტი შეიძლება ასევე მოიცავდეს <code class="docutils literal notranslate"><span class="pre">Kconfig</span></code> ფაილი, რომელიც განსაზღვრავს <a class="reference internal" href="build-system.html#id2">კომპონენტი კონფიგურაცია</a> პარამეტრები, რომელთა დაყენებაც შესაძლებელია <code class="docutils literal notranslate"><span class="pre">menuconfig</span></code>ზოგიერთი კომპონენტი ტერმინი შეიძლება ასევე მოიცავდეს <code class="docutils literal notranslate"><span class="pre">Kconfig.projbuild</span></code> და <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილები, რომლებიც სპეციალური ფაილებია <a class="reference internal" href="build-system.html#overriding-parts-of-the-project">პროექტის გადამწყვეტი ნაწილები</a>.</p>
</div>
<div class="section" id="project-cmakelists-file">
<h2>პროექტის CMakeLists ფაილი<a class="headerlink" href="build-system.html#project-cmakelists-file" title="Permalink to this headline">¶</a></h2>
<p>თითოეულ პროექტს აქვს ერთი უმაღლესი დონე <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი, რომელიც შეიცავს მთელი პროექტის შექმნის პარამეტრებს. ნაგულისხმევად, პროექტის CMakeLists შეიძლება საკმაოდ მინიმალური იყოს.</p>
<div class="section" id="minimal-example-cmakelists">
<h3>მინიმალური CMakeLists-ის მაგალითები<a class="headerlink" href="build-system.html#minimal-example-cmakelists" title="Permalink to this headline">¶</a></h3>
<p>მინიმალური პროექტი:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.5</span><span class="p">)</span>
<span class="nb">include</span><span class="p">(</span><span class="o">$ENV{</span><span class="nv">IDF_PATH</span><span class="o">}</span><span class="s">/tools/cmake/project.cmake</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">myProject</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="mandatory-parts">
<span id="project-mandatory-parts"></span><h3>სავალდებულო ნაწილები<a class="headerlink" href="build-system.html#mandatory-parts" title="Permalink to this headline">¶</a></h3>
<p>ამ სამი ხაზის ჩართვა, ზემოთ მითითებული თანმიმდევრობით, აუცილებელია ყველა პროექტისთვის:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">cmake_minimum_required(VERSION</span> <span class="pre">3.5)</span></code> CMake-ს ეუბნება პროექტის ასაწყობად საჭირო მინიმალურ ვერსიას. ESP-IDF შექმნილია CMake 3.5-თან ან უფრო ახალ ვერსიასთან სამუშაოდ. ეს ხაზი უნდა იყოს პირველი ხაზი CMakeLists.txt ფაილში.</li>
<li><code class="docutils literal notranslate"><span class="pre">include($ENV{IDF_PATH}/tools/cmake/project.cmake)</span></code> იზიდავს CMake-ის დანარჩენ ფუნქციონალს პროექტის კონფიგურაციისთვის, ყველა კომპონენტი ის აღმოსაჩენად და ა.შ.</li>
<li><code class="docutils literal notranslate"><span class="pre">project(myProject)</span></code> ქმნის თავად პროექტს და განსაზღვრავს პროექტის სახელს. პროექტის სახელი გამოიყენება აპლიკაციის საბოლოო ორობითი გამომავალი ფაილებისთვის - მაგ. <code class="docutils literal notranslate"><span class="pre">myProject.elf</span></code>, <code class="docutils literal notranslate"><span class="pre">myProject.bin</span></code>CMakeLists ფაილზე მხოლოდ ერთი პროექტის განსაზღვრაა შესაძლებელი.</li>
</ul>
</div>
<div class="section" id="optional-project-variables">
<h3>პროექტის არჩევითი ცვლადები<a class="headerlink" href="build-system.html#optional-project-variables" title="Permalink to this headline">¶</a></h3>
<p>ამ ცვლადებს აქვთ ნაგულისხმევი მნიშვნელობები, რომელთა შეცვლა შესაძლებელია მორგებული ქცევისთვის. იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/project.cmake">/tools/cmake/project.cmake</a> განხორციელების ყველა დეტალისთვის.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code>, <code class="docutils literal notranslate"><span class="pre">COMPONENTS_DIRS</span></code>: დირექტორიები კომპონენტი ის მოსაძებნად. ნაგულისხმევად <code class="docutils literal notranslate"><span class="pre">IDF_PATH/components</span></code>, <code class="docutils literal notranslate"><span class="pre">PROJECT_DIR/components</span></code>და <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENT_DIRS</span></code>თუ არ გსურთ ამ ადგილებში კომპონენტი ის ძებნა, გადახედეთ ამ ცვლადს.</li>
<li><code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENT_DIRS</span></code>, <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENTS_DIRS</span></code>კომპონენტი s-ის მოსაძებნად დამატებითი დირექტორიების არასავალდებულო სია. გზები შეიძლება იყოს პროექტის დირექტორიასთან ფარდობითი ან აბსოლუტური.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code>პროექტში ჩასართავად კომპონენტი სახელების სია. ნაგულისხმევად გამოიყენება ყველა კომპონენტი , რომელიც ნაპოვნია <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code> დირექტორიები. გამოიყენეთ ეს ცვლადი პროექტის „შესამცირებლად“ უფრო სწრაფი აწყობის დროის გასაზრდელად. გაითვალისწინეთ, რომ ნებისმიერი კომპონენტი , რომელიც „საჭიროებს“ სხვა კომპონენტი კომპონენტი რეგისტრაციისას REQUIRES ან PRIV_REQUIRES არგუმენტების მეშვეობით, ავტომატურად დაემატება ამ სიას, ამიტომ <code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code> სია შეიძლება ძალიან მოკლე იყოს.</li>
</ul>
<p>ამ ცვლადებში ნებისმიერი გზა შეიძლება იყოს აბსოლუტური გზები ან დაყენებული იყოს პროექტის დირექტორიასთან შედარებით.</p>
<p>ამ ცვლადების დასაყენებლად გამოიყენეთ <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/set.html">cmake set ბრძანება</a> ანუ <code class="docutils literal notranslate"><span class="pre">set(VARIABLE</span> <span class="pre">"VALUE")</span></code>. ის <code class="docutils literal notranslate"><span class="pre">set()</span></code> ბრძანებები უნდა განთავსდეს შემდეგ <code class="docutils literal notranslate"><span class="pre">cmake_minimum(...)</span></code> ხაზი, მაგრამ სანამ <code class="docutils literal notranslate"><span class="pre">include(...)</span></code> ხაზი.</p>
</div>
<div class="section" id="renaming-main-component">
<span id="rename-main"></span><h3>გადარქმევა <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი<a class="headerlink" href="build-system.html#renaming-main-component" title="Permalink to this headline">¶</a></h3>
<p>მშენებლობის სისტემა განსაკუთრებულ მიდგომას ითვალისწინებს <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი . ეს არის კომპონენტი , რომელიც ავტომატურად ემატება ბილდს იმ პირობით, რომ ის მოსალოდნელ ადგილას, PROJECT_DIR/main-ზეა. ბილდში ყველა სხვა კომპონენტი ასევე ემატება მის დამოკიდებულებად, რაც მომხმარებელს დამოკიდებულებების ძიებისგან იცავს და უზრუნველყოფს ბილდს, რომელიც დაუყოვნებლივ მუშაობს. <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი იწვევს ამ კულისებში არსებული მძიმე სამუშაოს დაკარგვას, რაც მომხმარებელს აიძულებს მიუთითოს ახლად გადარქმეული კომპონენტი ის ადგილმდებარეობა და ხელით მიუთითოს მისი დამოკიდებულებები. კერძოდ, სახელის გადარქმევის ნაბიჯები <code class="docutils literal notranslate"><span class="pre">main</span></code> შემდეგია:</p>
<ol class="arabic simple">
<li>გადარქმევა <code class="docutils literal notranslate"><span class="pre">main</span></code> დირექტორია.</li>
<li>კომპლექტი <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENT_DIRS</span></code> პროექტში CMakeLists.txt, რათა ჩავრთოთ გადარქმეული <code class="docutils literal notranslate"><span class="pre">main</span></code> დირექტორია.</li>
<li>მიუთითეთ დამოკიდებულებები გადარქმეულ კომპონენტი ის CMakeLists.txt ფაილში REQUIRES ან PRIV_REQUIRES არგუმენტების გამოყენებით. <a class="reference internal" href="build-system.html#cmake-minimal-component-cmakelists"><span class="std std-ref">კომპონენტი რეგისტრაცია</span></a>.</li>
</ol>
</div>
</div>
<div class="section" id="component-cmakelists-files">
<span id="component-directories"></span><h2>კომპონენტის CMakeLists ფაილები<a class="headerlink" href="build-system.html#component-cmakelists-files" title="Permalink to this headline">¶</a></h2>
<p>თითოეული პროექტი შეიცავს ერთ ან მეტ კომპონენტი s-ს. კომპონენტები შეიძლება იყოს ESP-IDF ის ნაწილი, პროექტის საკუთარი კომპონენტი s დირექტორიის ნაწილი ან დაემატოს მორგებული კომპონენტი დირექტორიებიდან (<a class="reference internal" href="build-system.html#component-directories"><span class="std std-ref">იხილეთ ზემოთ</span></a>).</p>
<p>კომპონენტი არის ნებისმიერი დირექტორია <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code> სია, რომელიც შეიცავს <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი.</p>
<div class="section" id="searching-for-components">
<h3>კომპონენტების ძიება<a class="headerlink" href="build-system.html#searching-for-components" title="Permalink to this headline">¶</a></h3>
<p>დირექტორიების სია, რომლებიც <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code> პროექტის კომპონენტი s-ის ძიება ხდება. ამ სიაში არსებული დირექტორიები შეიძლება თავად კომპონენტი s იყოს (ანუ ისინი შეიცავენ <cite>CMakeLists.txt</cite> ფაილი), ან ისინი შეიძლება იყოს ზედა დონის დირექტორიები, რომელთა ქვედირექტორიებია კომპონენტი s.</p>
<p>როდესაც CMake მუშაობს პროექტის კონფიგურაციისთვის, ის აღრიცხავს ბილდში შემავალ კომპონენტი ს. ეს სია შეიძლება სასარგებლო იყოს გამართვა ისთვის გარკვეული კომპონენტი ის ჩართვის/გამორიცხვის დასადგენად.</p>
</div>
<div class="section" id="multiple-components-with-the-same-name">
<h3>ერთი და იგივე სახელის მქონე მრავალი კომპონენტი 19<a class="headerlink" href="build-system.html#multiple-components-with-the-same-name" title="Permalink to this headline">¶</a></h3>
<p>როდესაც ESP-IDF აგროვებს ყველა კომპონენტი ს კომპილაცია მდე, ის ამას გააკეთებს მითითებული თანმიმდევრობით <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIRS</span></code>; ნაგულისხმევად, ეს ნიშნავს, რომ ჯერ ESP-IDF ის შიდა კომპონენტი s-ია, შემდეგ პროექტის კომპონენტი s-ია და ბოლოს ნებისმიერ კომპონენტი s-ს, რომელიც დაყენებულია <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENT_DIRS</span></code>თუ ამ დირექტორიებიდან ორი ან მეტი შეიცავს კომპონენტი ქვედირექტორიებს ერთი და იგივე სახელით, გამოიყენება კომპონენტი , რომელიც ბოლო ძიების ადგილასაა. ეს საშუალებას იძლევა, მაგალითად, ESP-IDF კომპონენტი s-ის გადაფარვა შეცვლილი ვერსიით, ამ კომპონენტი ESP-IDF კომპონენტი s დირექტორიიდან პროექტის კომპონენტი s დირექტორიაში კოპირებით და შემდეგ იქ მისი შეცვლით. ამ გზით გამოყენების შემთხვევაში, თავად ESP-IDF დირექტორია შეიძლება ხელუხლებელი დარჩეს.</p>
</div>
<div class="section" id="minimal-component-cmakelists">
<span id="cmake-minimal-component-cmakelists"></span><h3>მინიმალური კომპონენტების CMakeLists<a class="headerlink" href="build-system.html#minimal-component-cmakelists" title="Permalink to this headline">¶</a></h3>
<p>მინიმალური კომპონენტი <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი უბრალოდ არეგისტრირებს კომპონენტი აწყობის სისტემაში გამოყენებით <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s2">"foo.c"</span> <span class="s2">"bar.c"</span>
                       <span class="s">INCLUDE_DIRS</span> <span class="s2">"include"</span>
                       <span class="s">REQUIRES</span> <span class="s">mbedtls</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SRCS</span></code> არის წყაროს ფაილების სია (<code class="docutils literal notranslate"><span class="pre">*.c</span></code>, <code class="docutils literal notranslate"><span class="pre">*.cpp</span></code>, <code class="docutils literal notranslate"><span class="pre">*.cc</span></code>, <code class="docutils literal notranslate"><span class="pre">*.S</span></code>). ეს საწყისი ფაილები კომპილაცია d-ში კომპონენტი ბიბლიოთეკაში იქნება.</li>
<li><code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> არის დირექტორიების სია, რომლებიც უნდა დაემატოს გლობალურ ძიების გზას ნებისმიერი კომპონენტი ისთვის, რომელიც მოითხოვს ამ კომპონენტი , ასევე მთავარ წყაროს ფაილებს.</li>
<li><code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> სინამდვილეში არ არის საჭირო, მაგრამ ძალიან ხშირად საჭიროა იმის დეკლარირება, თუ რომელ სხვა კომპონენტი გამოიყენებს ეს კომპონენტი . იხილეთ <a class="reference internal" href="build-system.html#component-requirements"><span class="std std-ref">კომპონენტის მოთხოვნები</span></a>.</li>
</ul>
<p>შეიქმნება ბიბლიოთეკა კომპონენტი ის სახელით და დაუკავშირდება საბოლოო აპლიკაციას. დირექტორიები, როგორც წესი, მითითებულია <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> თავად ფაილი, თუმცა ისინი შეიძლება აბსოლუტური იყოს.</p>
<p>არსებობს სხვა არგუმენტებიც, რომელთა გადაცემაც შესაძლებელია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>ეს არგუმენტები განხილულია <a class="reference internal" href="build-system.html#cmake-component-register"><span class="std std-ref">აქ</span></a>.</p>
<p>იხილეთ <a class="reference internal" href="build-system.html#example-component-requirements">კომპონენტი მოთხოვნების მაგალითი</a> და  <a class="reference internal" href="build-system.html#example-component-cmakelists">მაგალითი კომპონენტი CMakeLists</a> უფრო სრული კომპონენტი სანახავად <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> მაგალითები.</p>
</div>
<div class="section" id="preset-component-variables">
<span id="component-variables"></span><h3>წინასწარ დაყენებული კომპონენტის ცვლადები<a class="headerlink" href="build-system.html#preset-component-variables" title="Permalink to this headline">¶</a></h3>
<p>კომპონენტი CMakeLists-ში გამოსაყენებლად ხელმისაწვდომია შემდეგი კომპონენტი სპეციფიკური ცვლადები, მაგრამ მათი შეცვლა არ არის საჭირო:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_DIR</span></code>კომპონენტი დირექტორია. ფასდება დირექტორიის აბსოლუტური გზის მიხედვით, რომელიც შეიცავს <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>კომპონენტი გზა არ შეიძლება შეიცავდეს ინტერვალებს. ეს იგივეა, რაც <code class="docutils literal notranslate"><span class="pre">CMAKE_CURRENT_SOURCE_DIR</span></code> ცვლადი.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_NAME</span></code>: კომპონენტი ის სახელი. იგივეა, რაც კომპონენტი დირექტორიის სახელი.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_ALIAS</span></code>: ბიბლიოთეკის მეტსახელი, რომელიც შექმნილია კომპონენტი ისთვის build სისტემის მიერ.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_LIB</span></code>კომპონენტი ისთვის build სისტემის მიერ შიდა წესით შექმნილი ბიბლიოთეკის სახელი.</li>
</ul>
<p>შემდეგი ცვლადები დაყენებულია პროექტის დონეზე, მაგრამ ხელმისაწვდომია კომპონენტი CMakeLists-ში გამოსაყენებლად:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">CONFIG_*</span></code>: პროექტის კონფიგურაცია ში თითოეულ მნიშვნელობას აქვს შესაბამისი ცვლადი, რომელიც ხელმისაწვდომია cmake-ში. ყველა სახელი იწყება <code class="docutils literal notranslate"><span class="pre">CONFIG_</span></code>. <a class="reference internal" href="../api-reference/kconfig.html"><span class="doc">დამატებითი ინფორმაცია აქ</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">ESP_PLATFORM</span></code>დაყენებულია 1-ზე, როდესაც CMake ფაილი დამუშავდება ESP-IDF build სისტემაში.</li>
</ul>
</div>
<div class="section" id="build-project-variables">
<h3>შექმნის/პროექტის ცვლადები<a class="headerlink" href="build-system.html#build-project-variables" title="Permalink to this headline">¶</a></h3>
<p>ქვემოთ მოცემულია რამდენიმე project/build ცვლადი, რომლებიც ხელმისაწვდომია როგორც build თვისებები და რომელთა მნიშვნელობების მოთხოვნა შესაძლებელია გამოყენებით <code class="docutils literal notranslate"><span class="pre">idf_build_get_property</span></code>
კომპონენტი CMakeLists.txt ფაილიდან:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">PROJECT_NAME</span></code>პროექტის სახელი, როგორც მითითებულია პროექტის CMakeLists.txt ფაილში.</li>
<li><code class="docutils literal notranslate"><span class="pre">PROJECT_DIR</span></code>პროექტის CMakeLists-ის შემცველი პროექტის დირექტორიის აბსოლუტური გზა. იგივეა, რაც <code class="docutils literal notranslate"><span class="pre">CMAKE_SOURCE_DIR</span></code> ცვლადი.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code>: ამ ბილდში შემავალი ყველა კომპონენტი ის სახელი, ფორმატირებული როგორც წერტილ-მძიმით გამოყოფილი CMake სია.</li>
<li><code class="docutils literal notranslate"><span class="pre">IDF_VER</span></code>: ESP-IDF ის Git ვერსია (შექმნილია <code class="docutils literal notranslate"><span class="pre">git</span> <span class="pre">describe</span></code>)</li>
<li><code class="docutils literal notranslate"><span class="pre">IDF_VERSION_MAJOR</span></code>, <code class="docutils literal notranslate"><span class="pre">IDF_VERSION_MINOR</span></code>, <code class="docutils literal notranslate"><span class="pre">IDF_VERSION_PATCH</span></code>პირობით გამოსახულებებში გამოსაყენებელი ESP-IDF ვერსიის კომპონენტები. გაითვალისწინეთ, რომ ეს ინფორმაცია ნაკლებად ზუსტია, ვიდრე მოწოდებული <code class="docutils literal notranslate"><span class="pre">IDF_VER</span></code> ცვლადი. <code class="docutils literal notranslate"><span class="pre">v4.0-dev-*</span></code>, <code class="docutils literal notranslate"><span class="pre">v4.0-beta1</span></code>, <code class="docutils literal notranslate"><span class="pre">v4.0-rc1</span></code> და <code class="docutils literal notranslate"><span class="pre">v4.0</span></code> ყველას ერთნაირი ღირებულებები ექნება <code class="docutils literal notranslate"><span class="pre">IDF_VERSION_*</span></code> ცვლადები, მაგრამ განსხვავებული <code class="docutils literal notranslate"><span class="pre">IDF_VER</span></code> ღირებულებები.</li>
<li><code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code>: იმ ობიექტის დასახელება, რომლისთვისაც პროექტი შენდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">PROJECT_VER</span></code>: პროექტის ვერსია.<ul>
<li>თუ <a class="reference internal" href="../api-reference/kconfig.html#config-app-project-ver-from-config"><span class="std std-ref">CONFIG_APP_PROJECT_VER_FROM_CONFIG</span></a> ოფცია დაყენებულია, მნიშვნელობა <a class="reference internal" href="../api-reference/kconfig.html#config-app-project-ver"><span class="std std-ref">CONFIG_APP_PROJECT_VER</span></a> გამოყენებული იქნება.</li>
<li>წინააღმდეგ შემთხვევაში, თუ <code class="docutils literal notranslate"><span class="pre">PROJECT_VER</span></code> ცვლადი დაყენებულია პროექტის CMakeLists.txt ფაილში, გამოყენებული იქნება მისი მნიშვნელობა.</li>
<li>წინააღმდეგ შემთხვევაში, თუ <code class="docutils literal notranslate"><span class="pre">PROJECT_DIR/version.txt</span></code> არსებობს, მისი შინაარსი გამოყენებული იქნება როგორც <code class="docutils literal notranslate"><span class="pre">PROJECT_VER</span></code>.</li>
<li>წინააღმდეგ შემთხვევაში, თუ პროექტი Git რეპოზიტორიაში მდებარეობს, გამოყენებული იქნება git describe-ის გამომავალი.</li>
<li>წინააღმდეგ შემთხვევაში, <code class="docutils literal notranslate"><span class="pre">PROJECT_VER</span></code> იქნება „1“.</li>
</ul>
</li>
</ul>
<p>სხვა აწყობის თვისებები ჩამოთვლილია <a class="reference internal" href="build-system.html#cmake-build-properties"><span class="std std-ref">აქ</span></a>.</p>
</div>
<div class="section" id="controlling-component-compilation">
<h3>კომპონენტების კომპილაციის კონტროლი<a class="headerlink" href="build-system.html#controlling-component-compilation" title="Permalink to this headline">¶</a></h3>
<p>კონკრეტული კომპონენტი ის კუთვნილი საწყისი ფაილების კომპილაციისას კომპილაცია r პარამეტრების გადასაცემად გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">target_compile_options</span></code> ფუნქცია:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">target_compile_options</span><span class="p">(</span><span class="o">${</span><span class="nv">COMPONENT_LIB</span><span class="o">}</span> <span class="s">PRIVATE</span> <span class="s">-Wno-unused-variable</span><span class="p">)</span>
</pre></div>
</div>
<p>კომპილაციის ფლაგების ერთ წყაროს ფაილზე გამოსაყენებლად გამოიყენეთ CMake. <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/set_source_files_properties.html">set_source_files_properties</a> ბრძანება:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set_source_files_properties</span><span class="p">(</span><span class="s">mysrc.c</span>
    <span class="s">PROPERTIES</span> <span class="s">COMPILE_FLAGS</span>
    <span class="s">-Wno-unused-variable</span>
<span class="p">)</span>
</pre></div>
</div>
<p>ეს შეიძლება სასარგებლო იყოს, თუ არსებობს ზემოთ მოცემული კოდი, რომელიც გაფრთხილებებს ასხივებს.</p>
<p>ამ ბრძანებების გამოყენებისას, განათავსეთ ისინი ზარის შემდეგ <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> კომპონენტი CMakeLists ფაილში.</p>
</div>
</div>
<div class="section" id="component-configuration">
<span id="id2"></span><h2>კომპონენტის კონფიგურაცია<a class="headerlink" href="build-system.html#component-configuration" title="Permalink to this headline">¶</a></h2>
<p>თითოეულ კომპონენტი ასევე შეიძლება ჰქონდეს <code class="docutils literal notranslate"><span class="pre">Kconfig</span></code> ფაილი, გვერდით <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>ეს შეიცავს კონფიგურაციის პარამეტრებს, რომლებიც უნდა დაემატოს კონფიგურაციის მენიუში ამ კომპონენტი .</p>
<p>ეს პარამეტრები მოცემულია „კომპონენტის პარამეტრების“ მენიუში, როდესაც menuconfig გაშვებულია.</p>
<p>კომპონენტი Kconfig ფაილის შესაქმნელად, ყველაზე მარტივი გზაა ESP-IDF თან ერთად გავრცელებული Kconfig ფაილებიდან ერთ-ერთის გამოყენება.</p>
<p>მაგალითისთვის იხილეთ <a class="reference internal" href="build-system.html#adding-conditional-configuration">პირობითი კონფიგურაციის დამატება</a>.</p>
</div>
<div class="section" id="preprocessor-definitions">
<h2>წინასწარი პროცესორის განმარტებები<a class="headerlink" href="build-system.html#preprocessor-definitions" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF აწყობის სისტემა ბრძანების ხაზზე შემდეგ C წინასწარი პროცესორის განმარტებებს ამატებს:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">ESP_PLATFORM</span></code> შეიძლება გამოყენებულ იქნას იმის დასადგენად, ხდება თუ არა აწყობა ESP-IDF ფარგლებში.</li>
<li><code class="docutils literal notranslate"><span class="pre">IDF_VER</span></code> : განსაზღვრულია git ვერსიის სტრიქონად. მაგ. <code class="docutils literal notranslate"><span class="pre">v2.0</span></code> მონიშნული გამოშვებისთვის ან <code class="docutils literal notranslate"><span class="pre">v1.0-275-g0efaa4f</span></code> თვითნებური ჩადენისთვის.</li>
</ul>
</div>
<div class="section" id="component-requirements">
<span id="id3"></span><h2>კომპონენტის მოთხოვნები<a class="headerlink" href="build-system.html#component-requirements" title="Permalink to this headline">¶</a></h2>
<p>თითოეული კომპონენტი კომპილაციისას, ESP-IDF აგების სისტემა რეკურსიულად აფასებს მის დამოკიდებულებებს. ეს ნიშნავს, რომ თითოეულმა კომპონენტი უნდა გამოაცხადოს კომპონენტი , რომლებზეც ის დამოკიდებულია („საჭიროა“).</p>
<div class="section" id="when-writing-a-component">
<h3>კომპონენტი წერისას19<a class="headerlink" href="build-system.html#when-writing-a-component" title="Permalink to this headline">¶</a></h3>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">...</span>
                       <span class="s">REQUIRES</span> <span class="s">mbedtls</span>
                       <span class="s">PRIV_REQUIRES</span> <span class="s">console</span> <span class="s">spiffs</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> უნდა დაყენდეს ყველა კომპონენტი ზე, რომელთა სათაურის ფაილებიც #included-დანაა <em>საჯარო</em> ამ კომპონენტი სათაურის ფაილები19.</li>
<li><code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> უნდა დაყენდეს ყველა კომპონენტი ზე, რომელთა სათაურის ფაილებიც #included-დან არის <em>ნებისმიერი წყაროს ფაილი</em> ამ კომპონენტი , თუ უკვე არ არის ჩამოთვლილი <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code>ასევე ნებისმიერი კომპონენტი , რომლის დაკავშირებაც აუცილებელია ამ კომპონენტი სწორად ფუნქციონირებისთვის.</li>
<li>ღირებულებები <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> და <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> არ უნდა იყოს დამოკიდებული კონფიგურაციის არცერთ არჩევანზე (<code class="docutils literal notranslate"><span class="pre">CONFIG_xxx</span></code> მაკროები). ეს იმიტომ ხდება, რომ მოთხოვნები გაფართოვდება კონფიგურაციის ჩატვირთვამდე. სხვა კომპონენტი ცვლადები (როგორიცაა ჩართვის გზები ან წყაროს ფაილები) შეიძლება დამოკიდებული იყოს კონფიგურაციის არჩევანზე.</li>
<li>არც ერთის და არც ორივეს დაყენება არ ხდება <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> ცვლადები კარგია. თუ კომპონენტი არ აქვს მოთხოვნები, გარდა <a class="reference internal" href="build-system.html#common-component-requirements">კომპონენტი საერთო მოთხოვნები</a> საჭიროა RTOS ისთვის, libc-სთვის და ა.შ.</li>
</ul>
<p>თუ კომპონენტი მხოლოდ რამდენიმე სამიზნე ჩიპს უჭერს მხარს (მნიშვნელობები <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code>) შემდეგ მას შეუძლია მიუთითოს <code class="docutils literal notranslate"><span class="pre">REQUIRED_IDF_TARGETS</span></code> ში <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> ამ მოთხოვნების გამოსახატავად გამოძახება. ამ შემთხვევაში, შექმნის სისტემა შეცდომას გამოიმუშავებს, თუ კომპონენტი შედის შექმნის პროცესში, მაგრამ არ უჭერს მხარს არჩეულ სამიზნეს.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">CMake-ის ტერმინოლოგიით, <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> და <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> არის CMake ფუნქციების გარშემო მიახლოებითი შეფუთვები <code class="docutils literal notranslate"><span class="pre">target_link_libraries(...</span> <span class="pre">PUBLIC</span> <span class="pre">...)</span></code> და <code class="docutils literal notranslate"><span class="pre">target_link_libraries(...</span> <span class="pre">PRIVATE</span> <span class="pre">...)</span></code>.</p>
</div>
</div>
<div class="section" id="example-of-component-requirements">
<span id="example-component-requirements"></span><h3>კომპონენტი მოთხოვნების მაგალითი<a class="headerlink" href="build-system.html#example-of-component-requirements" title="Permalink to this headline">¶</a></h3>
<p>წარმოიდგინეთ, რომ არსებობს <code class="docutils literal notranslate"><span class="pre">car</span></code> კომპონენტი , რომელიც იყენებს <code class="docutils literal notranslate"><span class="pre">engine</span></code> კომპონენტი , რომელიც იყენებს <code class="docutils literal notranslate"><span class="pre">spark_plug</span></code> კომპონენტი :</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- autoProject/
             - CMakeLists.txt
             - components/ - car/ - CMakeLists.txt
                                     - car.c
                                     - car.h
                           - engine/ - CMakeLists.txt
                                     - engine.c
                                     - include/ - engine.h
                           - spark_plug/  - CMakeLists.txt
                                          - plug.c
                                          - plug.h
</pre></div>
</div>
<div class="section" id="car-component">
<h4>ვაგონის კომპონენტი<a class="headerlink" href="build-system.html#car-component" title="Permalink to this headline">¶</a></h4>
<p>ის <code class="docutils literal notranslate"><span class="pre">car.h</span></code> სათაურის ფაილი არის საჯარო ინტერფეისი <code class="docutils literal notranslate"><span class="pre">car</span></code> კომპონენტი . ეს სათაური მოიცავს <code class="docutils literal notranslate"><span class="pre">engine.h</span></code> პირდაპირ იმიტომ, რომ ის იყენებს ამ სათაურის ზოგიერთ დეკლარაციას:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* car.h */</span>
<span class="cp">#include</span> <span class="cpf">"engine.h"</span><span class="cp"></span>

<span class="cp">#ifdef ENGINE_IS_HYBRID</span>
<span class="cp">#define CAR_MODEL "Hybrid"</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>და car.c მოიცავს <code class="docutils literal notranslate"><span class="pre">car.h</span></code> ასევე:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* car.c */</span>
<span class="cp">#include</span> <span class="cpf">"car.h"</span><span class="cp"></span>
</pre></div>
</div>
<p>ეს ნიშნავს, რომ <code class="docutils literal notranslate"><span class="pre">car/CMakeLists.txt</span></code> ფაილმა უნდა გამოაცხადოს, რომ <code class="docutils literal notranslate"><span class="pre">car</span></code> მოითხოვს <code class="docutils literal notranslate"><span class="pre">engine</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s2">"car.c"</span>
                  <span class="s">INCLUDE_DIRS</span> <span class="s2">"."</span>
                  <span class="s">REQUIRES</span> <span class="s">engine</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SRCS</span></code> იძლევა წყაროს ფაილების სიას <code class="docutils literal notranslate"><span class="pre">car</span></code> კომპონენტი .</li>
<li><code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> იძლევა ამ კომპონენტი საჯარო ჩართვის დირექტორიების სიას19. რადგან საჯარო ინტერფეისი არის <code class="docutils literal notranslate"><span class="pre">car.h</span></code>, დირექტორია, რომელიც შეიცავს <code class="docutils literal notranslate"><span class="pre">car.h</span></code> აქ არის ჩამოთვლილი.</li>
<li><code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> მოცემულია ამ კომპონენტი ის საჯარო ინტერფეისისთვის საჭირო კომპონენტი ების სია. რადგან <code class="docutils literal notranslate"><span class="pre">car.h</span></code> არის საჯარო სათაური და მოიცავს სათაურს <code class="docutils literal notranslate"><span class="pre">engine</span></code>, ჩვენ ვაერთიანებთ <code class="docutils literal notranslate"><span class="pre">engine</span></code> აქ. ეს უზრუნველყოფს, რომ ნებისმიერი სხვა კომპონენტი რომელიც მოიცავს <code class="docutils literal notranslate"><span class="pre">car.h</span></code> შეძლებს რეკურსიულად შეიტანოს საჭირო <code class="docutils literal notranslate"><span class="pre">engine.h</span></code> ასევე.</li>
</ul>
</div>
<div class="section" id="engine-component">
<h4>ძრავის კომპონენტი<a class="headerlink" href="build-system.html#engine-component" title="Permalink to this headline">¶</a></h4>
<p>ის <code class="docutils literal notranslate"><span class="pre">engine</span></code> კომპონენტი ასევე აქვს საჯარო სათაურის ფაილი <code class="docutils literal notranslate"><span class="pre">include/engine.h</span></code>, მაგრამ ეს სათაური უფრო მარტივია:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* engine.h */</span>
<span class="cp">#define ENGINE_IS_HYBRID</span>

<span class="kt">void</span> <span class="nf">engine_start</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>განხორციელება არის <code class="docutils literal notranslate"><span class="pre">engine.c</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* engine.c */</span>
<span class="cp">#include</span> <span class="cpf">"engine.h"</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">"spark_plug.h"</span><span class="cp"></span>

<span class="p">...</span>
</pre></div>
</div>
<p>ამ კომპონენტი , <code class="docutils literal notranslate"><span class="pre">engine</span></code> დამოკიდებულია <code class="docutils literal notranslate"><span class="pre">spark_plug</span></code> მაგრამ ეს კერძო დამოკიდებულებაა. <code class="docutils literal notranslate"><span class="pre">spark_plug.h</span></code> საჭიროა კომპილაცია <code class="docutils literal notranslate"><span class="pre">engine.c</span></code>, მაგრამ ჩართვა აუცილებელი არ არის <code class="docutils literal notranslate"><span class="pre">engine.h</span></code>.</p>
<p>ეს ნიშნავს, რომ <code class="docutils literal notranslate"><span class="pre">engine/CMakeLists.txt</span></code> ფაილის გამოყენება შესაძლებელია <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s2">"engine.c"</span>
                  <span class="s">INCLUDE_DIRS</span> <span class="s2">"include"</span>
                  <span class="s">PRIV_REQUIRES</span> <span class="s">spark_plug</span><span class="p">)</span>
</pre></div>
</div>
<p>შედეგად, წყაროს ფაილები <code class="docutils literal notranslate"><span class="pre">car</span></code> კომპონენტი არ სჭირდება <code class="docutils literal notranslate"><span class="pre">spark_plug</span></code> ჩართოს დირექტორიები, რომლებიც დამატებულია მათ კომპილაცია r ძიების გზაზე. ამან შეიძლება დააჩქაროს კომპილაცია და თავიდან აიცილოს კომპილაცია r ბრძანების ხაზების საჭიროზე გრძელი გახდომა.</p>
</div>
<div class="section" id="spark-plug-component">
<h4>სანთლის კომპონენტი<a class="headerlink" href="build-system.html#spark-plug-component" title="Permalink to this headline">¶</a></h4>
<p>ის <code class="docutils literal notranslate"><span class="pre">spark_plug</span></code> კომპონენტი სხვა არაფერზე არ არის დამოკიდებული. მას აქვს საჯარო სათაურის ფაილი. <code class="docutils literal notranslate"><span class="pre">spark_plug.h</span></code>, მაგრამ ეს არ მოიცავს სხვა კომპონენტი სათაურებს.</p>
<p>ეს ნიშნავს, რომ <code class="docutils literal notranslate"><span class="pre">spark_plug/CMakeLists.txt</span></code> ფაილს არაფერი სჭირდება <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> ან <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> პუნქტები:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s2">"spark_plug.c"</span>
                  <span class="s">INCLUDE_DIRS</span> <span class="s2">"."</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="source-file-include-directories">
<h3>წყაროს ფაილის ჩართვის დირექტორიები<a class="headerlink" href="build-system.html#source-file-include-directories" title="Permalink to this headline">¶</a></h3>
<p>თითოეული კომპონენტი ის საწყისი ფაილი არის კომპილაცია d, რომელიც მოიცავს შემდეგ გზებს, როგორც ეს მითითებულია გადაცემულ არგუმენტებში. <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">..</span>
                       <span class="s">INCLUDE_DIRS</span> <span class="s2">"include"</span>
                       <span class="s">PRIV_INCLUDE_DIRS</span> <span class="s2">"other"</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>მიმდინარე კომპონენტი სემესტრი <code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> და <code class="docutils literal notranslate"><span class="pre">PRIV_INCLUDE_DIRS</span></code>.</li>
<li>ის <code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> ეკუთვნის ყველა სხვა კომპონენტი , რომლებიც ჩამოთვლილია <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> და <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> პარამეტრები (ანუ ყველა მიმდინარე კომპონენტი ის საჯარო და კერძო დამოკიდებულება).</li>
<li>რეკურსიულად, ყველა <code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> იმ კომპონენტი ე სემესტრის <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> სიები (ანუ ამ კომპონენტი ის დამოკიდებულებების ყველა საჯარო დამოკიდებულება, რეკურსიულად გაფართოებული).</li>
</ul>
</div>
<div class="section" id="main-component-requirements">
<h3>ძირითადი კომპონენტი მოთხოვნები<a class="headerlink" href="build-system.html#main-component-requirements" title="Permalink to this headline">¶</a></h3>
<p>კომპონენტი დასახელდა <code class="docutils literal notranslate"><span class="pre">main</span></code> განსაკუთრებულია, რადგან ავტომატურად მოითხოვს ყველა სხვა კომპონენტი ს აწყობაში. ამიტომ მისი გავლა აუცილებელი არ არის. <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> ან <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> ამ კომპონენტი . იხ. <a class="reference internal" href="build-system.html#rename-main"><span class="std std-ref">მთავარი სახელის გადარქმევა</span></a> იმის აღსაწერად, თუ რა უნდა შეიცვალოს, თუ აღარ იყენებთ <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი .</p>
</div>
<div class="section" id="common-component-requirements">
<h3>კომპონენტი საერთო მოთხოვნები<a class="headerlink" href="build-system.html#common-component-requirements" title="Permalink to this headline">¶</a></h3>
<p>დუბლირების თავიდან ასაცილებლად, თითოეული კომპონენტი ავტომატურად მოითხოვს რამდენიმე „საერთო“ IDF კომპონენტი , მაშინაც კი, თუ ისინი აშკარად არ არის ნახსენები. ამ კომპონენტი სათაურების ჩართვა ყოველთვის შესაძლებელია.</p>
<p>გავრცელებული კომპონენტი სია ასეთია: freertos, newlib, heap, log, soc, esp_rom, esp_common, xtensa, cxx.</p>
</div>
<div class="section" id="including-components-in-the-build">
<h3>აწყობაში კომპონენტი ის ჩათვლით<a class="headerlink" href="build-system.html#including-components-in-the-build" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>ნაგულისხმევად, აწყობაში შედის ყველა კომპონენტი .</li>
<li>თუ დააყენებთ <code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code> ცვლადი თქვენი პროექტის მიერ უშუალოდ გამოყენებული კომპონენტი ების მინიმალურ სიამდე, მაშინ აწყობა გაფართოვდება და ასევე მოიცავს საჭირო კომპონენტი ებს. კომპონენტი ების სრული სია ასეთი იქნება:<ul>
<li>კომპონენტები, რომლებიც აშკარად არის ნახსენები <code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code>.</li>
<li>ეს კომპონენტი s-ის მოთხოვნები (რეკურსიულად შეფასებული).</li>
<li>„საერთო“ კომპონენტი , რომლებზეც ყველა კომპონენტი დამოკიდებულია.</li>
</ul>
</li>
<li>პარამეტრი <code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code> საჭირო კომპონენტი პერიოდის მინიმალურ სიამდე დამატებამ შეიძლება მნიშვნელოვნად შეამციროს კომპილაცია პერიოდი.</li>
</ul>
</div>
<div class="section" id="requirements-in-the-build-system-implementation">
<span id="component-requirements-implementation"></span><h3>მოთხოვნები სისტემის შექმნისას<a class="headerlink" href="build-system.html#requirements-in-the-build-system-implementation" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>CMake კონფიგურაციის პროცესის ძალიან ადრეულ ეტაპზე, სკრიპტი <code class="docutils literal notranslate"><span class="pre">expand_requirements.cmake</span></code> გაშვებულია. ეს სკრიპტი ახორციელებს კომპონენტი CMakeLists.txt ფაილების ნაწილობრივ შეფასებას და აგებს კომპონენტი მოთხოვნების გრაფიკს (ამ გრაფიკს შეიძლება ჰქონდეს ციკლები). გრაფიკი გამოიყენება ფაილის გენერირებისთვის. <code class="docutils literal notranslate"><span class="pre">component_depends.cmake</span></code> შექმნის დირექტორიაში.</li>
<li>შემდეგ CMake-ის მთავარი პროცესი მოიცავს ამ ფაილს და იყენებს მას, რათა განსაზღვროს კომპონენტი ის სია, რომელიც უნდა ჩაერთოს აწყობაში (შიდა <code class="docutils literal notranslate"><span class="pre">BUILD_COMPONENTS</span></code> ცვლადი). <code class="docutils literal notranslate"><span class="pre">BUILD_COMPONENTS</span></code> ცვლადი დალაგებულია ისე, რომ დამოკიდებულებები პირველ რიგში ჩამოთვლილია, თუმცა, რადგან კომპონენტი დამოკიდებულების გრაფიკს აქვს ციკლები, ამის გარანტირება შეუძლებელია ყველა კომპონენტი ისთვის. თანმიმდევრობა უნდა იყოს დეტერმინისტული, კომპონენტი ებისა და კომპონენტი დამოკიდებულებების ერთი და იგივე ნაკრების გათვალისწინებით.</li>
<li>ღირებულება <code class="docutils literal notranslate"><span class="pre">BUILD_COMPONENTS</span></code> CMake-ის მიერ რეგისტრირებულია, როგორც „კომპონენტების სახელები:“</li>
<li>შემდეგ კონფიგურაცია ფასდება აწყობაში შემავალი კომპონენტი ისთვის.</li>
<li>თითოეული კომპონენტი ჩვეულებრივ შედის ბილდში და CMakeLists.txt ფაილი ხელახლა ფასდება კომპონენტი ბიბლიოთეკების ბილდში დასამატებლად.</li>
</ul>
<div class="section" id="component-dependency-order">
<h4>კომპონენტის დამოკიდებულების თანმიმდევრობა<a class="headerlink" href="build-system.html#component-dependency-order" title="Permalink to this headline">¶</a></h4>
<p>კომპონენტი 19-ის თანმიმდევრობა <code class="docutils literal notranslate"><span class="pre">BUILD_COMPONENTS</span></code> ცვლადი განსაზღვრავს სხვა შეკვეთებს შექმნის დროს:</p>
<ul class="simple">
<li>შეუკვეთეთ ეს <a class="reference internal" href="build-system.html#project-include-cmake"><span class="std std-ref">project_include.cmake</span></a> ფაილები შედის პროექტში.</li>
<li>შეუკვეთეთ, რომ კომპილაციისთვის გენერირებული იყოს სათაურის ბილიკების სია (მეშვეობით <code class="docutils literal notranslate"><span class="pre">-I</span></code> არგუმენტი). (გაითვალისწინეთ, რომ მოცემული კომპონენტი ის საწყისი ფაილებისთვის, კომპილაცია r-ს მხოლოდ ამ კომპონენტი ის დამოკიდებულების სათაურის გზები გადაეცემა.)</li>
</ul>
</div>
</div>
</div>
<div class="section" id="overriding-parts-of-the-project">
<h2>პროექტის გადამწყვეტი ნაწილები<a class="headerlink" href="build-system.html#overriding-parts-of-the-project" title="Permalink to this headline">¶</a></h2>
<div class="section" id="project-include-cmake">
<span id="id4"></span><h3>project_include.cmake<a class="headerlink" href="build-system.html#project-include-cmake" title="Permalink to this headline">¶</a></h3>
<p>კომპონენტი ფაილების შეფასებამდე კომპონენტი რომელთა აწყობის მოთხოვნები უნდა შეფასდეს, შეგიძლიათ შექმნათ ფაილი სახელწოდებით <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> კომპონენტი დირექტორიაში. ეს CMake ფაილი შედის, როდესაც <code class="docutils literal notranslate"><span class="pre">project.cmake</span></code> მთელ პროექტს აფასებს.</p>
<p><code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილები გამოიყენება ESP-IDF ში, პროექტის მასშტაბით აწყობის ფუნქციების განსაზღვრისთვის, როგორიცაა <code class="docutils literal notranslate"><span class="pre">esptool.py</span></code> ბრძანების ხაზის არგუმენტები და <code class="docutils literal notranslate"><span class="pre">bootloader</span></code> „სპეციალური აპლიკაცია“.</p>
<p>კომპონენტი განსხვავებით <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილების ჩართვისას, <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> მიმდინარე წყაროს დირექტორია (<code class="docutils literal notranslate"><span class="pre">CMAKE_CURRENT_SOURCE_DIR</span></code> და სამუშაო დირექტორია) არის პროექტის დირექტორია. გამოიყენეთ ცვლადი <code class="docutils literal notranslate"><span class="pre">COMPONENT_DIR</span></code> კომპონენტი აბსოლუტური დირექტორიისთვის.</p>
<p>გაითვალისწინეთ, რომ <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> არ არის აუცილებელი კომპონენტი ყველაზე გავრცელებული გამოყენებისთვის - მაგალითად, პროექტში include დირექტორიების დასამატებლად, ან <code class="docutils literal notranslate"><span class="pre">LDFLAGS</span></code> საბოლოო დაკავშირების ეტაპამდე. ამ მნიშვნელობების მორგება შესაძლებელია <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> თავად ფაილი. იხილეთ <a class="reference internal" href="build-system.html#optional-project-variables">პროექტის არჩევითი ცვლადები</a> დეტალებისთვის.</p>
<p><code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილები შეტანილია მითითებული თანმიმდევრობით <code class="docutils literal notranslate"><span class="pre">BUILD_COMPONENTS</span></code> ცვლადი (როგორც CMake-ის მიერ არის ლოგირებული). ეს ნიშნავს, რომ კომპონენტი ის <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილი დაემატება მას შემდეგ, რაც ყველა მისი დამოკიდებულება იქნება. <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილები, თუ ორივე კომპონენტი არ არის დამოკიდებულების ციკლის ნაწილი. ეს მნიშვნელოვანია, თუ <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილი ეყრდნობა სხვა კომპონენტი დადგენილ ცვლადებს19. იხილეთ აგრეთვე <a class="reference internal" href="build-system.html#component-requirements-implementation"><span class="std std-ref">ზემოთ</span></a>.</p>
<p>დიდი სიფრთხილე გამოიჩინეთ ცვლადების ან მიზნების დაყენებისას <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილი. რადგან მნიშვნელობები შედის უმაღლესი დონის პროექტის CMake pass-ში, მათ შეუძლიათ გავლენა მოახდინონ ან დაარღვიონ ფუნქციონალობა ყველა კომპონენტი ში!</p>
</div>
<div class="section" id="kconfig-projbuild">
<h3>KConfig.projbuild<a class="headerlink" href="build-system.html#kconfig-projbuild" title="Permalink to this headline">¶</a></h3>
<p>ეს ეკვივალენტია <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ამისთვის <a class="reference internal" href="build-system.html#component-configuration"><span class="std std-ref">კომპონენტის კონფიგურაცია</span></a> KConfig ფაილები. თუ გსურთ კონფიგურაციის პარამეტრების ჩართვა menuconfig ის ზედა დონეზე, „კომპონენტის კონფიგურაციის“ ქვემენიუს ნაცვლად, მაშინ მათი განსაზღვრა შესაძლებელია KConfig.projbuild ფაილში, <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი.</p>
<p>ფრთხილად იყავით ამ ფაილში კონფიგურაციის მნიშვნელობების დამატებისას, რადგან ისინი მთელი პროექტის კონფიგურაცია განმავლობაში იქნება ჩართული. სადაც შესაძლებელია, ზოგადად უმჯობესია შექმნათ KConfig ფაილი. <a class="reference internal" href="build-system.html#component-configuration"><span class="std std-ref">კომპონენტის კონფიგურაცია</span></a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code> ფაილები გამოიყენება ESP-IDF ში, პროექტის მასშტაბით აწყობის ფუნქციების განსაზღვრისთვის, როგორიცაა <code class="docutils literal notranslate"><span class="pre">esptool.py</span></code> ბრძანების ხაზის არგუმენტები და <code class="docutils literal notranslate"><span class="pre">bootloader</span></code> „სპეციალური აპლიკაცია“.</p>
</div>
</div>
<div class="section" id="configuration-only-components">
<h2>მხოლოდ კონფიგურაციის კომპონენტები<a class="headerlink" href="build-system.html#configuration-only-components" title="Permalink to this headline">¶</a></h2>
<p>სპეციალური კომპონენტი , რომელიც არ შეიცავს წყაროს ფაილებს, მხოლოდ <code class="docutils literal notranslate"><span class="pre">Kconfig.projbuild</span></code> და <code class="docutils literal notranslate"><span class="pre">KConfig</span></code>, შეიძლება ჰქონდეს ერთსტრიქონიანი <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილი, რომელიც ფუნქციას იძახებს <code class="docutils literal notranslate"><span class="pre">idf_component_register()</span></code> არგუმენტების მითითების გარეშე. ეს ფუნქცია პროექტის აწყობაში კომპონენტი მოიცავს, მაგრამ ბიბლიოთეკა არ შეიქმნება. <em>და</em> არცერთ ჩართვის გზას სათაურის ფაილები არ დაემატება.</p>
</div>
<div class="section" id="debugging-cmake">
<h2>CMake-ის გამართვა<a class="headerlink" href="build-system.html#debugging-cmake" title="Permalink to this headline">¶</a></h2>
<p>სრული დეტალებისთვის <a class="reference external" href="https://cmake.org">CMake</a> და CMake ბრძანებები, იხილეთ <a class="reference external" href="https://cmake.org/cmake/help/v3.5/index.html">CMake v3.5 დოკუმენტაცია</a>.</p>
<p>რამდენიმე რჩევა გამართვა ისთვის ESP-IDF CMake-ზე დაფუძნებული აწყობის სისტემისთვის:</p>
<ul class="simple">
<li>როდესაც CMake გაშვებულია, ის ბეჭდავს საკმაოდ დიდ დიაგნოსტიკურ ინფორმაციას, მათ შორის კომპონენტი ბმულების და კომპონენტი ბილიკების სიებს.</li>
<li>სირბილი <code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">-DDEBUG=1</span></code> IDF აწყობის სისტემიდან უფრო ვრცელი დიაგნოსტიკური შედეგის მიღებას გამოიწვევს.</li>
<li>სირბილი <code class="docutils literal notranslate"><span class="pre">cmake</span></code> -თან ერთად <code class="docutils literal notranslate"><span class="pre">--trace</span></code> ან <code class="docutils literal notranslate"><span class="pre">--trace-expand</span></code> პარამეტრები მოგაწვდით უამრავ ინფორმაციას კონტროლის ნაკადის შესახებ. იხილეთ <a class="reference external" href="https://cmake.org/cmake/help/v3.5/manual/cmake.1.html#options">cmake ბრძანების ხაზის დოკუმენტაცია</a>.</li>
</ul>
<p>პროექტის CMakeLists ფაილიდან ჩართვისას, <code class="docutils literal notranslate"><span class="pre">project.cmake</span></code> ფაილი განსაზღვრავს რამდენიმე სასარგებლო მოდულს და გლობალურ ცვლადს და შემდეგ აწესებს <code class="docutils literal notranslate"><span class="pre">IDF_PATH</span></code> თუ ის სისტემურ გარემოში არ იყო დაყენებული.</p>
<p>ის ასევე განსაზღვრავს ჩაშენებული ფუნქციის გადაფარულ მორგებულ ვერსიას. <a class="reference external" href="https://cmake.org">CMake</a> <code class="docutils literal notranslate"><span class="pre">project</span></code> ფუნქცია. ეს ფუნქცია გადაფარებულია ESP-IDF სპეციფიკური პროექტის ყველა ფუნქციონალის დასამატებლად.</p>
<div class="section" id="warning-on-undefined-variables">
<span id="warn-undefined-variables"></span><h3>გაფრთხილება განუსაზღვრელი ცვლადების შესახებ<a class="headerlink" href="build-system.html#warning-on-undefined-variables" title="Permalink to this headline">¶</a></h3>
<p>ნაგულისხმევად, <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> გადის <code class="docutils literal notranslate"><span class="pre">--warn-uninitialized</span></code> დროშის მონიშვნა <a class="reference external" href="https://cmake.org">CMake</a> ამგვარად, თუ აწყობაში მითითებული იქნება განუსაზღვრელი ცვლადი, ის გაფრთხილებას გამოაჩენს. ეს შეიძლება ძალიან სასარგებლო იყოს შეცდომებიანი CMake ფაილების მოსაძებნად.</p>
<p>თუ ეს ქცევა არ გსურთ, მისი გამორთვა შესაძლებელია გავლის გზით <code class="docutils literal notranslate"><span class="pre">--no-warnings</span></code> რომ <code class="docutils literal notranslate"><span class="pre">idf.py</span></code>.</p>
<p>დაათვალიერეთ <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/project.cmake">/tools/cmake/project.cmake</a> ფაილი და დამხმარე ფუნქციები <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/idf_functions.cmake">/ინსტრუმენტები/cmake/idf_functions.cmake</a> დამატებითი დეტალებისთვის.</p>
</div>
</div>
<div class="section" id="example-component-cmakelists">
<span id="gnu-make-to-cmake"></span><h2>მაგალითის კომპონენტი CMakeLists<a class="headerlink" href="build-system.html#example-component-cmakelists" title="Permalink to this headline">¶</a></h2>
<p>რადგან შექმნის გარემო ცდილობს დააყენოს გონივრული ნაგულისხმევი პარამეტრები, რომლებიც უმეტეს შემთხვევაში იმუშავებს, კომპონენტი <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> შეიძლება იყოს ძალიან პატარა ან თუნდაც ცარიელი (იხ. <a class="reference internal" href="build-system.html#minimal-component-cmakelists">მინიმალური კომპონენტების CMakeLists</a>თუმცა, გადამწყვეტი <a class="reference internal" href="build-system.html#component-variables">კომპონენტი ცვლადები</a> როგორც წესი, ეს საჭიროა გარკვეული ფუნქციონირებისთვის.</p>
<p>აქ მოცემულია კომპონენტი CMakeLists ფაილების უფრო მოწინავე მაგალითები.</p>
<div class="section" id="adding-conditional-configuration">
<h3>პირობითი კონფიგურაციის დამატება<a class="headerlink" href="build-system.html#adding-conditional-configuration" title="Permalink to this headline">¶</a></h3>
<p>კონფიგურაციის სისტემის გამოყენება შესაძლებელია ზოგიერთი ფაილის პირობითი კომპილაცია პროექტის კონფიგურაცია ში არჩეული პარამეტრების მიხედვით.</p>
<p><code class="docutils literal notranslate"><span class="pre">Kconfig</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>config FOO_ENABLE_BAR
    bool "Enable the BAR feature."
    help
        This enables the BAR feature of the FOO component.
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span> set(srcs "foo.c" "more_foo.c")

 if(CONFIG_FOO_ENABLE_BAR)
     list(APPEND srcs "bar.c")
 endif()

idf_component_register(SRCS "${srcs}"
                     ...)
</pre></div>
</div>
<p>ეს მაგალითი იყენებს CMake-ს <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/if.html">თუ</a> ფუნქცია და <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/list.html">სია დამატება</a> ფუნქცია.</p>
<p>ეს ასევე შეიძლება გამოყენებულ იქნას იმპლემენტაციის ასარჩევად ან გამოსართავად, შემდეგნაირად:</p>
<p><code class="docutils literal notranslate"><span class="pre">Kconfig</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>config ENABLE_LCD_OUTPUT
    bool "Enable LCD output."
    help
        Select this if your board has a LCD.

config ENABLE_LCD_CONSOLE
    bool "Output console text to LCD"
    depends on ENABLE_LCD_OUTPUT
    help
        Select this to output debugging output to the lcd

config ENABLE_LCD_PLOT
    bool "Output temperature plots to LCD"
    depends on ENABLE_LCD_OUTPUT
    help
        Select this to output temperature plots
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">if</span><span class="p">(</span><span class="s">CONFIG_ENABLE_LCD_OUTPUT</span><span class="p">)</span>
   <span class="nb">set</span><span class="p">(</span><span class="s">srcs</span> <span class="s">lcd-real.c</span> <span class="s">lcd-spi.c</span><span class="p">)</span>
<span class="nb">else</span><span class="p">()</span>
   <span class="nb">set</span><span class="p">(</span><span class="s">srcs</span> <span class="s">lcd-dummy.c</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="c"># We need font if either console or plot is enabled</span>
<span class="nb">if</span><span class="p">(</span><span class="s">CONFIG_ENABLE_LCD_CONSOLE</span> <span class="s">OR</span> <span class="s">CONFIG_ENABLE_LCD_PLOT</span><span class="p">)</span>
   <span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">srcs</span> <span class="s2">"font.c"</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>

<span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s2">"${srcs}"</span>
                    <span class="s">...</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="conditions-which-depend-on-the-target">
<h3>პირობები, რომლებიც დამოკიდებულია მიზანზე<a class="headerlink" href="build-system.html#conditions-which-depend-on-the-target" title="Permalink to this headline">¶</a></h3>
<p>მიმდინარე სამიზნე ხელმისაწვდომია CMake ფაილებისთვის <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> ცვლადი.</p>
<p>გარდა ამისა, თუ სამიზნე <code class="docutils literal notranslate"><span class="pre">xyz</span></code> გამოიყენება (<code class="docutils literal notranslate"><span class="pre">IDF_TARGET=xyz</span></code>), შემდეგ Kconfig ცვლადი <code class="docutils literal notranslate"><span class="pre">CONFIG_IDF_TARGET_XYZ</span></code> დაყენდება.</p>
<p>გაითვალისწინეთ, რომ კომპონენტი დამოკიდებულებები შეიძლება დამოკიდებული იყოს <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> ცვლადზე, მაგრამ არა Kconfig ცვლადებზე. ასევე, Kconfig ცვლადების გამოყენება შეუძლებელია <code class="docutils literal notranslate"><span class="pre">include</span></code> CMake ფაილებში არსებული ინსტრუქციები, მაგრამ <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> შეიძლება გამოყენებულ იქნას ასეთ კონტექსტში.</p>
</div>
<div class="section" id="source-code-generation">
<h3>საწყისი კოდის გენერირება<a class="headerlink" href="build-system.html#source-code-generation" title="Permalink to this headline">¶</a></h3>
<p>ზოგიერთ კომპონენტი ფაილს ექნება სიტუაცია, როდესაც წყაროს ფაილი თავად კომპონენტი თან ერთად არ მოყვება, არამედ სხვა ფაილიდან უნდა გენერირდეს. დავუშვათ, ჩვენს კომპონენტი აქვს სათაურის ფაილი, რომელიც შედგება BMP ფაილის გადაკეთებული ბინარული მონაცემებისგან, რომლებიც გადაკეთებულია ჰიპოთეტური ინსტრუმენტის, სახელწოდებით bmp2h. სათაურის ფაილი შემდეგ შედის C წყაროს ფაილში, სახელწოდებით graphics_lib.c:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_custom_command</span><span class="p">(</span><span class="s">OUTPUT</span> <span class="s">logo.h</span>
     <span class="s">COMMAND</span> <span class="s">bmp2h</span> <span class="s">-i</span> <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span><span class="s">/logo.bmp</span> <span class="s">-o</span> <span class="s">log.h</span>
     <span class="s">DEPENDS</span> <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span><span class="s">/logo.bmp</span>
     <span class="s">VERBATIM</span><span class="p">)</span>

<span class="nb">add_custom_target</span><span class="p">(</span><span class="s">logo</span> <span class="s">DEPENDS</span> <span class="s">logo.h</span><span class="p">)</span>
<span class="nb">add_dependencies</span><span class="p">(</span><span class="o">${</span><span class="nv">COMPONENT_LIB</span><span class="o">}</span> <span class="s">logo</span><span class="p">)</span>

<span class="nb">set_property</span><span class="p">(</span><span class="s">DIRECTORY</span> <span class="s2">"${COMPONENT_DIR}"</span> <span class="s">APPEND</span> <span class="s">PROPERTY</span>
     <span class="s">ADDITIONAL_MAKE_CLEAN_FILES</span> <span class="s">logo.h</span><span class="p">)</span>
</pre></div>
</div>
<p>ეს პასუხი ადაპტირებულია <a class="reference external" href="https://cmake.org/Wiki/CMake_FAQ#How_can_I_generate_a_source_file_during_the_build.3F">CMake-ის ხშირად დასმული კითხვების ჩანაწერი</a>, რომელიც შეიცავს სხვა მაგალითებს, რომლებიც ასევე იმუშავებს ESP-IDF ბილდებთან.</p>
<p>ამ მაგალითში, logo.h გენერირდება მიმდინარე დირექტორიაში (build დირექტორია), ხოლო logo.bmp მოყვება კომპონენტი ს და მდებარეობს კომპონენტი გზაში. რადგან logo.h არის გენერირებული ფაილი, ის უნდა გაიწმინდოს პროექტის გასუფთავებისას. ამ მიზეზით, ის ემატება <a class="reference external" href="https://cmake.org/cmake/help/v3.5/prop_dir/ADDITIONAL_MAKE_CLEAN_FILES.html">დამატებითი ფაილების გასუფთავება</a> ქონება.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">თუ ფაილებს პროექტის CMakeLists.txt ფაილის ნაწილად ქმნით და არა კომპონენტი CMakeLists.txt ფაილის, მაშინ გამოიყენეთ build თვისება. <code class="docutils literal notranslate"><span class="pre">PROJECT_DIR</span></code> ნაცვლად <code class="docutils literal notranslate"><span class="pre">${COMPONENT_DIR}</span></code> და <code class="docutils literal notranslate"><span class="pre">${PROJECT_NAME}.elf</span></code> ნაცვლად <code class="docutils literal notranslate"><span class="pre">${COMPONENT_LIB}</span></code>.)</p>
</div>
<p>თუ სხვა კომპონენტი 19 წყაროს ფაილი შედის <code class="docutils literal notranslate"><span class="pre">logo.h</span></code>, შემდეგ <code class="docutils literal notranslate"><span class="pre">add_dependencies</span></code> ორ კომპონენტი ს შორის დამოკიდებულების დასამატებლად საჭირო იქნებოდა გამოძახება, რათა უზრუნველყოფილი ყოფილიყო კომპონენტი ის საწყისი ფაილების ყოველთვის სწორი თანმიმდევრობით კომპილაცია d განთავსება.</p>
</div>
<div class="section" id="embedding-binary-data">
<span id="cmake-embed-data"></span><h3>ორობითი მონაცემების ჩასმა<a class="headerlink" href="build-system.html#embedding-binary-data" title="Permalink to this headline">¶</a></h3>
<p>ზოგჯერ გაქვთ ფაილი, რომელიც შეიცავს ორობით ან ტექსტურ მონაცემებს, რომელთა გამოყენებაც გსურთ თქვენი კომპონენტი ისთვის, მაგრამ არ გსურთ ფაილის C წყაროს სახით გადაფორმატება.</p>
<p>შეგიძლიათ მიუთითოთ არგუმენტი <code class="docutils literal notranslate"><span class="pre">EMBED_FILES</span></code> კომპონენტი რეგისტრაციაში, ჩასასმელი ფაილებისთვის სივრცით გამოყოფილი სახელების მიცემა:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">...</span>
                       <span class="s">EMBED_FILES</span> <span class="s">server_root_cert.der</span><span class="p">)</span>
</pre></div>
</div>
<p>ან თუ ფაილი სტრიქონია, შეგიძლიათ გამოიყენოთ ცვლადი <code class="docutils literal notranslate"><span class="pre">EMBED_TXTFILES</span></code>ეს ტექსტური ფაილის შინაარსს ნულოვანი ტერმინალით დასრულებულ სტრიქონად ჩასთავსებს:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">...</span>
                       <span class="s">EMBED_TXTFILES</span> <span class="s">server_root_cert.pem</span><span class="p">)</span>
</pre></div>
</div>
<p>ფაილის შინაარსი დაემატება ფლეშ მეხსიერება ის .rodata განყოფილებას და ხელმისაწვდომია შემდეგი სიმბოლოების სახელწოდებით:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">server_root_cert_pem_start</span><span class="p">[]</span> <span class="k">asm</span><span class="p">(</span><span class="s">"_binary_server_root_cert_pem_start"</span><span class="p">);</span>
<span class="k">extern</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">server_root_cert_pem_end</span><span class="p">[]</span>   <span class="k">asm</span><span class="p">(</span><span class="s">"_binary_server_root_cert_pem_end"</span><span class="p">);</span>
</pre></div>
</div>
<p>სახელები გენერირდება ფაილის სრული სახელიდან, როგორც ეს მოცემულია <code class="docutils literal notranslate"><span class="pre">EMBED_FILES</span></code>სიმბოლოები /, . და ა.შ. ჩანაცვლებულია ქვედახაზებით. სიმბოლოს სახელში _binary პრეფიქსი დამატებულია objcopy-ის მიერ და იგივეა როგორც ტექსტური, ასევე ორობითი ფაილებისთვის.</p>
<p>პროექტში ფაილის ჩასადებად, კომპონენტი ის ნაცვლად, შეგიძლიათ გამოიძახოთ ფუნქცია <code class="docutils literal notranslate"><span class="pre">target_add_binary_data</span></code> ასე:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">target_add_binary_data</span><span class="p">(</span><span class="s">myproject.elf</span> <span class="s2">"main/data.bin"</span> <span class="s">TEXT</span><span class="p">)</span>
</pre></div>
</div>
<p>მოათავსეთ ეს ხაზი შემდეგ <code class="docutils literal notranslate"><span class="pre">project()</span></code> ხაზი თქვენი პროექტის CMakeLists.txt ფაილში. შეცვალეთ <code class="docutils literal notranslate"><span class="pre">myproject.elf</span></code> თქვენი პროექტის სახელწოდებით. საბოლოო არგუმენტი შეიძლება იყოს <code class="docutils literal notranslate"><span class="pre">TEXT</span></code> ნულოვანი ტერმინებით დამთავრებული სტრიქონის ჩასადებად, ან <code class="docutils literal notranslate"><span class="pre">BINARY</span></code> კონტენტის ისე ჩასართავად, როგორც არის.</p>
<p>ამ ტექნიკის გამოყენების მაგალითისთვის იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/protocols/https_request">პროტოკოლები/https_მოთხოვნა</a> - სერტიფიკატის ფაილის შიგთავსი იტვირთება ტექსტური .pem ფაილიდან კომპილაცია დროს.</p>
</div>
<div class="section" id="code-and-data-placements">
<h3>კოდისა და მონაცემების განთავსება<a class="headerlink" href="build-system.html#code-and-data-placements" title="Permalink to this headline">¶</a></h3>
<p>ESP-IDF აქვს ფუნქცია, რომელსაც ლინკერის სკრიპტის გენერირება ეწოდება, რომელიც კომპონენტი ს საშუალებას აძლევს ლინკერის ფრაგმენტების ფაილების მეშვეობით განსაზღვროს, თუ სად განთავსდება მისი კოდი და მონაცემები მეხსიერებაში. ეს ფაილები მუშავდება შექმნის სისტემის მიერ და გამოიყენება აპლიკაციის ბინარული ფაილის დასაკავშირებლად გამოყენებული ლინკერის სკრიპტის გასაძლიერებლად. იხილეთ <a class="reference internal" href="linker-script-generation.html"><span class="doc">ლინკერის სკრიპტის გენერირება</span></a> სწრაფი დაწყების სახელმძღვანელოსთვის, ასევე მექანიზმის დეტალური განხილვისთვის.</p>
</div>
<div class="section" id="fully-overriding-the-component-build-process">
<span id="component-build-full-override"></span><h3>კომპონენტის შექმნის პროცესის სრულად უგულებელყოფა<a class="headerlink" href="build-system.html#fully-overriding-the-component-build-process" title="Permalink to this headline">¶</a></h3>
<p>ცხადია, არსებობს შემთხვევები, როდესაც ყველა ეს რეცეპტი არასაკმარისია გარკვეული კომპონენტი ისთვის, მაგალითად, როდესაც კომპონენტი ძირითადად წარმოადგენს სხვა მესამე მხარის კომპონენტი შემოხვევას, რომელიც თავდაპირველად არ იყო განკუთვნილი კომპილაცია d-სთვის ამ აწყობის სისტემაში. ამ შემთხვევაში, შესაძლებელია ESP-IDF აწყობის სისტემის მთლიანად უარყოფა CMake ფუნქციის გამოყენებით, რომელსაც ეწოდება <a class="reference external" href="https://cmake.org/cmake/help/v3.5/module/ExternalProject.html">გარე პროექტი</a>მაგალითი კომპონენტი CMakeLists:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># External build process for quirc, runs in source dir and</span>
<span class="c"># produces libquirc.a</span>
<span class="nb">externalproject_add</span><span class="p">(</span><span class="s">quirc_build</span>
    <span class="s">PREFIX</span> <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span>
    <span class="s">SOURCE_DIR</span> <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span><span class="s">/quirc</span>
    <span class="s">CONFIGURE_COMMAND</span> <span class="s2">""</span>
    <span class="s">BUILD_IN_SOURCE</span> <span class="s">1</span>
    <span class="s">BUILD_COMMAND</span> <span class="s">make</span> <span class="s">CC=</span><span class="o">${</span><span class="nv">CMAKE_C_COMPILER</span><span class="o">}</span> <span class="s">libquirc.a</span>
    <span class="s">INSTALL_COMMAND</span> <span class="s2">""</span>
    <span class="p">)</span>

 <span class="c"># Add libquirc.a to the build process</span>
 <span class="c">#</span>
 <span class="nb">add_library</span><span class="p">(</span><span class="s">quirc</span> <span class="s">STATIC</span> <span class="s">IMPORTED</span> <span class="s">GLOBAL</span><span class="p">)</span>
 <span class="nb">add_dependencies</span><span class="p">(</span><span class="s">quirc</span> <span class="s">quirc_build</span><span class="p">)</span>

 <span class="nb">set_target_properties</span><span class="p">(</span><span class="s">quirc</span> <span class="s">PROPERTIES</span> <span class="s">IMPORTED_LOCATION</span>
      <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span><span class="s">/quirc/libquirc.a</span><span class="p">)</span>
 <span class="nb">set_target_properties</span><span class="p">(</span><span class="s">quirc</span> <span class="s">PROPERTIES</span> <span class="s">INTERFACE_INCLUDE_DIRECTORIES</span>
      <span class="o">${</span><span class="nv">COMPONENT_DIR</span><span class="o">}</span><span class="s">/quirc/lib</span><span class="p">)</span>

 <span class="nb">set_directory_properties</span><span class="p">(</span> <span class="s">PROPERTIES</span> <span class="s">ADDITIONAL_MAKE_CLEAN_FILES</span>
      <span class="s2">"${COMPONENT_DIR}/quirc/libquirc.a"</span><span class="p">)</span>
</pre></div>
</div>
<p>(ზემოთ მოცემული CMakeLists.txt ფაილის გამოყენება შესაძლებელია კომპონენტი შესაქმნელად, სახელწოდებით <code class="docutils literal notranslate"><span class="pre">quirc</span></code> რომელიც აშენებს <a class="reference external" href="https://github.com/dlbeer/quirc">უცნაური</a> პროექტი საკუთარი Makefile-ის გამოყენებით.)</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">externalproject_add</span></code> განსაზღვრავს გარე აწყობის სისტემას.<ul>
<li><code class="docutils literal notranslate"><span class="pre">SOURCE_DIR</span></code>, <code class="docutils literal notranslate"><span class="pre">CONFIGURE_COMMAND</span></code>, <code class="docutils literal notranslate"><span class="pre">BUILD_COMMAND</span></code> და <code class="docutils literal notranslate"><span class="pre">INSTALL_COMMAND</span></code> ყოველთვის უნდა იყოს დაყენებული. <code class="docutils literal notranslate"><span class="pre">CONFIGURE_COMMAND</span></code> შეიძლება დაყენდეს ცარიელ სტრიქონად, თუ შექმნის სისტემას არ აქვს „კონფიგურაციის“ ნაბიჯი. <code class="docutils literal notranslate"><span class="pre">INSTALL_COMMAND</span></code> ESP-IDF აწყობისთვის, როგორც წესი, ცარიელი იქნება.</li>
<li>პარამეტრი <code class="docutils literal notranslate"><span class="pre">BUILD_IN_SOURCE</span></code> ნიშნავს, რომ შექმნის დირექტორია იგივეა, რაც წყაროს დირექტორია. წინააღმდეგ შემთხვევაში, შეგიძლიათ დააყენოთ <code class="docutils literal notranslate"><span class="pre">BUILD_DIR</span></code>.</li>
<li>გაიარეთ კონსულტაცია <a class="reference external" href="https://cmake.org/cmake/help/v3.5/module/ExternalProject.html">გარე პროექტი</a> დოკუმენტაცია დამატებითი დეტალებისთვის <code class="docutils literal notranslate"><span class="pre">externalproject_add()</span></code></li>
</ul>
</li>
<li>ბრძანებების მეორე ნაკრები ამატებს ბიბლიოთეკის სამიზნეს, რომელიც მიუთითებს გარე სისტემის მიერ შექმნილ „იმპორტირებულ“ ბიბლიოთეკის ფაილზე. include დირექტორიების დასამატებლად და CMake-სთვის ამ ფაილის მდებარეობის მითითებისთვის საჭიროა რამდენიმე პარამეტრის დაყენება.</li>
<li>და ბოლოს, გენერირებული ბიბლიოთეკა დაემატება <a class="reference external" href="https://cmake.org/cmake/help/v3.5/prop_dir/ADDITIONAL_MAKE_CLEAN_FILES.html">დამატებითი ფაილების გასუფთავება</a>ეს ნიშნავს <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> წაშლის ამ ბიბლიოთეკას. (გაითვალისწინეთ, რომ აწყობიდან სხვა ობიექტის ფაილები არ წაიშლება.)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">PSRAM-ით გარე აწყობის პროცესის გამოყენებისას, გახსოვდეთ, რომ დაამატოთ <code class="docutils literal notranslate"><span class="pre">-mfix-esp32-psram-cache-issue</span></code> C კომპილაცია r არგუმენტებისკენ. იხ. <a class="reference internal" href="../api-reference/kconfig.html#config-spiram-cache-workaround"><span class="std std-ref">CONFIG_SPIRAM_CACHE_WORKAROUND</span></a> ამ დროშის დეტალებისთვის.</p>
</div>
<div class="section" id="externalproject-dependencies-clean-builds">
<span id="additional-make-clean-files-note"></span><h4>ExternalProject-ის დამოკიდებულებები, სუფთა აწყობები<a class="headerlink" href="build-system.html#externalproject-dependencies-clean-builds" title="Permalink to this headline">¶</a></h4>
<p>CMake-ს გარე პროექტის აწყობასთან დაკავშირებით აქვს გარკვეული უჩვეულო ქცევა:</p>
<ul>
<li><p class="first"><a class="reference external" href="https://cmake.org/cmake/help/v3.5/prop_dir/ADDITIONAL_MAKE_CLEAN_FILES.html">დამატებითი ფაილების გასუფთავება</a> მუშაობს მხოლოდ მაშინ, როდესაც „make“ გამოიყენება როგორც build system. თუ <a class="reference external" href="https://ninja-build.org">ნინძა</a> ან გამოიყენება IDE აწყობის სისტემა, ის არ წაშლის ამ ფაილებს გაწმენდის დროს.</p>
</li>
<li><p class="first">თუმცა, <a class="reference external" href="https://cmake.org/cmake/help/v3.5/module/ExternalProject.html">გარე პროექტი</a> კონფიგურაცია და აწყობა ბრძანებები იქნება <em>ყოველთვის</em> გაწმენდის შემდეგ ხელახლა შესრულდეს.</p>
</li>
<li><p class="first">ამიტომ, გარე build ბრძანების კონფიგურაციისთვის არსებობს ორი ალტერნატიული რეკომენდებული გზა:</p>
<blockquote>
<div><ol class="arabic simple">
<li>გქონდეთ გარეგანი <code class="docutils literal notranslate"><span class="pre">BUILD_COMMAND</span></code> გაუშვით ყველა წყაროს სრული სუფთა კომპილაცია . build ბრძანება შესრულდება, თუ რომელიმე დამოკიდებულება გადაეცემა <code class="docutils literal notranslate"><span class="pre">externalproject_add</span></code> თან <code class="docutils literal notranslate"><span class="pre">DEPENDS</span></code> შეიცვალა, ან თუ ეს სუფთა ვერსიაა (ანუ რომელიმე <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">clean</span></code>, <code class="docutils literal notranslate"><span class="pre">ninja</span> <span class="pre">clean</span></code>, ან <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">clean</span></code> გაიქცა.)</li>
<li>გქონდეთ გარეგანი <code class="docutils literal notranslate"><span class="pre">BUILD_COMMAND</span></code> იყოს ინკრემენტული აწყობის ბრძანება. გადაეცით პარამეტრი <code class="docutils literal notranslate"><span class="pre">BUILD_ALWAYS</span> <span class="pre">1</span></code> რომ <code class="docutils literal notranslate"><span class="pre">externalproject_add</span></code>ეს ნიშნავს, რომ გარე პროექტი აშენდება ყოველ ჯერზე, როდესაც აწყობა გაშვებულია, დამოკიდებულებების მიუხედავად. ეს მხოლოდ იმ შემთხვევაშია რეკომენდებული, თუ გარე პროექტს აქვს სწორი ინკრემენტული აწყობის ქცევა და მისი გაშვება დიდ დროს არ მოითხოვს.</li>
</ol>
</div></blockquote>
</li>
</ul>
<p>გარე პროექტის შესაქმნელად ამ მიდგომებიდან საუკეთესო დამოკიდებული იქნება თავად პროექტზე, მის აგების სისტემაზე და იმაზე, თუ რამდენად დაგჭირდებათ პროექტის ხშირად ხელახლა კომპილაცია .</p>
</div>
</div>
</div>
<div class="section" id="custom-sdkconfig-defaults">
<span id="id5"></span><h2>sdkconfig-ის მორგებული ნაგულისხმევი პარამეტრები<a class="headerlink" href="build-system.html#custom-sdkconfig-defaults" title="Permalink to this headline">¶</a></h2>
<p>მაგალითად, პროექტების ან სხვა პროექტების შემთხვევაში, სადაც არ გსურთ sdkconfig-ის სრული კონფიგურაციის მითითება, მაგრამ გსურთ ESP-IDF ნაგულისხმევი პარამეტრებიდან ზოგიერთი ძირითადი მნიშვნელობის გადაფარვა, შესაძლებელია ფაილის შექმნა. <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults</span></code> პროექტის დირექტორიაში. ეს ფაილი გამოყენებული იქნება ახალი კონფიგურაციის ნულიდან შექმნისას ან როდესაც რაიმე ახალი კონფიგურაციის მნიშვნელობა ჯერ არ არის დაყენებული <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> ფაილი.</p>
<p>ამ ფაილის სახელის გადასაწერად ან მრავალი ფაილის მითითებისთვის, დააყენეთ <code class="docutils literal notranslate"><span class="pre">SDKCONFIG_DEFAULTS</span></code> გარემოს ცვლადი ან ნაკრები <code class="docutils literal notranslate"><span class="pre">SDKCONFIG_DEFAULTS</span></code> ზედა დონის CMakeLists.txt ფაილში. თუ რამდენიმე ფაილს მიუთითებთ, სიის გამყოფად გამოიყენეთ წერტილ-მძიმე. ფაილების სახელები, რომლებიც სრული ბილიკებით არ არის მითითებული, მიმდინარე პროექტთან მიმართებაში გადაწყდება.</p>
<div class="section" id="target-dependent-sdkconfig-defaults">
<h3>სამიზნეზე დამოკიდებული sdkconfig-ის ნაგულისხმევი პარამეტრები<a class="headerlink" href="build-system.html#target-dependent-sdkconfig-defaults" title="Permalink to this headline">¶</a></h3>
<p>გარდა ამისა <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults</span></code> ფაილიდან, აწყობის სისტემა ასევე ჩატვირთავს ნაგულისხმევ პარამეტრებს <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults.TARGET_NAME</span></code> ფაილი, სადაც <code class="docutils literal notranslate"><span class="pre">TARGET_NAME</span></code> არის ღირებულება <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code>მაგალითად, ამისთვის <code class="docutils literal notranslate"><span class="pre">esp32</span></code> სამიზნე, ნაგულისხმევი პარამეტრები აღებული იქნება <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults</span></code> ჯერ და შემდეგ, <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults.esp32</span></code>.</p>
<p>თუ <code class="docutils literal notranslate"><span class="pre">SDKCONFIG_DEFAULTS</span></code> გამოიყენება ნაგულისხმევი ფაილის/ფაილების სახელის გადასაწერად, სამიზნე სპეციფიკური ნაგულისხმევი ფაილის სახელი მიღებული იქნება <code class="docutils literal notranslate"><span class="pre">SDKCONFIG_DEFAULTS</span></code> მნიშვნელობა/მნიშვნელობები ზემოთ მოცემული წესის გამოყენებით.</p>
</div>
</div>
<div class="section" id="flash-arguments">
<h2>ფლეშ არგუმენტები<a class="headerlink" href="build-system.html#flash-arguments" title="Permalink to this headline">¶</a></h2>
<p>არსებობს რამდენიმე სცენარი, როდესაც გვსურს სამიზნე დაფაზე ფლეშ მეხსიერება გამოყენება IDF-ის გარეშე. ამ შემთხვევაში გვინდა აწყობილი ბინარული ფაილების, esptool.py და esptool ფლეშ მეხსიერება არგუმენტების შენახვა. ბინარული ფაილების და esptool.py ფაილების შესანახად სკრიპტის დაწერა მარტივია.</p>
<p>პროექტის შექმნის გაშვების შემდეგ, შექმნის დირექტორია შეიცავს ორობით გამომავალ ფაილებს (<code class="docutils literal notranslate"><span class="pre">.bin</span></code> პროექტისთვის ფაილები) და ასევე შემდეგი ფლეშ მეხსიერება ფაილები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">flash_project_args</span></code> შეიცავს არგუმენტებს მთელი პროექტის ფლეშ მეხსიერება ისთვის (app, ჩამტვირთავი , დანაყოფების ცხრილი , PHY მონაცემები, თუ ეს კონფიგურირებულია).</li>
<li><code class="docutils literal notranslate"><span class="pre">flash_app_args</span></code> შეიცავს არგუმენტებს მხოლოდ ფლეშ მეხსიერება ისთვის, აპლიკაცია.</li>
<li><code class="docutils literal notranslate"><span class="pre">flash_bootloader_args</span></code> შეიცავს მხოლოდ ფლეშ მეხსიერება არგუმენტებს, ჩამტვირთავი .</li>
</ul>
<p>შეგიძლიათ გადასცეთ ამ ფლეშ მეხსიერება er არგუმენტის ფაილებიდან ნებისმიერი <code class="docutils literal notranslate"><span class="pre">esptool.py</span></code> შემდეგნაირად:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python esptool.py --chip esp32 write_flash @build/flash_project_args
</pre></div>
</div>
<p>ალტერნატიულად, შესაძლებელია პარამეტრების ხელით კოპირება არგუმენტის ფაილიდან და მათი ბრძანების ხაზზე გადაცემა.</p>
<p>შექმნის დირექტორია ასევე შეიცავს გენერირებულ ფაილს <code class="docutils literal notranslate"><span class="pre">flasher_args.json</span></code> რომელიც შეიცავს პროექტის ფლეშ მეხსიერება ინფორმაციას JSON ფორმატში. ეს ფაილი გამოიყენება <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> და ასევე შეიძლება გამოყენებულ იქნას სხვა ინსტრუმენტებით, რომლებსაც სჭირდებათ ინფორმაცია პროექტის შექმნის შესახებ.</p>
</div>
<div class="section" id="building-the-bootloader">
<h2>Bootloader-ის შექმნა<a class="headerlink" href="build-system.html#building-the-bootloader" title="Permalink to this headline">¶</a></h2>
<p>ჩამტვირთავი აგებულია სტანდარტულად, როგორც ნაწილი <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">build</span></code>, ან შეიძლება აშენდეს დამოუკიდებლად <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">bootloader</span></code>.</p>
<p>ჩამტვირთავი არის სპეციალური „ქვეპროექტი“ შიგნით <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637//components/bootloader/subproject">/ კომპონენტი წმ/ ჩამტვირთავი /ქვეპროექტი</a>მას აქვს საკუთარი პროექტის CMakeLists.txt ფაილი და მთავარ პროექტში ცალკე .ELF და .BIN ფაილებს ქმნის. თუმცა, ის ძირითად პროექტს უზიარებს კონფიგურაციისა და შექმნის დირექტორიას.</p>
<p>ქვეპროექტი ჩასმულია, როგორც გარე პროექტი ზედა დონის პროექტიდან, ფაილის მეშვეობით. <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//components/bootloader/project_include.cmake">/ კომპონენტი s/ ჩამტვირთავი /project_include.cmake</a>მთავარი აწყობის პროცესი ქვეპროექტისთვის CMake-ს გაუშვებს, რაც მოიცავს კომპონენტი s-ის (main კომპონენტი s-ის ქვესიმრავლე) აღმოჩენას და ჩამტვირთავი სპეციფიკური კონფიგურაციის გენერირებას (რომელიც მიღებულია main-დან). <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code>).</p>
</div>
<div class="section" id="selecting-the-target">
<span id="selecting-idf-target"></span><h2>სამიზნის შერჩევა<a class="headerlink" href="build-system.html#selecting-the-target" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF მხარს უჭერს მრავალ სამიზნეს (ჩიპს). თითოეული ჩიპისთვის გამოყენებული იდენტიფიკატორებია შემდეგი:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">esp32</span></code> — ESP32-D0WD, ESP32-D2WD, ESP32-S0WD (ESP-SOLO), ESP32-U4WD, ESP32-PICO-D4-ისთვის</li>
<li><code class="docutils literal notranslate"><span class="pre">esp32s2</span></code>— ESP32-S2-ისთვის</li>
</ul>
<p>პროექტის შექმნამდე სამიზნის შესარჩევად გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">set-target</span> <span class="pre">&lt;target&gt;</span></code> ბრძანება, მაგალითად:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>idf.py set-target esp32s2
</pre></div>
</div>
<div class="admonition important">
<p class="first admonition-title">მნიშვნელოვანი</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">set-target</span></code> გაასუფთავებს შექმნის დირექტორიას და ხელახლა შექმნის <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> ფაილი ნულიდან. ძველი <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> ფაილი შეინახება როგორც <code class="docutils literal notranslate"><span class="pre">sdkconfig.old</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p>ქცევა <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">set-target</span></code> ბრძანება უდრის:</p>
<ol class="last arabic simple">
<li>build დირექტორიის გაწმენდა (<code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">fullclean</span></code>)</li>
<li>sdkconfig ფაილის წაშლა (<code class="docutils literal notranslate"><span class="pre">mv</span> <span class="pre">sdkconfig</span> <span class="pre">sdkconfig.old</span></code>)</li>
<li>პროექტის კონფიგურაცია ახალი სამიზნით (<code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">-DIDF_TARGET=esp32</span> <span class="pre">reconfigure</span></code>)</li>
</ol>
</div>
<p>ასევე შესაძლებელია სასურველის გავლა <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> როგორც გარემოს ცვლადი (მაგ. <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">IDF_TARGET=esp32s2</span></code>) ან როგორც CMake ცვლადი (მაგ. <code class="docutils literal notranslate"><span class="pre">-DIDF_TARGET=esp32s2</span></code> არგუმენტი CMake-ში ან idf.py-ში). გარემოს ცვლადის დაყენება მოსახერხებელი მეთოდია, თუ ძირითადად ერთი ტიპის ჩიპთან მუშაობთ.</p>
<p>_default_ მნიშვნელობის მითითებისთვის <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> მოცემული პროექტისთვის, დაამატეთ <code class="docutils literal notranslate"><span class="pre">CONFIG_IDF_TARGET</span></code> ღირებულება <code class="docutils literal notranslate"><span class="pre">sdkconfig.defaults</span></code>მაგალითად, <code class="docutils literal notranslate"><span class="pre">CONFIG_IDF_TARGET="esp32s2"</span></code>ეს მნიშვნელობა გამოყენებული იქნება, თუ <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> არ არის მითითებული სხვა მეთოდით: გარემოს ცვლადის, CMake ცვლადის ან <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">set-target</span></code> ბრძანება.</p>
<p>თუ სამიზნე არ არის დაყენებული ამ მეთოდებიდან არცერთით, შექმნის სისტემა ნაგულისხმევად დაყენდება <code class="docutils literal notranslate"><span class="pre">esp32</span></code> სამიზნე.</p>
</div>
<div class="section" id="writing-pure-cmake-components">
<h2>სუფთა CMake კომპონენტების წერა<a class="headerlink" href="build-system.html#writing-pure-cmake-components" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF აწყობის სისტემა CMake-ს „ კომპონენტი “-ის კონცეფციითა და დამხმარე ფუნქციებით „ახვევს“ ამ კომპონენტი ებს პროექტის აწყობაში ავტომატურად ინტეგრირებისთვის.</p>
<p>თუმცა, „ კომპონენტი s“-ის კონცეფციის ქვეშ სრული CMake-ის აწყობის სისტემაა. ასევე შესაძლებელია ისეთი კომპონენტი შექმნა, რომელიც სუფთა CMake-ია.</p>
<p>აქ მოცემულია კომპონენტი ისთვის სახელწოდებით „pure CMake“ კომპონენტი CMakeLists ფაილის მაგალითი. <code class="docutils literal notranslate"><span class="pre">json</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_library</span><span class="p">(</span><span class="s">json</span> <span class="s">STATIC</span>
<span class="s">cJSON/cJSON.c</span>
<span class="s">cJSON/cJSON_Utils.c</span><span class="p">)</span>

<span class="nb">target_include_directories</span><span class="p">(</span><span class="s">json</span> <span class="s">PUBLIC</span> <span class="s">cJSON</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>ეს სინამდვილეში IDF-ის ექვივალენტური განცხადებაა. <code class="docutils literal notranslate"><span class="pre">json</span></code> კომპონენტი <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//components/json/CMakeLists.txt">/ კომპონენტი s/json/CMakeLists.txt</a>.</li>
<li>ეს ფაილი საკმაოდ მარტივია, რადგან ბევრი საწყისი ფაილი არ არის. დიდი რაოდენობით ფაილების მქონე კომპონენტი ფაილებისთვის, ESP-IDF ის კომპონენტი ლოგიკის გლობალური ქცევა კომპონენტი CMakeLists სტილს უფრო ამარტივებს.)</li>
<li>როდესაც კომპონენტი დაამატებს ბიბლიოთეკის სამიზნეს კომპონენტი სახელით, ESP-IDF ის აწყობის სისტემა ავტომატურად დაამატებს მას აწყობაში, გამოავლენს public include დირექტორიებს და ა.შ. თუ კომპონენტი ს სურს ბიბლიოთეკის სამიზნის დამატება სხვა სახელით, დამოკიდებულებები უნდა დაემატოს ხელით CMake ბრძანებების მეშვეობით.</li>
</ul>
</div>
<div class="section" id="using-third-party-cmake-projects-with-components">
<h2>მესამე მხარის CMake პროექტების გამოყენება კომპონენტებთან ერთად<a class="headerlink" href="build-system.html#using-third-party-cmake-projects-with-components" title="Permalink to this headline">¶</a></h2>
<p>CMake გამოიყენება ღია კოდის C და C++ პროექტების დიდი რაოდენობით — კოდი, რომლის გამოყენებაც მომხმარებლებს შეუძლიათ თავიანთი აპლიკაციებისთვის. CMake-ის აწყობის სისტემის ერთ-ერთი უპირატესობა არის ამ მესამე მხარის პროექტების იმპორტის შესაძლებლობა, ზოგჯერ მოდიფიკაციის გარეშეც კი! ეს საშუალებას აძლევს მომხმარებლებს მიიღონ ისეთი ფუნქციონალი, რომელიც შესაძლოა ჯერ არ იყოს მოწოდებული კომპონენტი , ან გამოიყენონ სხვა ბიბლიოთეკა იმავე ფუნქციონალისთვის.</p>
<p>ჰიპოთეტური ბიბლიოთეკის შემთხვევაში, ბიბლიოთეკის იმპორტი შეიძლება ასე გამოიყურებოდეს <code class="docutils literal notranslate"><span class="pre">foo</span></code> გამოსაყენებლად <code class="docutils literal notranslate"><span class="pre">main</span></code> კომპონენტი :</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="c"># Register the component</span>
<span class="nb">idf_component_register</span><span class="p">(</span><span class="s">...</span><span class="p">)</span>

<span class="c"># Set values of hypothetical variables that control the build of `foo`</span>
<span class="nb">set</span><span class="p">(</span><span class="s">FOO_BUILD_STATIC</span> <span class="s">OFF</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">FOO_BUILD_TESTS</span> <span class="s">OFF</span><span class="p">)</span>

<span class="c"># Create and import the library targets</span>
<span class="nb">add_subdirectory</span><span class="p">(</span><span class="s">foo</span><span class="p">)</span>

<span class="c"># Publicly link `foo` to `main` component</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">main</span> <span class="s">PUBLIC</span> <span class="s">foo</span><span class="p">)</span>
</pre></div>
</div>
<p>რეალური მაგალითისთვის, გადახედეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/build_system/cmake/import_lib">build_system/cmake/import_lib</a>გაითვალისწინეთ, რომ ბიბლიოთეკის იმპორტისთვის საჭირო ქმედებები შეიძლება განსხვავდებოდეს. რეკომენდებულია ბიბლიოთეკის დოკუმენტაციის წაკითხვა სხვა პროექტებიდან მისი იმპორტის ინსტრუქციისთვის. ასევე სასარგებლო იქნება ბიბლიოთეკის CMakeLists.txt ფაილისა და მისი შექმნის სტრუქტურის შესწავლა.</p>
<p>ასევე შესაძლებელია მესამე მხარის ბიბლიოთეკის შეფუთვა კომპონენტი ამ გზით. მაგალითად, <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/components/mbedtls">mbedtls</a> კომპონენტი არის Espressif-ის ჩანგლის შესაფუთი <a class="reference external" href="https://github.com/ARMmbed/mbedtls">mbedtls</a>იხილეთ მისი <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/mbedtls/CMakeLists.txt">კომპონენტი CMakeLists.txt </a>.</p>
<p>CMake ცვლადი <code class="docutils literal notranslate"><span class="pre">ESP_PLATFORM</span></code> ESP-IDF აწყობის სისტემის გამოყენებისას მნიშვნელობა 1-ზეა დაყენებული. ტესტები, როგორიცაა <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(ESP_PLATFORM)</span></code> შეიძლება გამოყენებულ იქნას ზოგად CMake კოდში, თუ საჭიროა IDF-ისთვის სპეციფიკური ლოგიკა.</p>
<div class="section" id="using-esp-idf-components-from-external-libraries">
<h3>გარე ბიბლიოთეკებიდან ESP-IDF კომპონენტი ის გამოყენება<a class="headerlink" href="build-system.html#using-esp-idf-components-from-external-libraries" title="Permalink to this headline">¶</a></h3>
<p>ზემოთ მოყვანილი მაგალითი ვარაუდობს, რომ გარე ბიბლიოთეკა <code class="docutils literal notranslate"><span class="pre">foo`</span> <span class="pre">(or</span> <span class="pre">``tinyxml</span></code> იმ შემთხვევაში, თუ <code class="docutils literal notranslate"><span class="pre">import_lib</span></code> მაგალითად) არ საჭიროებს ESP-IDF API ის გამოყენებას, გარდა ჩვეულებრივი API ებისა, როგორიცაა libc, libstdc++ და ა.შ. თუ გარე ბიბლიოთეკას სჭირდება სხვა ESP-IDF კომპონენტი ის მიერ მოწოდებული API ის გამოყენება, ეს უნდა იყოს მითითებული გარე CMakeLists.txt ფაილში ბიბლიოთეკის სამიზნეზე დამოკიდებულების დამატებით. <code class="docutils literal notranslate"><span class="pre">idf::&lt;componentname&gt;</span></code>.</p>
<p>მაგალითად, <code class="docutils literal notranslate"><span class="pre">foo/CMakeLists.txt</span></code> ფაილი:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_library</span><span class="p">(</span><span class="s">foo</span> <span class="s">bar.c</span> <span class="s">fizz.cpp</span> <span class="s">buzz.cpp</span><span class="p">)</span>

<span class="nb">if</span><span class="p">(</span><span class="s">ESP_PLATFORM</span><span class="p">)</span>
  <span class="c"># On ESP-IDF, bar.c needs to include esp_spi_flash.h from the spi_flash component</span>
  <span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">foo</span> <span class="s">PRIVATE</span> <span class="s">idf::spi_flash</span><span class="p">)</span>
<span class="nb">endif</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="using-prebuilt-libraries-with-components">
<h2>წინასწარ აშენებული ბიბლიოთეკების გამოყენება კომპონენტებთან ერთად<a class="headerlink" href="build-system.html#using-prebuilt-libraries-with-components" title="Permalink to this headline">¶</a></h2>
<p>კიდევ ერთი შესაძლებლობაა, რომ თქვენ გაქვთ წინასწარ აშენებული სტატიკური ბიბლიოთეკა (<code class="docutils literal notranslate"><span class="pre">.a</span></code> ფაილი), რომელიც აგებულია სხვა აწყობის პროცესით.</p>
<p>ESP-IDF ის აწყობის სისტემა უზრუნველყოფს უტილიტარულ ფუნქციას <code class="docutils literal notranslate"><span class="pre">add_prebuilt_library</span></code> რათა მომხმარებლებმა შეძლონ წინასწარ აშენებული ბიბლიოთეკების იმპორტი და გამოყენება:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">add_prebuilt_library</span><span class="p">(</span><span class="s">target_name</span> <span class="s">lib_path</span> <span class="s">[REQUIRES</span> <span class="s">req1</span> <span class="s">req2</span> <span class="s">...]</span> <span class="s">[PRIV_REQUIRES</span> <span class="s">req1</span> <span class="s">req2</span> <span class="s">...]</span><span class="p">)</span>
</pre></div>
</div>
<p>სადაც:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">target_name</span></code>- სახელი, რომლის გამოყენებაც შესაძლებელია იმპორტირებული ბიბლიოთეკის მითითებისთვის, მაგალითად, სხვა სამიზნეებთან დაკავშირებისას</li>
<li><code class="docutils literal notranslate"><span class="pre">lib_path</span></code>- გზა წინასწარ აგებული ბიბლიოთეკისკენ; შეიძლება იყოს აბსოლუტური ან ფარდობითი გზა კომპონენტი დირექტორიისკენ</li>
</ul>
<p>არასავალდებულო არგუმენტები <code class="docutils literal notranslate"><span class="pre">REQUIRES</span></code> და <code class="docutils literal notranslate"><span class="pre">PRIV_REQUIRES</span></code> მიუთითეთ დამოკიდებულება სხვა კომპონენტი 19. მათ იგივე მნიშვნელობა აქვთ, რაც არგუმენტებს <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>.</p>
<p>გაითვალისწინეთ, რომ წინასწარ აგებული ბიბლიოთეკა უნდა ყოფილიყო კომპილაცია d იმავე სამიზნე ვერსიისთვის, როგორც მომხმარებელი პროექტი. წინასწარ აგებული ბიბლიოთეკის შესაბამისი კონფიგურაციაც უნდა ემთხვეოდეს. თუ ყურადღებას არ მიაქცევთ, ამ ორ ფაქტორს შეიძლება ხელი შეუწყოს აპლიკაციაში არსებული უმნიშვნელო შეცდომების წარმოქმნას.</p>
<p>მაგალითისთვის, გადახედეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/build_system/cmake/import_prebuilt">build_system/cmake/import_prebuilt</a>.</p>
</div>
<div class="section" id="using-esp-idf-in-custom-cmake-projects">
<h2>ESP-IDF გამოყენება CMake-ის პროექტებში<a class="headerlink" href="build-system.html#using-esp-idf-in-custom-cmake-projects" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF გთავაზობთ CMake პროექტის შაბლონს აპლიკაციის მარტივად შესაქმნელად. თუმცა, ზოგიერთ შემთხვევაში მომხმარებელს შეიძლება უკვე ჰქონდეს არსებული CMake პროექტი ან სურდეს საკუთარი CMake პროექტის შექმნა. ასეთ შემთხვევებში სასურველია IDF კომპონენტი ის გამოყენება ბიბლიოთეკების სახით, რომლებიც დაკავშირებული იქნება მომხმარებლის სამიზნე ფაილებთან (ბიბლიოთეკები/შესრულებადი ფაილები).</p>
<p>ამის გაკეთება შესაძლებელია -ის გამოყენებით <a class="reference internal" href="build-system.html#cmake-buildsystem-api"><span class="std std-ref">სისტემის შექმნის API s მოწოდებულია</span></a> მიერ <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/tools/cmake/idf.cmake">ინსტრუმენტები/cmake/idf.cmake</a>მაგალითად:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.5</span><span class="p">)</span>
<span class="nb">project</span><span class="p">(</span><span class="s">my_custom_app</span> <span class="s">C</span><span class="p">)</span>

<span class="c"># Include CMake file that provides ESP-IDF CMake build system APIs.</span>
<span class="nb">include</span><span class="p">(</span><span class="o">$ENV{</span><span class="nv">IDF_PATH</span><span class="o">}</span><span class="s">/tools/cmake/idf.cmake</span><span class="p">)</span>

<span class="c"># Include ESP-IDF components in the build, may be thought as an equivalent of</span>
<span class="c"># add_subdirectory() but with some additional procesing and magic for ESP-IDF build</span>
<span class="c"># specific build processes.</span>
<span class="nb">idf_build_process</span><span class="p">(</span><span class="s">esp32</span><span class="p">)</span>

<span class="c"># Create the project executable and plainly link the newlib component to it using</span>
<span class="c"># its alias, idf::newlib.</span>
<span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="o">}</span><span class="s">.elf</span> <span class="s">main.c</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="o">}</span><span class="s">.elf</span> <span class="s">idf::newlib</span><span class="p">)</span>

<span class="c"># Let the build system know what the project executable is to attach more targets, dependencies, etc.</span>
<span class="nb">idf_build_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="o">}</span><span class="s">.elf</span><span class="p">)</span>
</pre></div>
</div>
<p>მაგალითი <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/build_system/cmake/idf_as_lib">build_system/cmake/idf_as_lib</a> აჩვენებს აპლიკაციის შექმნას, რომელიც ექვივალენტურია <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/get-started/hello_world">აპლიკაცია „გამარჯობა მსოფლიო“ </a>
საკუთარი CMake პროექტის გამოყენებით.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">IDF-ის შექმნის სისტემას მხოლოდ მის მიერ აგებული საწყისი ფაილებისთვის კომპილაცია r ფლაგების დაყენება შეუძლია. როდესაც გარე CMakeLists.txt ფაილი გამოიყენება და PSRAM ჩართულია, არ დაგავიწყდეთ მისი დამატება. <code class="docutils literal notranslate"><span class="pre">-mfix-esp32-psram-cache-issue</span></code> C კომპილაცია r არგუმენტებისკენ. იხ. <a class="reference internal" href="../api-reference/kconfig.html#config-spiram-cache-workaround"><span class="std std-ref">CONFIG_SPIRAM_CACHE_WORKAROUND</span></a> ამ დროშის დეტალებისთვის.</p>
</div>
</div>
<div class="section" id="esp-idf-cmake-build-system-api">
<span id="cmake-buildsystem-api"></span><h2>ESP-IDF CMake Build System API<a class="headerlink" href="build-system.html#esp-idf-cmake-build-system-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="idf-build-commands">
<h3>idf-build-ბრძანებები<a class="headerlink" href="build-system.html#idf-build-commands" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_get_property(var property [GENERATOR_EXPRESSION])
</pre></div>
</div>
<p>მოძიება <a class="reference internal" href="build-system.html#cmake-build-properties"><span class="std std-ref">ქონების აშენება</span></a> <em>ქონება</em> და შეინახეთ იგი <em>ვარი</em> ხელმისაწვდომია მიმდინარე სფეროდან. დაზუსტება
<em>გენერატორის_ექსპრესია</em> მოიძიებს ამ თვისებისთვის გენერატორის გამოხატვის სტრიქონს, ფაქტობრივი მნიშვნელობის ნაცვლად, რომლის გამოყენებაც შესაძლებელია CMake ბრძანებებთან ერთად, რომლებიც მხარს უჭერენ გენერატორის გამოსახულებებს.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_set_property(property val [APPEND])
</pre></div>
</div>
<p>დააყენეთ <a class="reference internal" href="build-system.html#cmake-build-properties"><span class="std std-ref">ქონების აშენება</span></a> <em>ქონება</em> ღირებულებით <em>ვალი</em>. დაზუსტება <em>დამატება</em> მითითებულ მნიშვნელობას დაამატებს თვისების მიმდინარე მნიშვნელობას. თუ თვისება ადრე არ არსებობდა ან ამჟამად ცარიელია, მითითებული მნიშვნელობა ხდება პირველი ელემენტი/წევრი.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_component(component_dir)
</pre></div>
</div>
<p>დირექტორიის წარდგენა <em>კომპონენტი _dir</em> რომელიც შეიცავს კომპონენტი სისტემისთვის. ფარდობითი გზები გარდაიქმნება აბსოლუტურ გზებად მიმდინარე დირექტორიასთან მიმართებაში. ამ ბრძანების ყველა გამოძახება უნდა შესრულდეს მანამ, სანამ <cite>idf_build_process</cite>.</p>
<p>ეს ბრძანება არ იძლევა გარანტიას, რომ კომპონენტი დამუშავდება შექმნის დროს (იხ. <cite>COMPONENTS</cite> არგუმენტის აღწერა <cite>idf_build_process</cite>)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_process(target
                  [PROJECT_DIR project_dir]
                  [PROJECT_VER project_ver]
                  [PROJECT_NAME project_name]
                  [SDKCONFIG sdkconfig]
                  [SDKCONFIG_DEFAULTS sdkconfig_defaults]
                  [BUILD_DIR build_dir]
                  [COMPONENTS component1 component2 ...])
</pre></div>
</div>
<p>ასრულებს კულისებში მიმდინარე მაგიის ძირითად ნაწილს ESP-IDF და კომპონენტი ის ჩართვისთვის, როგორიცაა კომპონენტი კონფიგურაცია, ბიბლიოთეკების შექმნა, დამოკიდებულებების გაფართოება და გარჩევადობა. ამ ფუნქციებს შორის, მომხმარებლის პერსპექტივიდან, შესაძლოა ყველაზე მნიშვნელოვანი იყოს ბიბლიოთეკების შექმნა თითოეული კომპონენტი ის გამოძახებით. <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>ეს ბრძანება ქმნის ბიბლიოთეკებს თითოეული კომპონენტი ისთვის, რომლებზეც წვდომა შესაძლებელია idf:: ფორმის ფსევდონიმების გამოყენებით.<em>კომპონენტი _name</em>ეს ფსევდონიმები შეიძლება გამოყენებულ იქნას კომპონენტი ის მომხმარებლის საკუთარ სამიზნეებთან, ბიბლიოთეკებთან ან შესრულებად ფაილებთან დასაკავშირებლად.</p>
<p>ზარისთვის საჭიროა სამიზნე ჩიპის მითითება შემდეგნაირად: <em>სამიზნე</em> არგუმენტი. გამოძახების დამატებითი არგუმენტებია:</p>
<ul class="simple">
<li>PROJECT_DIR - პროექტის დირექტორია; ნაგულისხმევად CMAKE_SOURCE_DIR</li>
<li>PROJECT_NAME - პროექტის სახელი; ნაგულისხმევად CMAKE_PROJECT_NAME</li>
<li>PROJECT_VER - პროექტის ვერსია/რედაქტირება; ნაგულისხმევად „1“</li>
<li>SDK CONFIG - გენერირებული sdkconfig ფაილის გამომავალი გზა; ნაგულისხმევად არის PROJECT_DIR/sdkconfig ან CMAKE_SOURCE_DIR/sdkconfig, იმისდა მიხედვით, დაყენებულია თუ არა PROJECT_DIR.</li>
<li>SDK CONFIG_DEFAULTS - ფაილების სია, რომლებიც შეიცავს ნაგულისხმევ კონფიგურაციას აწყობაში გამოსაყენებლად (სია უნდა შეიცავდეს სრულ ბილიკებს); ნაგულისხმევად ცარიელია. თითოეული მნიშვნელობისთვის <em>ფაილის სახელი</em> სიაში, ფაილიდან კონფიგურაცია <em>ფაილის სახელი.მიზანი</em>, თუ ის არსებობს, ასევე იტვირთება.</li>
<li>BUILD_DIR - დირექტორია ESP-IDF აწყობასთან დაკავშირებული არტეფაქტების, როგორიცაა გენერირებული ბინარული ფაილები, ტექსტური ფაილები, კომპონენტი , განსათავსებლად; ნაგულისხმევად CMAKE_BINARY_DIR.</li>
<li>კომპონენტები - აირჩიეთ კომპონენტი დამუშავებისთვის აწყობის სისტემის მიერ ცნობილ კომპონენტი ებს შორის (დამატებულია <cite>idf_build_component</cite>). ეს არგუმენტი გამოიყენება აწყობის შესამცირებლად. სხვა კომპონენტი ავტომატურად ემატება, თუ ისინი საჭიროა დამოკიდებულების ჯაჭვში, ანუ ამ სიაში კომპონენტი ის საჯარო და კერძო მოთხოვნები ავტომატურად ემატება და, თავის მხრივ, ამ მოთხოვნების საჯარო და კერძო მოთხოვნები და ა.შ. თუ მითითებული არ არის, დამუშავდება აწყობის სისტემისთვის ცნობილი ყველა კომპონენტი .</li>
</ul>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_executable(executable)
</pre></div>
</div>
<p>მიუთითეთ შესრულებადი ფაილი <em>შესრულებადი</em> ESP-IDF build-ისთვის. ეს დამატებით სამიზნეებს ანიჭებს, როგორიცაა ფლეშ მეხსიერება ing-თან დაკავშირებული დამოკიდებულებები, დამატებითი ორობითი ფაილების გენერირება და ა.შ. უნდა გამოიძახოს შემდეგ. <code class="docutils literal notranslate"><span class="pre">idf_build_process</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_build_get_config(var config [GENERATOR_EXPRESSION])
</pre></div>
</div>
<p>მიიღეთ მითითებული კონფიგურაციის მნიშვნელობა. ისევე როგორც build თვისებების შემთხვევაში, მითითება
<em>გენერატორის_ექსპრესია</em> მიიღებს ამ კონფიგურაციისთვის გენერატორის გამოხატვის სტრიქონს, ფაქტობრივი მნიშვნელობის ნაცვლად, რომლის გამოყენებაც შესაძლებელია CMake ბრძანებებთან ერთად, რომლებიც მხარს უჭერენ გენერატორის გამოსახულებებს. ფაქტობრივი კონფიგურაციის მნიშვნელობები ცნობილია მხოლოდ გამოძახების შემდეგ. <cite>idf_build_process</cite>თუმცა.</p>
</div>
<div class="section" id="cmake-build-properties">
<span id="idf-build-properties"></span><h3>idf-build-properties<a class="headerlink" href="build-system.html#cmake-build-properties" title="Permalink to this headline">¶</a></h3>
<p>ეს არის თვისებები, რომლებიც აღწერს build-ს. build-ის თვისებების მნიშვნელობების მოძიება შესაძლებელია build ბრძანების გამოყენებით. <code class="docutils literal notranslate"><span class="pre">idf_build_get_property</span></code>მაგალითად, Python-ის ინტერპრეტატორის აწყობისთვის გამოსაყენებლად:</p>
</div>
<div class="section" id="idf-component-commands">
<h3>idf- კომპონენტი -ბრძანებები<a class="headerlink" href="build-system.html#idf-component-commands" title="Permalink to this headline">¶</a></h3>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_component_get_property(var component property [GENERATOR_EXPRESSION])
</pre></div>
</div>
<p>მითითებულის მოძიება <em>კომპონენტი</em>ს <a class="reference internal" href="build-system.html#cmake-component-properties"><span class="std std-ref">კომპონენტი ქონება</span></a>, <em>ქონება</em> და შეინახეთ იგი <em>ვარი</em> ხელმისაწვდომია მიმდინარე სფეროდან. დაზუსტება
<em>გენერატორის_ექსპრესია</em> მოიძიებს ამ თვისებისთვის გენერატორის გამოხატვის სტრიქონს, ფაქტობრივი მნიშვნელობის ნაცვლად, რომლის გამოყენებაც შესაძლებელია CMake ბრძანებებთან ერთად, რომლებიც მხარს უჭერენ გენერატორის გამოსახულებებს.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>idf_component_set_property(component property val [APPEND])
</pre></div>
</div>
<p>მითითებულის დაყენება <em>კომპონენტი</em>ს <a class="reference internal" href="build-system.html#cmake-component-properties"><span class="std std-ref">კომპონენტი ქონება</span></a>, <em>ქონება</em> ღირებულებით <em>ვალი</em>. დაზუსტება <em>დამატება</em> მითითებულ მნიშვნელობას დაამატებს თვისების მიმდინარე მნიშვნელობას. თუ თვისება ადრე არ არსებობდა ან ამჟამად ცარიელია, მითითებული მნიშვნელობა ხდება პირველი ელემენტი/წევრი.</p>
<div class="highlight-none notranslate" id="cmake-component-register"><div class="highlight"><pre><span></span>idf_component_register([[SRCS src1 src2 ...] | [[SRC_DIRS dir1 dir2 ...] [EXCLUDE_SRCS src1 src2 ...]]
                       [INCLUDE_DIRS dir1 dir2 ...]
                       [PRIV_INCLUDE_DIRS dir1 dir2 ...]
                       [REQUIRES component1 component2 ...]
                       [PRIV_REQUIRES component1 component2 ...]
                       [LDFRAGMENTS ldfragment1 ldfragment2 ...]
                       [REQUIRED_IDF_TARGETS target1 target2 ...]
                       [EMBED_FILES file1 file2 ...]
                       [EMBED_TXTFILES file1 file2 ...])
</pre></div>
</div>
<p>რეგისტრაცია კომპონენტი ის აწყობის სისტემაში. ისევე, როგორც <code class="docutils literal notranslate"><span class="pre">project()</span></code> CMake ბრძანება, რომელიც უნდა გამოიძახონ კომპონენტი ის CMakeLists.txt ფაილიდან პირდაპირ (არა ფუნქციის ან მაკროს მეშვეობით) და რეკომენდებულია მისი გამოძახება სხვა ნებისმიერ ბრძანებამდე. აქ მოცემულია რამდენიმე ინსტრუქცია, თუ რომელი ბრძანებები შეიძლება გამოიძახონ <strong>არა</strong> ადრე დაურეკავდნენ <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li>ბრძანებები, რომლებიც არ არის ვალიდური CMake სკრიპტის რეჟიმში</li>
<li>project_include.cmake-ში განსაზღვრული მორგებული ბრძანებები</li>
<li>სისტემის შექმნის API ბრძანებები, გარდა <code class="docutils literal notranslate"><span class="pre">idf_build_get_property</span></code>; თუმცა გაითვალისწინეთ, შესაძლოა, თვისება ჯერ არ იყოს დაყენებული</li>
</ul>
</div></blockquote>
<p>ცვლადების დაყენებისა და მათზე მოქმედი ბრძანებების გამოძახება, როგორც წესი, დასაშვებია. <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>.</p>
<p>არგუმენტები <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> მოიცავს:</p>
<blockquote>
<div><ul class="simple">
<li>SRCS - კომპონენტი საწყისი ფაილები, რომლებიც გამოიყენება კომპონენტი ისთვის სტატიკური ბიბლიოთეკის შესაქმნელად; თუ არ არის მითითებული, კომპონენტი განიხილება, როგორც მხოლოდ კონფიგურაციისთვის განკუთვნილი კომპონენტი და მის ნაცვლად იქმნება ინტერფეისის ბიბლიოთეკა.</li>
<li>SRC_DIRS, EXCLUDE_SRCS - გამოიყენება წყაროს ფაილების (.c, .cpp, .S) გლობალიზაციისთვის დირექტორიების მითითებით, წყაროს ფაილების SRCS-ის მეშვეობით ხელით მითითების ნაცვლად. გაითვალისწინეთ, რომ ეს დამოკიდებულია <a class="reference internal" href="build-system.html#cmake-file-globbing"><span class="std std-ref">გლობირების შეზღუდვები CMake-ში</span></a>EXCLUDE_SRCS-ში მითითებული საწყისი ფაილები ამოღებულია გლობალური ფაილებიდან.</li>
<li>INCLUDE_DIRS - კომპონენტი დირექტორიასთან მიმართებაში არსებული გზები, რომლებიც დაემატება ყველა სხვა კომპონენტი დირექტორიის ჩართვის ძიების გზას, რომელიც საჭიროებს მიმდინარე კომპონენტი</li>
<li>PRIV_INCLUDE_DIRS - დირექტორიის გზები, უნდა იყოს ფარდობითი კომპონენტი დირექტორიასთან, რომელიც დაემატება მხოლოდ ამ კომპონენტი ის საწყისი ფაილების ჩართვის ძიების გზას.</li>
<li>მოითხოვს - საჯარო კომპონენტი მოთხოვნები კომპონენტი ისთვის</li>
<li>PRIV_REQUIRES - კომპონენტი კერძო მოთხოვნები კომპონენტი ისთვის; იგნორირებულია მხოლოდ კონფიგურაციისთვის განკუთვნილ კომპონენტი ზე.</li>
<li>LDFRAGMENTS - კომპონენტი ლინკერის ფრაგმენტის ფაილები</li>
<li>REQUIRED_IDF_TARGETS - მიუთითეთ ერთადერთი სამიზნე, რომელსაც კომპონენტი უჭერს მხარს</li>
</ul>
</div></blockquote>
<p>შემდეგი გამოიყენება <a class="reference internal" href="build-system.html#cmake-embed-data"><span class="std std-ref">მონაცემების ტერმინში ჩასმა კომპონენტი</span></a>და განიხილება, როგორც წყაროს ფაილები, როდესაც განისაზღვრება, არის თუ არა კომპონენტი მხოლოდ კონფიგურაციისთვის. ეს ნიშნავს, რომ მაშინაც კი, თუ კომპონენტი არ მიუთითებს წყაროს ფაილებს, სტატიკური ბიბლიოთეკა მაინც იქმნება შიდა დონეზე კომპონენტი ისთვის, თუ ის განსაზღვრავს რომელიმეს:</p>
<blockquote>
<div><ul class="simple">
<li>EMBED_FILES - ორობითი ფაილები, რომლებიც ჩასაშენებელია კომპონენტი ში</li>
<li>EMBED_TXTFILES - ტექსტური ფაილები, რომლებიც უნდა ჩასვათ კომპონენტი ში</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="cmake-component-properties">
<span id="idf-component-properties"></span><h3>idf- კომპონენტი -თვისებები<a class="headerlink" href="build-system.html#cmake-component-properties" title="Permalink to this headline">¶</a></h3>
<p>ეს არის თვისებები, რომლებიც აღწერს კომპონენტი . კომპონენტი თვისებების მნიშვნელობების მოძიება შესაძლებელია build ბრძანების გამოყენებით. <code class="docutils literal notranslate"><span class="pre">idf_component_get_property</span></code>მაგალითად, დირექტორიის მისაღებად <code class="docutils literal notranslate"><span class="pre">freertos</span></code> კომპონენტი :</p>
<ul class="simple">
<li>COMPONENT_ALIAS - COMPONENT_LIB-ის მეტსახელი, რომელიც გამოიყენება კომპონენტი გარე სამიზნეებთან დასაკავშირებლად; დადგენილია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code> და თავად ალიას ბიბლიოთეკა შექმნილია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code></li>
<li>COMPONENT_DIR - კომპონენტი დირექტორია; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code></li>
<li>COMPONENT_LIB - შექმნილი კომპონენტი სტატიკური/ინტერფეისის ბიბლიოთეკის სახელი; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code> და თავად ბიბლიოთეკა შექმნილია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code></li>
<li>COMPONENT_NAME - კომპონენტი ; დადგენილია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code> კომპონენტი დირექტორიის სახელზე დაყრდნობით</li>
<li>COMPONENT_TYPE - კომპონენტი ის ტიპი, იქნება ეს LIBRARY თუ CONFIG_ONLY. კომპონენტი არის LIBRARY ტიპის, თუ ის განსაზღვრავს წყაროს ფაილებს ან ჩადებს ფაილს.</li>
<li>EMBED_FILES - კომპონენტი ში ჩასასმელი ფაილების სია; მითითებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> EMBED_FILES არგუმენტი</li>
<li>EMBED_TXTFILES - კომპონენტი ში ჩასასმელი ტექსტური ფაილების სია; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> EMBED_TXTFILES არგუმენტი</li>
<li>INCLUDE_DIRS - კომპონენტი ის ჩათვლით დირექტორიების სია; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> INCLUDE_DIRS არგუმენტი</li>
<li>KCONFIG - კომპონენტი Kconfig ფაილი; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code></li>
<li>KCONFIG_PROJBUILD - კომპონენტი Kconfig.projbuild; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_build_component</span></code></li>
<li>LDFRAGMENTS - კომპონენტი ლინკერის ფრაგმენტების ფაილების სია; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> LDFRAGMENTS არგუმენტი</li>
<li>PRIV_INCLUDE_DIRS - კომპონენტი ის კერძო დირექტორიების სია; დაყენებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> PRIV_INCLUDE_DIRS LIBRARY ტიპის კომპონენტი -ზე</li>
<li>PRIV_REQUIRES - კერძო კომპონენტი დამოკიდებულებების სია; მითითებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> PRIV_REQUIRES არგუმენტი</li>
<li>REQUIRED_IDF_TARGETS - კომპონენტი ის მიერ მხარდაჭერილი სამიზნეების სია; მითითებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> EMBED_TXTFILES არგუმენტი</li>
<li>მოითხოვს - საჯარო კომპონენტი დამოკიდებულებების სია; მითითებულია <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> საჭიროებს არგუმენტს</li>
<li>SRCS - კომპონენტი საწყისი ფაილების სია; დაყენებულია SRCS-დან ან SRC_DIRS/EXCLUDE_SRCS არგუმენტიდან <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code></li>
</ul>
</div>
</div>
<div class="section" id="file-globbing-incremental-builds">
<span id="cmake-file-globbing"></span><h2>ფაილების გლობაცია და ინკრემენტული აწყობა<a class="headerlink" href="build-system.html#file-globbing-incremental-builds" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF კომპონენტი ში საწყისი ფაილების ჩართვის სასურველი გზაა მათი ხელით ჩამოთვლა SRCS არგუმენტის გამოყენებით. <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRCS</span> <span class="s">library/a.c</span> <span class="s">library/b.c</span> <span class="s">platform/platform.c</span>
                       <span class="s">...</span><span class="p">)</span>
</pre></div>
</div>
<p>ეს უპირატესობა ასახავს <a class="reference external" href="https://gist.github.com/mbinna/c61dbb39bca0e4fb7d1f73b0d66a4fd1/">საუკეთესო პრაქტიკის გამოყენება</a> წყაროს ფაილების ხელით ჩამოთვლის. თუმცა, ეს შეიძლება მოუხერხებელი იყოს, როდესაც ბილდში დასამატებელი უამრავი წყაროს ფაილია. ESP-IDF ბილდ სისტემა წყაროს ფაილების მითითების ალტერნატიულ გზას გვთავაზობს. <code class="docutils literal notranslate"><span class="pre">SRC_DIRS</span></code>:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">idf_component_register</span><span class="p">(</span><span class="s">SRC_DIRS</span> <span class="s">library</span> <span class="s">platform</span>
                       <span class="s">...</span><span class="p">)</span>
</pre></div>
</div>
<p>ეს მეთოდი იყენებს გლობინგის კულისებში მითითებულ დირექტორიებში წყაროს ფაილების მოსაძებნად. თუმცა, გაითვალისწინეთ, რომ თუ ახალი წყაროს ფაილი დაემატება და ეს მეთოდი გამოყენებული იქნება, CMake-მა არ იცის, რომ ავტომატურად ხელახლა უნდა გაუშვას და ეს ფაილი არ დაემატება ბილდს.</p>
<p>კომპრომისი მისაღებია, როდესაც ფაილს თავად ამატებთ, რადგან შეგიძლიათ სუფთა აწყობა ან გაშვება გამოიწვიოთ. <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">reconfigure</span></code> ხელით ხელახლა გასაშვებად <a class="reference external" href="https://cmake.org">CMake</a>თუმცა, პრობლემა უფრო რთულდება, როდესაც თქვენს პროექტს სხვებს უზიარებთ, რომლებმაც შეიძლება ახალი ვერსია შეამოწმონ წყაროს კონტროლის ინსტრუმენტის, როგორიცაა Git… გამოყენებით.</p>
<p>კომპონენტი ისთვის, რომლებიც ESP-IDF ის ნაწილია, ჩვენ ვიყენებთ მესამე მხარის Git CMake ინტეგრაციის მოდულს (<a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/third_party/GetGitRevisionDescription.cmake">/tools/cmake/third_party/GetGitRevisionDescription.cmake</a>), რომელიც ავტომატურად ხელახლა გაუშვებს CMake-ს ყოველ ჯერზე, როდესაც რეპოზიტორის კომიტი შეიცვლება. ეს ნიშნავს, რომ თუ თქვენ შეამოწმებთ ESP-IDF ახალ ვერსიას, CMake ავტომატურად ხელახლა გაუშვებს.</p>
<p>პროექტის კომპონენტი s-ისთვის (რომელიც არ არის ESP-IDF ის ნაწილი), არსებობს რამდენიმე განსხვავებული ვარიანტი:</p>
<ul class="simple">
<li>თუ თქვენი პროექტის ფაილს Git-ში ინახავთ, ESP-IDF ავტომატურად აკონტროლებს Git-ის ვერსიას და ხელახლა გაუშვებს CMake-ს, თუ ვერსია შეიცვლება.</li>
<li>თუ ზოგიერთი კომპონენტი ინახება მესამე git საცავში (არა პროექტის საცავში ან ESP-IDF საცავში), შეგიძლიათ დაამატოთ გამოძახება <code class="docutils literal notranslate"><span class="pre">git_describe</span></code> ფუნქცია კომპონენტი CMakeLists ფაილში, რათა ავტომატურად გამოიწვიოს CMake-ის ხელახალი გაშვება Git-ის ვერსიის შეცვლისას.</li>
<li>თუ Git-ს არ იყენებთ, არ დაგავიწყდეთ მისი ხელით გაშვება <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">reconfigure</span></code> როდესაც წყაროს ფაილი შეიძლება შეიცვალოს.</li>
<li>ამ პრობლემის სრულად თავიდან ასაცილებლად, გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> არგუმენტი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> პროექტის კომპონენტი ს-ში ყველა საწყისი ფაილის ჩამოსატვირთად.</li>
</ul>
<p>საუკეთესო ვარიანტი დამოკიდებული იქნება თქვენს კონკრეტულ პროექტზე და მის მომხმარებლებზე.</p>
</div>
<div class="section" id="build-system-metadata">
<h2>სისტემის მეტამონაცემების შექმნა<a class="headerlink" href="build-system.html#build-system-metadata" title="Permalink to this headline">¶</a></h2>
<p>IDE-ებსა და სხვა აწყობის სისტემებში ინტეგრაციისთვის, როდესაც CMake ამუშავებს, აწყობის პროცესი წარმოქმნის მეტამონაცემების ფაილებს. <code class="docutils literal notranslate"><span class="pre">build/</span></code> დირექტორია. ამ ფაილების აღსადგენად, გაუშვით <code class="docutils literal notranslate"><span class="pre">cmake</span></code> ან <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">reconfigure</span></code> (ან სხვა ნებისმიერი <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> შექმნის ბრძანება).</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">compile_commands.json</span></code> არის სტანდარტული ფორმატის JSON ფაილი, რომელიც აღწერს პროექტში კომპილაცია d-ს ყველა წყაროს ფაილს. CMake ფუნქცია ქმნის ამ ფაილს და ბევრ IDE-ს შეუძლია მისი გაანალიზება.</li>
<li><code class="docutils literal notranslate"><span class="pre">project_description.json</span></code> შეიცავს ზოგად ინფორმაციას ESP-IDF პროექტის, კონფიგურირებული ბილიკების და ა.შ. შესახებ.</li>
<li><code class="docutils literal notranslate"><span class="pre">flasher_args.json</span></code> შეიცავს esptool.py არგუმენტებს ფლეშ მეხსიერება პროექტის ორობითი ფაილებისთვის. ასევე არსებობს <code class="docutils literal notranslate"><span class="pre">flash_*_args</span></code> ფაილები, რომელთა გამოყენება შესაძლებელია პირდაპირ esptool.py-თან. იხილეთ <a class="reference internal" href="build-system.html#flash-arguments">ფლეშ არგუმენტები</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">CMakeCache.txt</span></code> არის CMake ქეშის ფაილი, რომელიც შეიცავს სხვა ინფორმაციას CMake პროცესის, ინსტრუმენტების ნაკრები და ა.შ. შესახებ.</li>
<li><code class="docutils literal notranslate"><span class="pre">config/sdkconfig.json</span></code> არის პროექტის კონფიგურაცია მნიშვნელობების JSON ფორმატირებული ვერსია.</li>
<li><code class="docutils literal notranslate"><span class="pre">config/kconfig_menus.json</span></code> არის menuconfig ში ნაჩვენები მენიუების JSON ფორმატის ვერსია, გარე IDE ინტერფეისებში გამოსაყენებლად.</li>
</ul>
<div class="section" id="json-configuration-server">
<h3>JSON კონფიგურაციის სერვერი<a class="headerlink" href="build-system.html#json-configuration-server" title="Permalink to this headline">¶</a></h3>
<p>ინსტრუმენტი, სახელწოდებით <code class="docutils literal notranslate"><span class="pre">confserver.py</span></code> გათვალისწინებულია იმისათვის, რომ IDE-ებმა მარტივად ინტეგრირდნენ კონფიგურაციის სისტემის ლოგიკასთან. <code class="docutils literal notranslate"><span class="pre">confserver.py</span></code> შექმნილია ფონურ რეჟიმში გასაშვებად და გამომძახებელ პროცესთან ურთიერთქმედებისთვის, JSON-ის წაკითხვითა და ჩაწერით პროცესის stdin და stdout-ის მეშვეობით.</p>
<p>შეგიძლია სირბილი <code class="docutils literal notranslate"><span class="pre">confserver.py</span></code> პროექტიდან მეშვეობით <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">confserver</span></code> ან <code class="docutils literal notranslate"><span class="pre">ninja</span> <span class="pre">confserver</span></code>, ან მსგავსი სამიზნე, რომელიც გააქტიურებულია სხვა ბილდის გენერატორიდან.</p>
<p>კონფიგურაციის სერვერი stderr-ზე გამოაქვს ადამიანის მიერ წასაკითხი შეცდომები და გაფრთხილებები, ხოლო stdout-ზე - JSON. გაშვებისას, ის გამოიტანს სისტემაში თითოეული კონფიგურაციის ელემენტის სრულ მნიშვნელობებს JSON ლექსიკონის სახით და ხელმისაწვდომ დიაპაზონებს იმ მნიშვნელობებისთვის, რომლებიც შეზღუდულია დიაპაზონით. იგივე ინფორმაცია შეიცავს <code class="docutils literal notranslate"><span class="pre">sdkconfig.json</span></code>:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"values"</span><span class="p">:</span> <span class="p">{</span> <span class="nt">"ITEM"</span><span class="p">:</span> <span class="s2">"value"</span><span class="p">,</span> <span class="nt">"ITEM_2"</span><span class="p">:</span> <span class="mi">1024</span><span class="p">,</span> <span class="nt">"ITEM_3"</span><span class="p">:</span> <span class="kc">false</span> <span class="p">},</span> <span class="nt">"ranges"</span> <span class="p">:</span> <span class="p">{</span> <span class="nt">"ITEM_2"</span> <span class="p">:</span> <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32768</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>მხოლოდ ხილული კონფიგურაციის ელემენტები იგზავნება. უხილავი/გამორთული ელემენტების ანალიზი შესაძლებელია სტატიკურიდან. <code class="docutils literal notranslate"><span class="pre">kconfig_menus.json</span></code> ფაილი, რომელიც ასევე შეიცავს მენიუს სტრუქტურას და სხვა მეტამონაცემებს (აღწერილობები, ტიპები, დიაპაზონები და ა.შ.)</p>
<p>შემდეგ კონფიგურაციის სერვერი დაელოდება კლიენტისგან შეყვანის მონაცემებს. კლიენტი გადასცემს მოთხოვნას ერთი ან მეტი მნიშვნელობის შეცვლის შესახებ, როგორც JSON ობიექტი, რასაც მოჰყვება ახალი ხაზი:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="s2">"1"</span><span class="p">,</span> <span class="nt">"set"</span><span class="p">:</span> <span class="p">{</span><span class="nt">"SOME_NAME"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nt">"OTHER_NAME"</span><span class="p">:</span> <span class="kc">true</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>კონფიგურაციის სერვერი გაანალიზებს ამ მოთხოვნას და განაახლებს პროექტს. <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> ფაილი და დააბრუნეთ ცვლილებების სრული სია:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"values"</span><span class="p">:</span> <span class="p">{</span><span class="nt">"SOME_NAME"</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nt">"OTHER_NAME"</span><span class="p">:</span> <span class="kc">true</span> <span class="p">,</span> <span class="nt">"DEPENDS_ON_SOME_NAME"</span><span class="p">:</span> <span class="kc">null</span><span class="p">}}</span>
</pre></div>
</div>
<p>ელემენტები, რომლებიც ახლა უხილავი/გამორთულია, დააბრუნებენ მნიშვნელობას <code class="docutils literal notranslate"><span class="pre">null</span></code>ნებისმიერი ახლად ხილული ელემენტი დააბრუნებს მის ახლად ხილულ მიმდინარე მნიშვნელობას.</p>
<p>თუ კონფიგურაციის ელემენტის დიაპაზონი იცვლება სხვა მნიშვნელობაზე დამოკიდებულების გამო, მაშინ ესეც იგზავნება:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"values"</span><span class="p">:</span> <span class="p">{</span><span class="nt">"OTHER_NAME"</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="nt">"ranges"</span> <span class="p">:</span> <span class="p">{</span> <span class="nt">"HAS_RANGE"</span> <span class="p">:</span> <span class="p">[</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</pre></div>
</div>
<p>თუ არასწორი მონაცემები გადაეცემა, ობიექტზე გამოჩნდება „შეცდომის“ ველი:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"values"</span><span class="p">:</span> <span class="p">{},</span> <span class="nt">"error"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"The following config symbol(s) were not visible so were not updated: NOT_VISIBLE_ITEM"</span><span class="p">]}</span>
</pre></div>
</div>
<p>ნაგულისხმევად, კონფიგურაციის ცვლილებები sdkconfig ფაილში არ იწერება. ცვლილებები მეხსიერებაში ინახება „შენახვის“ ბრძანების გაგზავნამდე:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"save"</span><span class="p">:</span> <span class="kc">null</span> <span class="p">}</span>
</pre></div>
</div>
<p>შენახული ფაილიდან კონფიგურაციის მნიშვნელობების გადასატვირთად, მეხსიერებაში არსებული ნებისმიერი ცვლილების გაუქმებით, შეგიძლიათ გაიგზავნოს „ჩატვირთვის“ ბრძანება:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="nt">"version"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nt">"load"</span><span class="p">:</span> <span class="kc">null</span> <span class="p">}</span>
</pre></div>
</div>
<p>როგორც „ჩატვირთვის“, ასევე „შენახვის“ მნიშვნელობა შეიძლება იყოს ახალი გზის სახელი ან „null“ წინა გზის სახელის ჩასატვირთად/შესანახად.</p>
<p>„ჩატვირთვის“ ბრძანებაზე პასუხი ყოველთვის არის კონფიგურაციის მნიშვნელობებისა და დიაპაზონების სრული ნაკრები, იგივე, რაც სერვერის საწყისი გაშვებისას.</p>
<p>„ჩატვირთვის“, „დაყენების“ და „შენახვის“ ნებისმიერი კომბინაცია შეიძლება გაიგზავნოს ერთ ბრძანებაში და ბრძანებები ამ თანმიმდევრობით შესრულდება. ამიტომ, შესაძლებელია კონფიგურაციის ფაილიდან ჩატვირთვა, კონფიგურაციის ელემენტის გარკვეული მნიშვნელობების დაყენება და შემდეგ ფაილში შენახვა ერთი ბრძანებით.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">კონფიგურაციის სერვერი ავტომატურად არ ატვირთავს ცვლილებებს, რომლებიც გარედან გამოიყენება. <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> ფაილი. გაგზავნეთ „ჩატვირთვის“ ბრძანება ან გადატვირთეთ სერვერი, თუ ფაილი გარედან არის რედაქტირებული.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">კონფიგურაციის სერვერი არ ხელახლა გაუშვებს CMake-ს სხვა აწყობის ფაილების ან მეტამონაცემების ფაილების რეგენერაციისთვის. <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> განახლებულია. ეს ავტომატურად მოხდება შემდეგ ჯერზე <code class="docutils literal notranslate"><span class="pre">CMake</span></code> ან <code class="docutils literal notranslate"><span class="pre">idf.py</span></code> გაშვებულია.</p>
</div>
</div>
</div>
<div class="section" id="build-system-internals">
<h2>სისტემის შიდა ელემენტების შექმნა<a class="headerlink" href="build-system.html#build-system-internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="build-scripts">
<h3>სკრიპტების შექმნა<a class="headerlink" href="build-system.html#build-scripts" title="Permalink to this headline">¶</a></h3>
<p>ESP-IDF build სისტემის listfiles მდებარეობს <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637//tools/cmake">/ინსტრუმენტები/cmake</a>მოდულები, რომლებიც ახორციელებენ ძირითადი სისტემის აწყობის ფუნქციონალს, შემდეგია:</p>
<blockquote>
<div><blockquote>
<div><ul class="simple">
<li>build.cmake - დაკავშირებული ბრძანებების შექმნა, მაგ. აწყობის ინიციალიზაცია, აწყობის თვისებების მოძიება/დაყენება, აწყობის დამუშავება.</li>
<li>კომპონენტი .cmake - კომპონენტებთან დაკავშირებული ბრძანებები, მაგ. კომპონენტი ის დამატება, კომპონენტი თვისებების მოძიება/დაყენება, კომპონენტი ის რეგისტრაცია.</li>
<li>kconfig.cmake - კონფიგურაციის ფაილების (sdkconfig, sdkconfig.h, sdkconfig.cmake და ა.შ.) გენერირება Kconfig ფაილებიდან.</li>
<li>ldgen.cmake - ლინკერის ფრაგმენტების ფაილებიდან საბოლოო ლინკერის სკრიპტის გენერირება.</li>
<li>target.cmake - build target-ის და ინსტრუმენტების ნაკრები ფაილის დაყენება.</li>
<li>utilities.cmake - სხვადასხვა დამხმარე ბრძანებები.</li>
</ul>
</div></blockquote>
<p>ამ ფაილების გარდა, არსებობს კიდევ ორი მნიშვნელოვანი CMake სკრიპტი. <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637//tools/cmake">/ინსტრუმენტები/cmake</a>:</p>
<blockquote>
<div><ul class="simple">
<li>idf.cmake - აყენებს ბილდს და მოიცავს ზემოთ ჩამოთვლილ ძირითად მოდულებს. შედის CMake პროექტებში ESP-IDF ბილდ სისტემის ფუნქციონალზე წვდომისთვის.</li>
<li>project.cmake - მოიცავს <code class="docutils literal notranslate"><span class="pre">idf.cmake</span></code> და გთავაზობთ მორგებულს <code class="docutils literal notranslate"><span class="pre">project()</span></code> ბრძანება, რომელიც ასრულებს შესრულებადი ფაილის შექმნის ყველა მძიმე სამუშაოს. შედის სტანდარტული ESP-IDF პროექტების ზედა დონის CMakeLists.txt ფაილში.</li>
</ul>
</div></blockquote>
</div></blockquote>
<p>დანარჩენი ფაილები, რომლებიც <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637//tools/cmake">/ინსტრუმენტები/cmake</a> არის დამხმარე ან მესამე მხარის სკრიპტები, რომლებიც გამოიყენება შექმნის პროცესში.</p>
</div>
<div class="section" id="build-process">
<h3>შექმნის პროცესი<a class="headerlink" href="build-system.html#build-process" title="Permalink to this headline">¶</a></h3>
<p>ეს ნაწილი აღწერს ESP-IDF აპლიკაციის შექმნის სტანდარტულ პროცესს. შექმნის პროცესი დაახლოებით ოთხ ფაზად შეიძლება დაიყოს:</p>
<div class="figure align-center" id="id6">
<div><a class="reference internal image-reference" href="../_images/blockdiag-16ef5cdf3d8a6a4300fe1484c9349582a144d8c0.png"><img height="120.0" src="../_images/blockdiag-16ef5cdf3d8a6a4300fe1484c9349582a144d8c0.png" width="832.0"/></a></div><p class="caption"><span class="caption-text">ESP-IDF სისტემის შექმნის პროცესი</span><a class="headerlink" href="build-system.html#id6" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="initialization">
<h4>ინიციალიზაცია<a class="headerlink" href="build-system.html#initialization" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>ეს ეტაპი განსაზღვრავს მშენებლობისთვის საჭირო პარამეტრებს.</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>Upon inclusion of <code class="docutils literal notranslate"><span class="pre">idf.cmake</span></code> in <code class="docutils literal notranslate"><span class="pre">project.cmake</span></code>, the following steps are performed:</dt>
<dd><ul class="first last">
<li>კომპლექტი <code class="docutils literal notranslate"><span class="pre">IDF_PATH</span></code> გარემოს ცვლადიდან ან გზიდან გამომდინარე <code class="docutils literal notranslate"><span class="pre">project.cmake</span></code> შედის ზედა დონის CMakeLists.txt ფაილში.</li>
<li>დამატება <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637//tools/cmake">/ინსტრუმენტები/cmake</a> რომ <code class="docutils literal notranslate"><span class="pre">CMAKE_MODULE_PATH</span></code> და მოიცავს ძირითად მოდულებს პლუს სხვადასხვა დამხმარე/მესამე მხარის სკრიპტებს.</li>
<li>დააყენეთ აწყობის ინსტრუმენტები/შესრულებადი ფაილები, როგორიცაა Python-ის ნაგულისხმევი ინტერპრეტატორი.</li>
<li>მიიღეთ ESP-IDF git revisation და შეინახეთ როგორც <code class="docutils literal notranslate"><span class="pre">IDF_VER</span></code>.</li>
<li>დააყენეთ გლობალური აწყობის სპეციფიკაციები, მაგ. კომპილაცია პარამეტრები, კომპილაცია განმარტებები, ჩართეთ დირექტორიები აწყობაში ყველა კომპონენტი ისთვის.</li>
<li>დაამატეთ კომპონენტი s <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/components">კომპონენტი სემესტრი</a> აშენებისკენ.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>The initial part of the custom <code class="docutils literal notranslate"><span class="pre">project()</span></code> command performs the following steps:</dt>
<dd><ul class="first last">
<li>კომპლექტი <code class="docutils literal notranslate"><span class="pre">IDF_TARGET</span></code> გარემოს ცვლადიდან ან CMake ქეშიდან და შესაბამისიდან <code class="docutils literal notranslate"><span class="pre">CMAKE_TOOLCHAIN_FILE</span></code> გამოსაყენებლად.</li>
<li>დაამატეთ კომპონენტი s <code class="docutils literal notranslate"><span class="pre">EXTRA_COMPONENTS_DIRS</span></code> აშენებისკენ.</li>
<li>მოამზადეთ არგუმენტები ბრძანების გამოძახებისთვის <code class="docutils literal notranslate"><span class="pre">idf_build_process()</span></code> ისეთი ცვლადებიდან, როგორიცაა <code class="docutils literal notranslate"><span class="pre">COMPONENTS</span></code>/<code class="docutils literal notranslate"><span class="pre">EXCLUDE_COMPONENTS</span></code>, <code class="docutils literal notranslate"><span class="pre">SDKCONFIG</span></code>, <code class="docutils literal notranslate"><span class="pre">SDKCONFIG_DEFAULTS</span></code>.</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>ზარი <code class="docutils literal notranslate"><span class="pre">idf_build_process()</span></code> ბრძანება ამ ფაზის დასასრულს აღნიშნავს.</p>
</div></blockquote>
</div>
<div class="section" id="enumeration">
<h4>ჩამოთვლა<a class="headerlink" href="build-system.html#enumeration" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>ეს ფაზა ქმნის კომპონენტი ის საბოლოო სიას, რომელიც უნდა დამუშავდეს აწყობაში და ხორციელდება პირველ ნახევარში. <code class="docutils literal notranslate"><span class="pre">idf_build_process()</span></code>.</p>
<blockquote>
<div><ul class="simple">
<li>თითოეული კომპონენტი ის საჯარო და კერძო მოთხოვნების მოძიება. იქმნება შვილობილი პროცესი, რომელიც თითოეული კომპონენტი ის CMakeLists.txt ფაილს სკრიპტის რეჟიმში ასრულებს. -ის მნიშვნელობები <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> REQUIRES და PRIV_REQUIRES არგუმენტი უბრუნდება მშობელ აწყობის პროცესს. ამას ადრეული გაფართოება ეწოდება. ცვლადი <code class="docutils literal notranslate"><span class="pre">CMAKE_BUILD_EARLY_EXPANSION</span></code> ამ ეტაპის განმავლობაში განისაზღვრება.</li>
<li>რეკურსიული სახით ჩართეთ კომპონენტი ე ტერმინი საჯარო და კერძო მოთხოვნების საფუძველზე.</li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="processing">
<h4>დამუშავება<a class="headerlink" href="build-system.html#processing" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>ეს ფაზა ამუშავებს კომპონენტი s-ს კონსტრუქციაში და წარმოადგენს მეორე ნახევარს. <code class="docutils literal notranslate"><span class="pre">idf_build_process()</span></code>.</p>
<ul class="simple">
<li>sdkconfig ფაილიდან ჩატვირთეთ პროექტის კონფიგურაცია და შექმენით sdkconfig.cmake და sdkconfig.h სათაური. ეს ცვლადები/მაკროსები განსაზღვრავს კონფიგურაციის ცვლადებს/მაკროსებს, რომლებიც ხელმისაწვდომია შესაბამისად აწყობის სკრიპტებიდან და C/C++ წყაროს/სათაურის ფაილებიდან.</li>
<li>ჩართეთ თითოეული კომპონენტი <code class="docutils literal notranslate"><span class="pre">project_include.cmake</span></code>.</li>
<li>დაამატეთ თითოეული კომპონენტი ქვედირექტორიად, მისი CMakeLists.txt დამუშავებით. კომპონენტი CMakeLists.txt გამოიძახებს რეგისტრაციის ბრძანებას, <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> რომელიც ამატებს წყაროს ფაილებს, მოიცავს დირექტორიებს, ქმნის კომპონენტი ბიბლიოთეკას, აკავშირებს დამოკიდებულებებს და ა.შ.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="finalization">
<h4>დასრულება<a class="headerlink" href="build-system.html#finalization" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>ამ ფაზის შემდეგ ყველაფერია <code class="docutils literal notranslate"><span class="pre">idf_build_process()</span></code>.</p>
<ul class="simple">
<li>შექმენით შესრულებადი ფაილი და დააკავშირეთ კომპონენტი ბიბლიოთეკები მასთან.</li>
<li>შექმენით პროექტის მეტამონაცემების ფაილები, როგორიცაა project_description.json, და აჩვენეთ შესაბამისი ინფორმაცია შექმნილი პროექტის შესახებ.</li>
</ul>
</div></blockquote>
<p>დათვალიერება <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/project.cmake">/tools/cmake/project.cmake</a> დამატებითი დეტალებისთვის.</p>
</div>
</div>
</div>
<div class="section" id="migrating-from-esp-idf-gnu-make-system">
<h2>ESP-IDF GNU Make System-დან მიგრაცია<a class="headerlink" href="build-system.html#migrating-from-esp-idf-gnu-make-system" title="Permalink to this headline">¶</a></h2>
<p>CMake-ზე დაფუძნებული ESP-IDF build სისტემის ზოგიერთი ასპექტი ძალიან ჰგავს GNU Make-ზე დაფუძნებულ ძველ სისტემას. დეველოპერმა უნდა მიუთითოს მნიშვნელობები, რომლებიც მოიცავს დირექტორიებს, წყაროს ფაილებს და ა.შ. თუმცა, არსებობს სინტაქსური განსხვავება, რადგან დეველოპერმა ისინი რეგისტრაციის ბრძანებისთვის არგუმენტების სახით უნდა გადასცეს. <cite>idf_component_register</cite>.</p>
<div class="section" id="automatic-conversion-tool">
<h3>ავტომატური კონვერტაციის ინსტრუმენტი<a class="headerlink" href="build-system.html#automatic-conversion-tool" title="Permalink to this headline">¶</a></h3>
<p>პროექტის ავტომატური კონვერტაციის ინსტრუმენტი ხელმისაწვდომია <a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637//tools/cmake/convert_to_cmake.py">/tools/cmake/convert_to_cmake.py</a>გაუშვით ეს ბრძანების ხაზის ინსტრუმენტი პროექტისკენ მიმავალი ბილიკით შემდეგნაირად:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">$IDF_PATH</span>/tools/cmake/convert_to_cmake.py /path/to/project_dir
</pre></div>
</div>
<p>პროექტის დირექტორია უნდა შეიცავდეს Makefile-ს და GNU Make (<code class="docutils literal notranslate"><span class="pre">make</span></code>) უნდა იყოს დაინსტალირებული და ხელმისაწვდომი PATH-ზე.</p>
<p>ინსტრუმენტი გარდაქმნის პროექტის Makefile-ს და ნებისმიერ კომპონენტი <code class="docutils literal notranslate"><span class="pre">component.mk</span></code> ფაილები მათი ეკვივალენტებისთვის <code class="docutils literal notranslate"><span class="pre">CMakeLists.txt</span></code> ფაილები.</p>
<p>ამას სირბილით აკეთებს <code class="docutils literal notranslate"><span class="pre">make</span></code> ESP-IDF build სისტემის ცვლადების გასაფართოებლად, რომლებიც build-ის მიერ არის დაყენებული და შემდეგ იგივე ცვლადების დასაყენებლად ეკვივალენტური CMakelists ფაილების გენერირება.</p>
<p>კონვერტაციის ხელსაწყოს არ შეუძლია Makefile-ის რთული ლოგიკის ან უჩვეულო სამიზნეების დამუშავება. მათი ხელით კონვერტაცია იქნება საჭირო.</p>
</div>
<div class="section" id="no-longer-available-in-cmake">
<h3>CMake-ში აღარ არის ხელმისაწვდომი<a class="headerlink" href="build-system.html#no-longer-available-in-cmake" title="Permalink to this headline">¶</a></h3>
<p>CMake-ზე დაფუძნებულ სისტემაში ზოგიერთი ფუნქცია მნიშვნელოვნად განსხვავებულია ან ამოღებულია. შემდეგი ცვლადები აღარ არსებობს CMake-ზე დაფუძნებულ აწყობის სისტემაში:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_BUILD_DIR</span></code>: გამოყენება <code class="docutils literal notranslate"><span class="pre">CMAKE_CURRENT_BINARY_DIR</span></code> სამაგიეროდ.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_LIBRARY</span></code>: ნაგულისხმევად <code class="docutils literal notranslate"><span class="pre">$(COMPONENT_NAME).a</span></code>, თუმცა ბიბლიოთეკის სახელი შეიძლება შეიცვალოს კომპონენტი ით. კომპონენტი ბიბლიოთეკის სახელი აღარ შეიძლება შეიცვალოს კომპონენტი ით.</li>
<li><code class="docutils literal notranslate"><span class="pre">CC</span></code>, <code class="docutils literal notranslate"><span class="pre">LD</span></code>, <code class="docutils literal notranslate"><span class="pre">AR</span></code>, <code class="docutils literal notranslate"><span class="pre">OBJCOPY</span></code>gcc xtensa cross- ინსტრუმენტების ნაკრები დან თითოეული ინსტრუმენტის სრული ბილიკები. გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">CMAKE_C_COMPILER</span></code>, <code class="docutils literal notranslate"><span class="pre">CMAKE_C_LINK_EXECUTABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">CMAKE_OBJCOPY</span></code>და ა.შ. ამის ნაცვლად. <a class="reference external" href="https://cmake.org/cmake/help/v3.5/manual/cmake-variables.7.html#variables-for-languages">სრული სია აქ</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">HOSTCC</span></code>, <code class="docutils literal notranslate"><span class="pre">HOSTLD</span></code>, <code class="docutils literal notranslate"><span class="pre">HOSTAR</span></code>: მასპინძელი მშობლიური ინსტრუმენტების ნაკრები დან თითოეული ინსტრუმენტის სრული სახელები. ეს სახელები აღარ არის მოწოდებული, გარე პროექტებმა ნებისმიერი საჭირო მასპინძელი ინსტრუმენტების ნაკრები ხელით უნდა აღმოაჩინონ.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_ADD_LDFLAGS</span></code>: გამოიყენება ბმულის დროშების გადასაფარებლად. გამოიყენეთ CMake <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/target_link_libraries.html#command:target_link_libraries">target_link_libraries</a> ბრძანება ამის ნაცვლად.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_ADD_LINKER_DEPS</span></code>: ფაილების სია, რომლებზეც ბმული უნდა იყოს დამოკიდებული. <a class="reference external" href="https://cmake.org/cmake/help/v3.5/command/target_link_libraries.html#command:target_link_libraries">target_link_libraries</a> როგორც წესი, ეს დამოკიდებულებები ავტომატურად გამოიტანება. ლინკერის სკრიპტებისთვის გამოიყენეთ მოწოდებული CMake ფუნქცია. <code class="docutils literal notranslate"><span class="pre">target_linker_scripts</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_SUBMODULES</span></code>: თუ აღარ გამოიყენება, შექმნის სისტემა ავტომატურად ჩამოთვლის ყველა ქვემოდულს ESP-IDF რეპოზიტორში.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_EXTRA_INCLUDES</span></code>: ადრე ალტერნატივა იყო <code class="docutils literal notranslate"><span class="pre">COMPONENT_PRIV_INCLUDEDIRS</span></code> აბსოლუტური ბილიკებისთვის. გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">PRIV_INCLUDE_DIRS</span></code> არგუმენტი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> ყველა შემთხვევისთვის ახლა (შეიძლება იყოს ფარდობითი ან აბსოლუტური).</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_OBJS</span></code>ადრე, კომპონენტი წყაროების მითითება შესაძლებელი იყო ობიექტის ფაილების სიის სახით. ახლა მათი მითითება შესაძლებელია წყაროს ფაილების სიის სახით შემდეგი გზით: <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> არგუმენტი <cite>idf_component_register</cite>.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_OBJEXCLUDE</span></code>: ჩანაცვლებულია -ით <code class="docutils literal notranslate"><span class="pre">EXCLUDE_SRCS</span></code> არგუმენტი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code>მიუთითეთ საწყისი ფაილები (აბსოლუტური გზების ან კომპონენტი დირექტორიასთან მიმართებაში).</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_EXTRA_CLEAN</span></code>: თვისების დაყენება <code class="docutils literal notranslate"><span class="pre">ADDITIONAL_MAKE_CLEAN_FILES</span></code> სამაგიეროდ, მაგრამ გაითვალისწინეთ <a class="reference internal" href="build-system.html#additional-make-clean-files-note"><span class="std std-ref">CMake-ს ამ ფუნქციონალთან დაკავშირებით გარკვეული შეზღუდვები აქვს</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_OWNBUILDTARGET</span></code> და <code class="docutils literal notranslate"><span class="pre">COMPONENT_OWNCLEANTARGET</span></code>: გამოიყენეთ CMake <a class="reference external" href="https://cmake.org/cmake/help/v3.5/module/ExternalProject.html">გარე პროექტი</a> სამაგიეროდ. იხილეთ <a class="reference internal" href="build-system.html#component-build-full-override"><span class="std std-ref">კომპონენტის შექმნის პროცესის სრულად უგულებელყოფა</span></a> სრული დეტალებისთვის.</li>
<li><code class="docutils literal notranslate"><span class="pre">COMPONENT_CONFIG_ONLY</span></code>: ზარი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> ყოველგვარი არგუმენტების გარეშე. იხილეთ <a class="reference internal" href="build-system.html#configuration-only-components">მხოლოდ კონფიგურაციის კომპონენტები</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">CFLAGS</span></code>, <code class="docutils literal notranslate"><span class="pre">CPPFLAGS</span></code>, <code class="docutils literal notranslate"><span class="pre">CXXFLAGS</span></code>: გამოიყენეთ ეკვივალენტური CMake ბრძანებები. იხილეთ <a class="reference internal" href="build-system.html#controlling-component-compilation">კომპონენტების კომპილაციის კონტროლი</a>.</li>
</ul>
</div>
<div class="section" id="no-default-values">
<h3>ნაგულისხმევი მნიშვნელობები არ არის<a class="headerlink" href="build-system.html#no-default-values" title="Permalink to this headline">¶</a></h3>
<p>მემკვიდრეობით მიღებული Make-based build სისტემისგან განსხვავებით, შემდეგ პარამეტრებს არ აქვთ ნაგულისხმევი მნიშვნელობები:</p>
<ul class="simple">
<li>წყაროს დირექტორიები (<code class="docutils literal notranslate"><span class="pre">COMPONENT_SRCDIRS</span></code> ცვლადი Make-ში, <code class="docutils literal notranslate"><span class="pre">SRC_DIRS</span></code> არგუმენტი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> CMake-ში)</li>
<li>დირექტორიების ჩართვა (<code class="docutils literal notranslate"><span class="pre">COMPONENT_ADD_INCLUDEDIRS</span></code> ცვლადი Make-ში, <code class="docutils literal notranslate"><span class="pre">INCLUDE_DIRS</span></code> არგუმენტი <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> CMake-ში)</li>
</ul>
</div>
<div class="section" id="no-longer-necessary">
<h3>აღარ არის საჭირო<a class="headerlink" href="build-system.html#no-longer-necessary" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>მემკვიდრეობით მიღებულ აწყობის სისტემაში ასევე საჭიროა დაყენდეს <code class="docutils literal notranslate"><span class="pre">COMPONENT_SRCDIRS</span></code> თუ <code class="docutils literal notranslate"><span class="pre">COMPONENT_SRCS</span></code> დაყენებულია. CMake-ში ეკვივალენტი აუცილებელი არ არის, ანუ მითითება <code class="docutils literal notranslate"><span class="pre">SRC_DIRS</span></code> რომ <code class="docutils literal notranslate"><span class="pre">idf_component_register</span></code> თუ <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> ასევე მითითებულია (სინამდვილეში, <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> იგნორირებულია, თუ <code class="docutils literal notranslate"><span class="pre">SRC_DIRS</span></code> მითითებულია).</li>
</ul>
</div>
<div class="section" id="flashing-from-make">
<h3>მარკის ციმციმი<a class="headerlink" href="build-system.html#flashing-from-make" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">flash</span></code> და მსგავსი მიზნები კვლავ მუშაობს ფლეშ მეხსიერება შესაქმნელად. თუმცა, პროექტი <code class="docutils literal notranslate"><span class="pre">sdkconfig</span></code> აღარ განსაზღვრავს სერიული პორტი და ბოდის სიჩქარე . გარემოს ცვლადების გამოყენება შესაძლებელია მათი გადასალახავად. იხილეთ <a class="reference internal" href="build-system.html#flash-with-ninja-or-make"><span class="std std-ref">ნინძასთან ან მაკასთან ერთად ფლეშინგი</span></a> დამატებითი დეტალებისთვის.</p>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="build-system-legacy.html" rel="next" title="Build System (Legacy GNU Make)">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="bootloader.html" rel="prev" title="Bootloader"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>