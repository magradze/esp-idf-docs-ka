
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SDIO ბარათის დამხმარე დრაივერი — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="esp_slave_protocol.html" rel="next" title="Communication with ESP SDIO Slave"/>
<link href="sdspi_host.html" rel="prev" title="SD SPI Host Driver"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/sdio_slave.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/peripherals/sdio_slave"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/peripherals/sdio_slave.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">პერიფერიული მოწყობილობები</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="adc.html">ანალოგური კომბინაციის კოდი</a></li>
<li class="toctree-l3"><a class="reference internal" href="can.html">შეიძლება</a></li>
<li class="toctree-l3"><a class="reference internal" href="dac.html">ციფრულ-ანალოგური AC</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpio.html">GPIO (RTC დაბალი სიმძლავრის შეყვანა/გამოყვანის ჩათვლით)</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2c.html">I2C</a></li>
<li class="toctree-l3"><a class="reference internal" href="i2s.html">I2S</a></li>
<li class="toctree-l3"><a class="reference internal" href="ledc.html">LED კონტროლი</a></li>
<li class="toctree-l3"><a class="reference internal" href="mcpwm.html">MCPWM</a></li>
<li class="toctree-l3"><a class="reference internal" href="pcnt.html">პულსის მრიცხველი</a></li>
<li class="toctree-l3"><a class="reference internal" href="rmt.html">დისტანციური მართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="sd_pullup_requirements.html">SD Pull-up-ის მოთხოვნები</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc_host.html">SDMMC ჰოსტი</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdspi_host.html">SD SPI მასპინძელი</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="sdio_slave.html#">SDIO მონა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="sdio_slave.html#overview">მიმოხილვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="sdio_slave.html#application-example">განაცხადის მაგალითი</a></li>
<li class="toctree-l4"><a class="reference internal" href="sdio_slave.html#api-reference">API მითითება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sigmadelta.html">სიგმა-დელტა მოდულაცია</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_master.html">SPI ოსტატი</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_slave.html">SPI მონა</a></li>
<li class="toctree-l3"><a class="reference internal" href="temp_sensor.html">ტემპერატურის სენსორი</a></li>
<li class="toctree-l3"><a class="reference internal" href="timer.html">ტაიმერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="touch_pad.html">შეხების სენსორი</a></li>
<li class="toctree-l3"><a class="reference internal" href="uart.html">UART</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">შენახვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">პერიფერიული მოწყობილობების API</a> »</li>
<li>SDIO ბარათის დამხმარე დრაივერი</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/peripherals/sdio_slave.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="sdio-card-slave-driver">
<h1>SDIO ბარათის დამხმარე დრაივერი<a class="headerlink" href="sdio_slave.html#sdio-card-slave-driver" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="sdio_slave.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ESP32 SDIO ბარათის პერიფერიული მოწყობილობები (ჰოსტი, მონა) იზიარებს პინების ორ კომპლექტს, როგორც ეს ქვემოთ მოცემულ ცხრილშია მოცემული. პირველი კომპლექტი, როგორც წესი, დაკავებულია SPI0 ავტობუსით, რომელიც პასუხისმგებელია SPI ფლეშ მეხსიერება , რომელიც ინარჩუნებს გასაშვებად კოდს. ეს ნიშნავს, რომ SDIO მონა დრაივერს შეუძლია იმუშაოს მხოლოდ პინების მეორე კომპლექტზე, სანამ SDIO ჰოსტი არ იყენებს მას.</p>
<p>SDIO მონა მოწყობილობას შეუძლია მუშაობა 3 რეჟიმში: SPI, 1-ბიტიანი SD და 4-ბიტიანი SD რეჟიმები, რომლებსაც აპარატურა ავტომატურად აღმოაჩენს. SDIO სპეციფიკაციის მიხედვით, CMD და DAT0-3 ხაზები უნდა გაიხსნას 1-ბიტიან, 4-ბიტიან თუ SPI რეჟიმში.</p>
<div class="section" id="connections">
<h3>კავშირები<a class="headerlink" href="sdio_slave.html#connections" title="Permalink to this headline">¶</a></h3>
<table border="1" class="docutils">
<colgroup>
<col width="26%"/>
<col width="38%"/>
<col width="18%"/>
<col width="18%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">PIN-ის სახელი</th>
<th class="head" rowspan="2">შესაბამისი ქინძისთავები SPI რეჟიმში</th>
<th class="head">სლოტი 1</th>
<th class="head">სლოტი 2</th>
</tr>
<tr class="row-even"><th class="head" colspan="2">GPIO ნომერი</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>CLK</td>
<td>SCLK</td>
<td>6</td>
<td>14</td>
</tr>
<tr class="row-even"><td>CMD</td>
<td>მოსი</td>
<td>11</td>
<td>15</td>
</tr>
<tr class="row-odd"><td>DAT0</td>
<td>მისო</td>
<td>7</td>
<td>2</td>
</tr>
<tr class="row-even"><td>თარიღი1</td>
<td>შეწყვეტა</td>
<td>8</td>
<td>4</td>
</tr>
<tr class="row-odd"><td>DAT2</td>
<td>NC (გაწევა)</td>
<td>9</td>
<td>12</td>
</tr>
<tr class="row-even"><td>DAT3</td>
<td>#CS</td>
<td>10</td>
<td>13</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>1-ბიტიანი SD რეჟიმი: შეაერთეთ CLK, CMD, DAT0, DAT1 პინები და დამიწება.</li>
<li>4-ბიტიანი SD რეჟიმი: შეაერთეთ ყველა პინი და დამიწება.</li>
<li>SPI რეჟიმი: შეაერთეთ SCLK, MOSI, MISO, Interrupt, #CS პინები და დამიწება.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">გთხოვთ, შეამოწმოთ, სწორად არის თუ არა ბარათის CMD და DATA ხაზები D0-D3 10 კოჰმ რეზისტორებით მიმაგრებული. ეს უნდა იყოს უზრუნველყოფილი 1-ბიტიან ან SPI რეჟიმშიც კი. ოფიციალური მოდულების უმეტესობა შიდა რეჟიმში არ გვთავაზობს ამ მიმაგრებას. თუ იყენებთ ოფიციალურ დეველოპერულ დაფებს, შეამოწმეთ.
<a class="reference internal" href="sd_pullup_requirements.html#compatibility-overview-espressif-hw-sdio"><span class="std std-ref">თავსებადობის მიმოხილვა</span></a> იმის სანახავად, აქვს თუ არა თქვენს განვითარების დაფებს ასეთი ამოძრავებები.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p>ოფიციალური მოდულების უმეტესობას აქვს კონფლიქტი SDIO-ს დამხმარე ფუნქციასთან შემაერთებელ ქინძისთავებზე. თუ იყენებთ ESP32 მოდულს 3.3 ვ ფლეშ მეხსიერება 3, მოდულის პირველად დეველოპერის დროს უნდა ჩაწეროთ EFUSE. იხილეთ <a class="reference internal" href="sd_pullup_requirements.html#compatibility-overview-espressif-hw-sdio"><span class="std std-ref">თავსებადობის მიმოხილვა</span></a> იმის სანახავად, თუ როგორ გახადოთ თქვენი მოდულები SDIO-სთან თავსებადი.</p>
<p>აქ მოცემულია 3.3 ვოლტიანი ფლეშ მეხსიერება ის მქონე მოდულების/კომპლექტების სია:</p>
<ul class="simple">
<li>მოდულები: ESP32-PICO-D4, ESP32-WROOM-32 სერია (მათ შორის ESP32-SOLO-1), ESP32-WROVER-B და ESP32-WROVER-IB</li>
<li>კომპლექტები: ESP32-PICO-KIT, ESP32-DevKitC (v4-მდე), ESP32-WROVER-KIT (v4.1 (ასევე ცნობილი როგორც ESP32-WROVER-KIT-VB), v2, v1 (ასევე ცნობილი როგორც DevKitJ v1))</li>
</ul>
<p class="last">თქვენი ESP23-WROVER-KIT-ის ვერსიის გარჩევა მასზე არსებული მოდულის მიხედვით შეგიძლიათ: v4.1 შეიცავს ESP32-WROVER-B მოდულებს, v3 შეიცავს ESP32-WROVER მოდულებს, ხოლო v2 და v1 შეიცავს ESP32-WROOM-32 მოდულებს.</p>
</div>
<p>იხილეთ <a class="reference internal" href="sd_pullup_requirements.html"><span class="doc">SD Pull-up-ის მოთხოვნები</span></a> ამოძრავებების შესახებ დამატებითი ტექნიკური დეტალებისთვის.</p>
<div class="toctree-wrapper compound">
</div>
<p>მასპინძელი მონას SD რეჟიმში გადაჰყავს თავდაპირველად CMD0-ის გაგზავნით DAT3 პინით მაღალი სიგნალით, ან SPI რეჟიმში CMD0-ის გაგზავნით CS პინით (იგივე პინი, რაც DAT3) დაბალი სიგნალით.</p>
<p>ინიციალიზაციის შემდეგ, მასპინძელს შეუძლია ჩართოს 4-ბიტიანი SD რეჟიმი CCCR რეგისტრის 0x07 CMD52-ით ჩაწერით. ავტობუსის აღმოჩენის ყველა პროცესს დაქვემდებარებული პერიფერიული მოწყობილობა ამუშავებს.</p>
<p>ჰოსტს უნდა დაუკავშირდეს მონა-მოთამაშეს ESP-მოთამაშისთვის სპეციფიკური პროტოკოლით. მონა-მოთამაშე ფუნქცია 1-ზე წვდომის მეშვეობით 3 სერვისს სთავაზობს CMD52 და CMD53-ის მეშვეობით: (1) გამგზავნი FIFO და მიმღები FIFO, (2) ჰოსტისა და მონა-მოთამაშის მიერ გაზიარებული 52 8-ბიტიანი R/W რეგისტრი, (3) 16 შეწყვეტის წყარო (8 ჰოსტიდან მონა-მოთამაშემდე და 8 მონიდან ჰოსტამდე).</p>
</div>
<div class="section" id="terminology">
<h3>ტერმინოლოგია<a class="headerlink" href="sdio_slave.html#terminology" title="Permalink to this headline">¶</a></h3>
<p>SDIO დაქვემდებარებული დრაივერი იყენებს შემდეგ ტერმინებს:</p>
<ul class="simple">
<li>გადაცემა: გადაცემა ყოველთვის იწყება ჰოსტიდან მიღებული ბრძანების ტოკენით და შეიძლება შეიცავდეს პასუხს და რამდენიმე მონაცემთა ბლოკს. ESP32 მონა პროგრამული უზრუნველყოფა დაფუძნებულია გადაცემებზე.</li>
<li>გაგზავნა: slave-დან host-ზე გადარიცხვები.</li>
<li>მიღება: მასპინძლიდან მონაზე გადაყვანა.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ESP ტექნიკური სახელმძღვანელოს რეგისტრების სახელები ჰოსტის თვალსაზრისით არის ორიენტირებული, ანუ „rx“ რეგისტრები გაგზავნას აღნიშნავს, ხოლო „tx“ მიღებას. ჩვენ არ ვიყენებთ <cite>tx</cite> ან <cite>rx</cite> მძღოლში, რათა თავიდან იქნას აცილებული ორაზროვნება.</p>
</div>
<ul class="simple">
<li>FIFO: ფუნქცია 1-ში კონკრეტული მისამართი, რომელზეც წვდომა შესაძლებელია CMD53-ის მეშვეობით დიდი რაოდენობით მონაცემების წასაკითხად/ჩასაწერად. მისამართი დაკავშირებულია მონა პორტიდან წასაკითხად/ჩასაწერად მოთხოვნილ სიგრძესთან ერთი გადაცემისას:
<em>მოთხოვნილი სიგრძე</em> = 0x1F800-მისამართი.</li>
<li>საკუთრება: როდესაც დრაივერი იღებს ბუფერის საკუთრებას, ეს ნიშნავს, რომ დრაივერს შეუძლია შემთხვევით წაიკითხოს/ჩაწეროს ბუფერი (ჩვეულებრივ, DMA-ს მეშვეობით). აპლიკაციამ არ უნდა წაიკითხოს/ჩაწეროს ბუფერი მანამ, სანამ საკუთრება არ დაუბრუნდება აპლიკაციას. თუ აპლიკაცია კითხულობს მიმღები დრაივერის საკუთრებაში არსებული ბუფერიდან, მონაცემების წაკითხვა შეიძლება იყოს შემთხვევითი; თუ აპლიკაცია წერს გამგზავნი დრაივერის საკუთრებაში არსებულ ბუფერში, გაგზავნილი მონაცემები შეიძლება დაზიანდეს.</li>
<li>მოთხოვნილი სიგრძე: ერთ გადარიცხვაში მოთხოვნილი სიგრძე, რომელიც განისაზღვრება FIFO მისამართით.</li>
<li>გადაცემის სიგრძე: ერთ გადაცემაში მოთხოვნილი სიგრძე, რომელიც განისაზღვრება CMD53 ბაიტების/ბლოკების რაოდენობის ველით.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">მოთხოვნილი სიგრძე განსხვავდება გადაცემის სიგრძისგან. ESP32 მონა DMA ბაზაზე <em>მოთხოვნილი სიგრძე</em> ვიდრე <em>გადაცემის სიგრძე</em>. ის <em>გადაცემის სიგრძე</em> არ უნდა იყოს უფრო მოკლე, ვიდრე <em>მოთხოვნილი სიგრძე</em>, ხოლო დანარჩენი ნაწილი შეივსება 0-ით (გაგზავნა) ან გაუქმება (მიღება).</p>
</div>
<ul class="simple">
<li>მიმღები ბუფერის ზომა: ბუფერის ზომა წინასწარ განსაზღვრულია მასპინძელსა და დამხმარე მოწყობილობას შორის კომუნიკაციის დაწყებამდე. დამხმარე აპლიკაციამ ინიციალიზაციის დროს ბუფერის ზომა უნდა დააყენოს <code class="docutils literal notranslate"><span class="pre">recv_buffer_size</span></code> წევრი
<code class="docutils literal notranslate"><span class="pre">sdio_slave_config_t</span></code>.</li>
<li>შეფერხებები: esp32 დაქვემდებარებული სისტემის მხარდაჭერა ორი მიმართულებით ახდენს შეფერხებებს: ჰოსტიდან დაქვემდებარებულისკენ (ქვემოთ მოქვემდებარე შეფერხებები) და დაქვემდებარებულიდან ჰოსტამდე (ქვემოთ მოქვემდებარე ჰოსტის შეფერხებები). იხილეთ მეტი <a class="reference internal" href="sdio_slave.html#interrupts"><span class="std std-ref">შეწყვეტები</span></a>.</li>
<li>რეგისტრები: ფუნქცია 1-ში კონკრეტული მისამართი, წვდომა CMD52 ან CMD53-ით.</li>
</ul>
</div>
<div class="section" id="communication-with-esp-sdio-slave">
<h3>კომუნიკაცია ESP SDIO Slave-თან<a class="headerlink" href="sdio_slave.html#communication-with-esp-sdio-slave" title="Permalink to this headline">¶</a></h3>
<p>მასპინძელმა უნდა მოახდინოს ESP32 SDIO მონა-მოთამაშის ინიციალიზაცია სტანდარტული SDIO ინიციალიზაციის პროცესის შესაბამისად (სექტორი 3.1.2). <a class="reference external" href="https://www.sdcard.org/downloads/pls/">SDIO გამარტივებული სპეციფიკაცია</a>), რომელიც მოკლედ არის აღწერილი <a class="reference internal" href="esp_slave_protocol.html#esp-slave-init"><span class="std std-ref">ESP SDIO მონა-მონაწილის ინიციალიზაცია</span></a>.</p>
<p>გარდა ამისა, CMD52/CMD53-ზე Func 1-ზე არსებობს ESP32-სპეციფიკური ზედა დონის საკომუნიკაციო პროტოკოლი. იხილეთ <a class="reference internal" href="esp_slave_protocol.html#esp-slave-protocol-layer"><span class="std std-ref">ESP SDIO მონა პროტოკოლი</span></a>ასევე არსებობს კომპონენტი
<a class="reference internal" href="../protocols/esp_serial_slave_link.html"><span class="doc">ESP სერიული მონა ბმული</span></a>
ESP32 მასტერისთვის ESP32 SDIO მონასთან კომუნიკაციისთვის იხილეთ მაგალითი <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/peripherals/sdio">პერიფერიული მოწყობილობები/სდიო</a>
თქვენი ჰოსტის პროგრამირებისას.</p>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="interrupts">
<span id="id1"></span><h3>შეწყვეტები<a class="headerlink" href="sdio_slave.html#interrupts" title="Permalink to this headline">¶</a></h3>
<p>მოსახერხებელი კომუნიკაციის ხელშესაწყობად, ჰოსტიდან მონამდე და მონიდან ჰოსტამდე შეფერხებებია.</p>
<div class="section" id="slave-interrupts">
<h4>მონათა შეფერხებები<a class="headerlink" href="sdio_slave.html#slave-interrupts" title="Permalink to this headline">¶</a></h4>
<p>ჰოსტს შეუძლია შეაჩეროს მონა 0x08D რეგისტრში ნებისმიერი ერთი ბიტის ჩაწერით. რეგისტრის ნებისმიერი ბიტის დაყენების შემდეგ, იხსნება შეწყვეტა და SDIO მონა დრაივერი იძახებს უკუკავშირის ფუნქციას, რომელიც განსაზღვრულია <code class="docutils literal notranslate"><span class="pre">slave_intr_cb</span></code> წევრი <code class="docutils literal notranslate"><span class="pre">sdio_slave_config_t</span></code> სტრუქტურა.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">უკუკავშირის ფუნქცია გამოიძახება ISR-ში, უკუკავშირში არ გამოიყენოთ რაიმე შეფერხება, ციკლი ან სპინლოკი.</p>
</div>
<p>არსებობს ფუნქციების კიდევ ერთი ნაკრების გამოყენება. შეგიძლიათ დარეკოთ <code class="docutils literal notranslate"><span class="pre">sdio_slave_wait_int</span></code> გარკვეულ დროში შეფერხების მოლოდინი ან დარეკვა <code class="docutils literal notranslate"><span class="pre">sdio_slave_clear_int</span></code> ჰოსტიდან შეფერხებების გასასუფთავებლად. უკუკავშირის ფუნქციას შეუძლია იდეალურად იმუშაოს ლოდინის ფუნქციებთან ერთად.</p>
</div>
<div class="section" id="host-interrupts">
<h4>მასპინძლის შეფერხებები<a class="headerlink" href="sdio_slave.html#host-interrupts" title="Permalink to this headline">¶</a></h4>
<p>მონა-მომხმარებელს შეუძლია ჰოსტის მუშაობის შეწყვეტა შეწყვეტის ხაზით (გარკვეულ დროს), რომელიც დონის მიმართ მგრძნობიარეა. როდესაც ჰოსტი ხედავს შეწყვეტის ხაზს, მას შეუძლია წაიკითხოს მონა-მომხმარებლის შეწყვეტის სტატუსის რეგისტრი შეწყვეტის წყაროს სანახავად. ჰოსტს შეუძლია შეწყვეტის ბიტების წაშლა ან შეწყვეტის წყაროს გამორთვა. შეწყვეტის ხაზი აქტიური დარჩება მანამ, სანამ ყველა წყარო არ წაიშლება ან არ გამოირთვება.</p>
<p>არსებობს რამდენიმე სპეციალური შეფერხების წყარო, ასევე ზოგადი დანიშნულების წყაროები. იხილეთ. <code class="docutils literal notranslate"><span class="pre">sdio_slave_hostint_t</span></code> დამატებითი ინფორმაციისთვის.</p>
</div>
</div>
<div class="section" id="shared-registers">
<h3>საერთო რეესტრები<a class="headerlink" href="sdio_slave.html#shared-registers" title="Permalink to this headline">¶</a></h3>
<p>ჰოსტსა და დამხმარე მოწყობილობას შორის ინფორმაციის გასაზიარებლად არსებობს 52 8-ბიტიანი R/W გაზიარებული რეგისტრი. დამხმარე მოწყობილობას შეუძლია რეგისტრების ჩაწერა ან წაკითხვა ნებისმიერ დროს. <code class="docutils literal notranslate"><span class="pre">sdio_slave_read_reg</span></code> და <code class="docutils literal notranslate"><span class="pre">sdio_slave_write_reg</span></code>მასპინძელს შეუძლია რეგისტრზე წვდომა (R/W) CMD52 ან CMD53-ის მეშვეობით.</p>
</div>
<div class="section" id="receiving-fifo">
<h3>FIFO-ს მიღება<a class="headerlink" href="sdio_slave.html#receiving-fifo" title="Permalink to this headline">¶</a></h3>
<p>როდესაც ჰოსტი აპირებს მონასთვის რამდენიმე პაკეტის გაგზავნას, მან უნდა შეამოწმოს, მზადაა თუ არა მონა მისაღებად მონას ბუფერული ნომრის წაკითხვით.</p>
<p>იმისათვის, რომ ჰოსტმა მონაცემები მონისთვის გაგზავნოს, აპლიკაციამ მონური დრაივერისთვის ბუფერები შემდეგი ნაბიჯების მიხედვით უნდა ჩატვირთოს:</p>
<ol class="arabic simple">
<li>ბუფერის რეგისტრაცია დარეკვით <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv_register_buf</span></code>და მიიღეთ რეგისტრირებული ბუფერის სახელური. დრაივერი გამოყოფს მეხსიერებას დაკავშირებული სიის აღმწერისთვის, რომელიც საჭიროა ბუფერის აპარატურაზე დასაკავშირებლად.</li>
<li>ბუფერების დრაივერზე ჩატვირთვა ბუფერის სახელურის გადაცემით <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv_load_buf</span></code>.</li>
<li>ზარი <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv</span></code> მიღებული მონაცემების მისაღებად. თუ საჭიროა არადაბლოკვის ზარი, დააყენეთ <code class="docutils literal notranslate"><span class="pre">wait=0</span></code>.</li>
<li>დამუშავებული ბუფერის სახელური უკან დრაივერს გადაეცით <code class="docutils literal notranslate"><span class="pre">sdio_recv_load_buf</span></code> ისევ.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">მონაცემების კოპირებით გამოწვეული ზედმეტი ხარჯების თავიდან ასაცილებლად, დრაივერს თავად არ აქვს ბუფერი, აპლიკაცია პასუხისმგებელია ახალი ბუფერების დროულად მიწოდებაზე. DMA ავტომატურად შეინახავს მიღებულ მონაცემებს ბუფერში.</p>
</div>
</div>
<div class="section" id="sending-fifo">
<h3>FIFO-ს გაგზავნა<a class="headerlink" href="sdio_slave.html#sending-fifo" title="Permalink to this headline">¶</a></h3>
<p>ყოველ ჯერზე, როდესაც მონას აქვს გასაგზავნი მონაცემები, ის იწვევს შეწყვეტას და მასპინძელი მოითხოვს პაკეტის სიგრძეს. არსებობს გაგზავნის ორი რეჟიმი:</p>
<ul class="simple">
<li>ნაკადის რეჟიმი: როდესაც დრაივერში ბუფერი იტვირთება, ბუფერის სიგრძე ჩაითვლება შემომავალ კომუნიკაციებში მასპინძლის მიერ მოთხოვნილი პაკეტის სიგრძეში. მიუხედავად იმისა, გაიგზავნა თუ არა წინა პაკეტები, ეს ნიშნავს, რომ მასპინძელს შეუძლია ერთი გადაცემისას მიიღოს მონაცემები რამდენიმე ბუფერიდან.</li>
<li>პაკეტის რეჟიმი: პაკეტის სიგრძე განახლდება პაკეტ-პაკეტად და მხოლოდ მაშინ, როდესაც წინა პაკეტი იგზავნება. ეს ნიშნავს, რომ ჰოსტს შეუძლია ერთი გადაცემისას მხოლოდ ერთი ბუფერის მონაცემების მიღება.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">მონაცემების კოპირებით გამოწვეული ზედმეტი ხარჯების თავიდან ასაცილებლად, დრაივერს შიგნით არ აქვს ბუფერი. კერძოდ, DMA მონაცემებს პირდაპირ აპლიკაციის მიერ მოწოდებული ბუფერიდან იღებს. აპლიკაციამ არ უნდა შეეხოს ბუფერს გაგზავნის დასრულებამდე.</p>
</div>
<p>გაგზავნის რეჟიმის დაყენება შესაძლებელია <code class="docutils literal notranslate"><span class="pre">sending_mode</span></code> წევრი <code class="docutils literal notranslate"><span class="pre">sdio_slave_config_t</span></code>და ბუფერული ნომრების დაყენება შესაძლებელია <code class="docutils literal notranslate"><span class="pre">send_queue_size</span></code>ყველა ბუფერის ზომა შეზღუდულია და არ აღემატება 4092 ბაიტს. მიუხედავად იმისა, რომ ნაკადის რეჟიმში ერთ გადაცემაში შესაძლებელია რამდენიმე ბუფერის გაგზავნა, თითოეული ბუფერი მაინც რიგში ერთ ბუფერად ითვლება.</p>
<p>აპლიკაციას შეუძლია დარეკვა <code class="docutils literal notranslate"><span class="pre">sdio_slave_transmit</span></code> პაკეტების გასაგზავნად. ამ შემთხვევაში ფუნქცია ბრუნდება გადაცემის წარმატებით დასრულების შემდეგ, ამიტომ რიგი სრულად არ არის გამოყენებული. როდესაც საჭიროა უფრო მაღალი ეფექტურობა, აპლიკაციას შეუძლია გამოიყენოს შემდეგი ფუნქციები:</p>
<ol class="arabic simple">
<li>ბუფერის ინფორმაციის გადაცემა (მისამართი, სიგრძე და ასევე <code class="docutils literal notranslate"><span class="pre">arg</span></code> ბუფერის მითითებით) <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_queue</span></code>თუ არადაბლოკვის ზარი საჭიროა, დააყენეთ <code class="docutils literal notranslate"><span class="pre">wait=0</span></code>თუ <code class="docutils literal notranslate"><span class="pre">wait</span></code> არ არის <code class="docutils literal notranslate"><span class="pre">portMAX_DELAY</span></code> (დაელოდეთ წარმატებას), აპლიკაციამ უნდა შეამოწმოს შედეგი, რათა იცოდეს, მონაცემები რიგშია მოთავსებული თუ გაუქმებულია.</li>
<li>ზარი <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_get_finished</span></code> დასრულებული გადაცემის მისაღებად და დასამუშავებლად. ბუფერი უნდა შეინახოს უცვლელად დაბრუნებამდე <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_get_finished</span></code>ეს ნიშნავს, რომ ბუფერი რეალურად იგზავნება ჰოსტთან და არა უბრალოდ რიგში რჩება.</li>
</ol>
<p>გამოყენების რამდენიმე გზა არსებობს <code class="docutils literal notranslate"><span class="pre">arg</span></code> რიგის პარამეტრში:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">პირდაპირ მიუთითეთ <code class="docutils literal notranslate"><span class="pre">arg</span></code> დინამიურად გამოყოფილ ბუფერზე და გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">arg</span></code> გადარიცხვის დასრულების შემდეგ მისი გასათავისუფლებლად.</p>
</li>
<li><p class="first">გადარიცხვის ინფორმაციის გადატანა გადარიცხვის სტრუქტურაში და მიუთითეთ <code class="docutils literal notranslate"><span class="pre">arg</span></code> სტრუქტურას. თქვენ შეგიძლიათ გამოიყენოთ სტრუქტურა სხვა ფუნქციების შესასრულებლად, როგორიცაა:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
    <span class="n">uint8_t</span><span class="o">*</span> <span class="n">buffer</span><span class="p">;</span>
    <span class="n">size_t</span>   <span class="n">size</span><span class="p">;</span>
    <span class="nb">int</span>      <span class="nb">id</span><span class="p">;</span>
<span class="p">}</span><span class="n">sdio_transfer_t</span><span class="p">;</span>

<span class="o">//</span><span class="ow">and</span> <span class="n">send</span> <span class="k">as</span><span class="p">:</span>
<span class="n">sdio_transfer_t</span> <span class="n">trans</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">ADDRESS_TO_SEND</span><span class="p">,</span>
    <span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="o">//</span><span class="n">the</span> <span class="mi">3</span><span class="n">rd</span> <span class="n">transfer</span> <span class="n">so</span> <span class="n">far</span>
<span class="p">};</span>
<span class="n">sdio_slave_send_queue</span><span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">buffer</span><span class="p">,</span> <span class="n">trans</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">trans</span><span class="p">,</span> <span class="n">portMAX_DELAY</span><span class="p">);</span>

<span class="o">//...</span> <span class="n">maybe</span> <span class="n">more</span> <span class="n">transfers</span> <span class="n">are</span> <span class="n">sent</span> <span class="n">here</span>

<span class="o">//</span><span class="ow">and</span> <span class="n">deal</span> <span class="k">with</span> <span class="n">finished</span> <span class="n">transfer</span> <span class="k">as</span><span class="p">:</span>
<span class="n">sdio_transfer_t</span><span class="o">*</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="n">sdio_slave_send_get_finished</span><span class="p">((</span><span class="n">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="n">portMAX_DELAY</span><span class="p">);</span>
<span class="n">ESP_LOGI</span><span class="p">(</span><span class="s2">"tag"</span><span class="p">,</span> <span class="s2">"(</span><span class="si">%d</span><span class="s2">) successfully send </span><span class="si">%d</span><span class="s2"> bytes of %p"</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="nb">id</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">arg</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">);</span>
<span class="n">some_post_callback</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <span class="o">//</span><span class="n">do</span> <span class="n">more</span> <span class="n">things</span>
</pre></div>
</div>
</li>
<li><p class="first">ამ დრაივერის მიმღებ ნაწილთან მუშაობა, წერტილი <code class="docutils literal notranslate"><span class="pre">arg</span></code> ამ ბუფერის მიმღები ბუფერის სახელურზე. რათა ჩვენ შევძლოთ ბუფერის პირდაპირ გამოყენება მონაცემების მისაღებად მათი გაგზავნის შემდეგ:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uint8_t</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">};</span>
<span class="n">sdio_slave_buf_handle_t</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">sdio_slave_recv_register_buf</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="n">sdio_slave_send_queue</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">portMAX_DELAY</span><span class="p">);</span>

<span class="o">//...</span> <span class="n">maybe</span> <span class="n">more</span> <span class="n">transfers</span> <span class="n">are</span> <span class="n">sent</span> <span class="n">here</span>

<span class="o">//</span><span class="ow">and</span> <span class="n">load</span> <span class="n">finished</span> <span class="n">buffer</span> <span class="n">to</span> <span class="n">receive</span> <span class="k">as</span>
<span class="n">sdio_slave_buf_handle_t</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="n">sdio_slave_send_get_finished</span><span class="p">((</span><span class="n">void</span><span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">portMAX_DELAY</span><span class="p">);</span>
<span class="n">sdio_slave_recv_load_buf</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</pre></div>
</div>
<p>მეტი ამის შესახებ, იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/peripherals/sdio">პერიფერიული მოწყობილობები/სდიო</a>.</p>
</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="application-example">
<h2>განაცხადის მაგალითი<a class="headerlink" href="sdio_slave.html#application-example" title="Permalink to this headline">¶</a></h2>
<p>მონა/ბატონის კომუნიკაცია: <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/peripherals/sdio">პერიფერიული მოწყობილობები/სდიო</a>.</p>
</div>
<div class="section" id="api-reference">
<h2>API მითითება<a class="headerlink" href="sdio_slave.html#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="sdio_slave.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/soc/include/hal/sdio_slave_types.h">soc/include/hal/sdio_slave_types.h</a></li>
</ul>
</div>
<div class="section" id="enumerations">
<h3>ჩამოთვლები<a class="headerlink" href="sdio_slave.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv420sdio_slave_hostint_t">
<span id="_CPPv320sdio_slave_hostint_t"></span><span id="_CPPv220sdio_slave_hostint_t"></span><span id="sdio_slave_hostint_t"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15f"></span><em class="property">ჩამოთვლა </em><code class="descname">sdio_slave_hostint_t</code><a class="headerlink" href="sdio_slave.html#_CPPv420sdio_slave_hostint_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჰოსტისთვის გაგზავნილი შეფერხებების ნიღაბი. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT0">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT0"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT0"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fac27ebe2c7f769c2d054867bd8531ffb0"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT0</code> = BIT(0)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT0" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ზოგადი დანიშნულების შეწყვეტის ბიტი 0. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT1">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT1"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT1"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fa91eadb47c4350f572ccdb94c4b0b783b"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT1</code> = BIT(1)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT1" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT2">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT2"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT2"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fa8d4815070c473a71e8107451f087aef8"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT2</code> = BIT(2)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT2" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT3">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT3"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT3"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fab5e2a42da9a5eb2f7eb7edfa414cec77"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT3</code> = BIT(3)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT3" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT4">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT4"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT4"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fa2e1b580b41f45f9c80dfd69554bec842"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT4</code> = BIT(4)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT4" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT5">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT5"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT5"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15faacf4fd7360e94235812d461ad013f2c1"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT5</code> = BIT(5)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT5" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT6">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT6"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT6"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fae99e454bc071576e7c6d3205b3471059"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT6</code> = BIT(6)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT6" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SDIO_SLAVE_HOSTINT_BIT7">
<span id="_CPPv323SDIO_SLAVE_HOSTINT_BIT7"></span><span id="_CPPv223SDIO_SLAVE_HOSTINT_BIT7"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fa855d4c9205f4ac47483994e8822a9a89"></span><code class="descname">SDIO_SLAVE_HOSTINT_BIT7</code> = BIT(7)<a class="headerlink" href="sdio_slave.html#_CPPv423SDIO_SLAVE_HOSTINT_BIT7" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv434SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET">
<span id="_CPPv334SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET"></span><span id="_CPPv234SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET"></span><span class="target" id="sdio__slave__types_8h_1a41019a6697bec3addbe2f5452772e15fa1c51d3682b4d6fc3fd5c4daef60e7273"></span><code class="descname">SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET</code> = BIT(23)<a class="headerlink" href="sdio_slave.html#_CPPv434SDIO_SLAVE_HOSTINT_SEND_NEW_PACKET" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ახალი პაკეტი ხელმისაწვდომია. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv419sdio_slave_timing_t">
<span id="_CPPv319sdio_slave_timing_t"></span><span id="_CPPv219sdio_slave_timing_t"></span><span id="sdio_slave_timing_t"></span><span class="target" id="sdio__slave__types_8h_1a73c02c776695fa09298aa124eb8347fd"></span><em class="property">ჩამოთვლა </em><code class="descname">sdio_slave_timing_t</code><a class="headerlink" href="sdio_slave.html#_CPPv419sdio_slave_timing_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SDIO მონა-მონაწილის დრო. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv431SDIO_SLAVE_TIMING_PSEND_PSAMPLE">
<span id="_CPPv331SDIO_SLAVE_TIMING_PSEND_PSAMPLE"></span><span id="_CPPv231SDIO_SLAVE_TIMING_PSEND_PSAMPLE"></span><span class="target" id="sdio__slave__types_8h_1a73c02c776695fa09298aa124eb8347fda9396369e0b181c649b35d5d05732d9b9"></span><code class="descname">SDIO_SLAVE_TIMING_PSEND_PSAMPLE</code> = 0<a class="headerlink" href="sdio_slave.html#_CPPv431SDIO_SLAVE_TIMING_PSEND_PSAMPLE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნა posedge-ზე და ნიმუშის აღება posedge-ზე. HS რეჟიმისთვის ნაგულისხმევი მნიშვნელობა. ჩვეულებრივ, DS რეჟიმში მუშაობისას ამის გამოყენება პრობლემას არ წარმოადგენს. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431SDIO_SLAVE_TIMING_NSEND_PSAMPLE">
<span id="_CPPv331SDIO_SLAVE_TIMING_NSEND_PSAMPLE"></span><span id="_CPPv231SDIO_SLAVE_TIMING_NSEND_PSAMPLE"></span><span class="target" id="sdio__slave__types_8h_1a73c02c776695fa09298aa124eb8347fdaac8256dad07f55a9726159d4cd9ae435"></span><code class="descname">SDIO_SLAVE_TIMING_NSEND_PSAMPLE</code><a class="headerlink" href="sdio_slave.html#_CPPv431SDIO_SLAVE_TIMING_NSEND_PSAMPLE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნა negedge-ზე და ნიმუშის აღება posedge-ზე. ნაგულისხმევი მნიშვნელობა DS რეჟიმისთვის და უფრო დაბალი მაჩვენებლებისთვის. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431SDIO_SLAVE_TIMING_PSEND_NSAMPLE">
<span id="_CPPv331SDIO_SLAVE_TIMING_PSEND_NSAMPLE"></span><span id="_CPPv231SDIO_SLAVE_TIMING_PSEND_NSAMPLE"></span><span class="target" id="sdio__slave__types_8h_1a73c02c776695fa09298aa124eb8347fda89b7242cadb1b87b48f7839471689b7b"></span><code class="descname">SDIO_SLAVE_TIMING_PSEND_NSAMPLE</code><a class="headerlink" href="sdio_slave.html#_CPPv431SDIO_SLAVE_TIMING_PSEND_NSAMPLE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნეთ პოსეჯში, ხოლო ნიმუში ნეგეჯში. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431SDIO_SLAVE_TIMING_NSEND_NSAMPLE">
<span id="_CPPv331SDIO_SLAVE_TIMING_NSEND_NSAMPLE"></span><span id="_CPPv231SDIO_SLAVE_TIMING_NSEND_NSAMPLE"></span><span class="target" id="sdio__slave__types_8h_1a73c02c776695fa09298aa124eb8347fdadc3005a6aafab14145f578b09088b7a9"></span><code class="descname">SDIO_SLAVE_TIMING_NSEND_NSAMPLE</code><a class="headerlink" href="sdio_slave.html#_CPPv431SDIO_SLAVE_TIMING_NSEND_NSAMPLE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნეთ ნეგეჯში და ნიმუშიც ნეგეჯში. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv425sdio_slave_sending_mode_t">
<span id="_CPPv325sdio_slave_sending_mode_t"></span><span id="_CPPv225sdio_slave_sending_mode_t"></span><span id="sdio_slave_sending_mode_t"></span><span class="target" id="sdio__slave__types_8h_1a6251a813d056e685b1fc40b5e52ecc9b"></span><em class="property">ჩამოთვლა </em><code class="descname">sdio_slave_sending_mode_t</code><a class="headerlink" href="sdio_slave.html#_CPPv425sdio_slave_sending_mode_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SDIO მონა რეჟიმის კონფიგურაცია. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv422SDIO_SLAVE_SEND_STREAM">
<span id="_CPPv322SDIO_SLAVE_SEND_STREAM"></span><span id="_CPPv222SDIO_SLAVE_SEND_STREAM"></span><span class="target" id="sdio__slave__types_8h_1a6251a813d056e685b1fc40b5e52ecc9bac833041a84c2747660cfd98a5d89f212"></span><code class="descname">SDIO_SLAVE_SEND_STREAM</code> = 0<a class="headerlink" href="sdio_slave.html#_CPPv422SDIO_SLAVE_SEND_STREAM" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ნაკადის რეჟიმში, გასაგზავნი ყველა პაკეტი, თუ შესაძლებელია, ერთ პაკეტად გაერთიანდება. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv422SDIO_SLAVE_SEND_PACKET">
<span id="_CPPv322SDIO_SLAVE_SEND_PACKET"></span><span id="_CPPv222SDIO_SLAVE_SEND_PACKET"></span><span class="target" id="sdio__slave__types_8h_1a6251a813d056e685b1fc40b5e52ecc9bab7e85edf6ae78881205a49d947840c5f"></span><code class="descname">SDIO_SLAVE_SEND_PACKET</code> = 1<a class="headerlink" href="sdio_slave.html#_CPPv422SDIO_SLAVE_SEND_PACKET" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პაკეტების რეჟიმში, ერთი პაკეტი გაიგზავნება ერთმანეთის მიყოლებით (packet_len-ის გაზრდა მხოლოდ იმ შემთხვევაში, თუ ბოლო პაკეტი გაიგზავნა). </p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="id2">
<h3>სათაურის ფაილი<a class="headerlink" href="sdio_slave.html#id2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/driver/include/driver/sdio_slave.h">დრაივერი/include/driver/sdio_slave.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="sdio_slave.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv421sdio_slave_initializeP19sdio_slave_config_t">
<span id="_CPPv321sdio_slave_initializeP19sdio_slave_config_t"></span><span id="_CPPv221sdio_slave_initializeP19sdio_slave_config_t"></span><span id="sdio_slave_initialize__sdio_slave_config_tP"></span><span class="target" id="sdio__slave_8h_1ad19a66725e9863a941f9d4bed057dabc"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_initialize</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv419sdio_slave_config_t" title="sdio_slave_config_t">sdio_slave_config_t</a> *<em>კონფიგურაცია</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv421sdio_slave_initializeP19sdio_slave_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>sdio-ს მოკავშირე დრაივერის ინიციალიზაცია</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_NOT_FOUND, თუ თავისუფალი შეფერხება არ არის ნაპოვნი.</li>
<li>ESP_ERR_INVALID_STATE, თუ უკვე ინიციალიზებულია.</li>
<li>ESP_ERR_NO_MEM, თუ მეხსიერების გამოყოფის გამო შეცდომა მოხდა.</li>
<li>ESP_OK წარმატების შემთხვევაში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">config</span></code>sdio-ს დაქვემდებარებული დრაივერის კონფიგურაცია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417sdio_slave_deinitv">
<span id="_CPPv317sdio_slave_deinitv"></span><span id="_CPPv217sdio_slave_deinitv"></span><span id="sdio_slave_deinit__void"></span><span class="target" id="sdio__slave_8h_1a8ad6cd2ff0b723980b455309486d74c2"></span>void <code class="descname">sdio_slave_deinit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv417sdio_slave_deinitv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რესურსების გასათავისუფლებლად მოახდინეთ sdio-ს ქვედა დრაივერის დეინიციალიზაცია. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416sdio_slave_startv">
<span id="_CPPv316sdio_slave_startv"></span><span id="_CPPv216sdio_slave_startv"></span><span id="sdio_slave_start__void"></span><span class="target" id="sdio__slave_8h_1a47a63fae917f65e1b27065991f5c65b9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_start</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv416sdio_slave_startv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩართეთ გაგზავნისა და მიღების აპარატურა, ასევე დააყენეთ IOREADY1 1-ზე.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>The driver will continue sending from previous data and PKT_LEN counting, keep data received as well as start receiving from current TOKEN1 counting. See <code class="docutils literal notranslate"><span class="pre">sdio_slave_reset</span></code>.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_STATE, თუ უკვე დაწყებულია.</li>
<li>სხვა შემთხვევაში ESP_OK. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415sdio_slave_stopv">
<span id="_CPPv315sdio_slave_stopv"></span><span id="_CPPv215sdio_slave_stopv"></span><span id="sdio_slave_stop__void"></span><span class="target" id="sdio__slave_8h_1a203fd879a79bcf173d4e7f3626e4a454"></span>void <code class="descname">sdio_slave_stop</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv415sdio_slave_stopv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აპარატურის გაგზავნისა და მიღების შეჩერებისთვის, ასევე დააყენეთ IOREADY1 0-ზე.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>this will not clear the data already in the driver, and also not reset the PKT_LEN and TOKEN1 counting. Call <code class="docutils literal notranslate"><span class="pre">sdio_slave_reset</span></code> to do that. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416sdio_slave_resetv">
<span id="_CPPv316sdio_slave_resetv"></span><span id="_CPPv216sdio_slave_resetv"></span><span id="sdio_slave_reset__void"></span><span class="target" id="sdio__slave_8h_1a7481e121623651af93f9ecf467cf030c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_reset</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv416sdio_slave_resetv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დრაივერში არსებული მონაცემების გასუფთავება და PKT_LEN-ისა და TOKEN1-ის დათვლის გადატვირთვა.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>always return ESP_OK. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428sdio_slave_recv_register_bufP7uint8_t">
<span id="_CPPv328sdio_slave_recv_register_bufP7uint8_t"></span><span id="_CPPv228sdio_slave_recv_register_bufP7uint8_t"></span><span id="sdio_slave_recv_register_buf__uint8_tP"></span><span class="target" id="sdio__slave_8h_1aa10889fd95f21e1d904e6ecaa80a4972"></span><a class="reference internal" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="sdio_slave_buf_handle_t">sdio_slave_buf_handle_t</a> <code class="descname">sdio_slave_recv_register_buf</code><span class="sig-paren">(</span>uint8_t *<em>დაწყება</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv428sdio_slave_recv_register_bufP7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიღებისთვის გამოყენებული რეგისტრის ბუფერი. ყველა ბუფერი გამოყენებამდე უნდა დარეგისტრირდეს და შემდეგ მათი (ისევ) გამოყენება დრაივერში დაბრუნებული ჰენდის მეშვეობით იქნება შესაძლებელი.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>The driver will use and only use the amount of space specified in the <code class="docutils literal notranslate"><span class="pre">recv_buffer_size</span></code> member set in the <code class="docutils literal notranslate"><a class="reference internal" href="sdio_slave.html#structsdio__slave__config__t"><span class="std std-ref"><span class="pre">sdio_slave_config_t</span></span></a></code>. All buffers should be larger than that. The buffer is used by the DMA, so it should be DMA capable and 32-bit aligned.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>The buffer handle if success, otherwise NULL. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>ბუფერის საწყისი მისამართი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430sdio_slave_recv_unregister_buf23sdio_slave_buf_handle_t">
<span id="_CPPv330sdio_slave_recv_unregister_buf23sdio_slave_buf_handle_t"></span><span id="_CPPv230sdio_slave_recv_unregister_buf23sdio_slave_buf_handle_t"></span><span id="sdio_slave_recv_unregister_buf__sdio_slave_buf_handle_t"></span><span class="target" id="sdio__slave_8h_1af71d22478666d1cbfe7fd2c8ebf38576"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_recv_unregister_buf</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="sdio_slave_buf_handle_t">sdio_slave_buf_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv430sdio_slave_recv_unregister_buf23sdio_slave_buf_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დრაივერიდან ბუფერის რეგისტრაციის გაუქმება და ბუფერზე მითითებით აღმწერის მიერ გამოყენებული სივრცის გათავისუფლება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK if success, ESP_ERR_INVALID_ARG if the handle is NULL or the buffer is being used. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>გასათავისუფლებლად ბუფერთან სახელური გამოიყენეთ.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424sdio_slave_recv_load_buf23sdio_slave_buf_handle_t">
<span id="_CPPv324sdio_slave_recv_load_buf23sdio_slave_buf_handle_t"></span><span id="_CPPv224sdio_slave_recv_load_buf23sdio_slave_buf_handle_t"></span><span id="sdio_slave_recv_load_buf__sdio_slave_buf_handle_t"></span><span class="target" id="sdio__slave_8h_1adfe5f43f22c576e811a9ea3789bddfb8"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_recv_load_buf</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="sdio_slave_buf_handle_t">sdio_slave_buf_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv424sdio_slave_recv_load_buf23sdio_slave_buf_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ბუფერის ჩატვირთვა მონაცემების მიღების მოლოდინში მყოფ რიგში. დრაივერი იღებს ბუფერის საკუთრებას მანამ, სანამ ბუფერი არ დაბრუნდება <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_get_finished</span></code> ტრანზაქციის დასრულების შემდეგ.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG თუ არასწორი სახელური ან ბუფერი უკვე რიგშია. მხოლოდ მას შემდეგ, რაც ბუფერი დაბრუნდება <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv</span></code> შეგიძლიათ ხელახლა ატვირთოთ.</li>
<li>ESP_OK წარმატების შემთხვევაში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: მონაცემთა მისაღებად მზად ბუფერზე გადაყვანა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415sdio_slave_recvP23sdio_slave_buf_handle_tPP7uint8_tP6size_t10TickType_t">
<span id="_CPPv315sdio_slave_recvP23sdio_slave_buf_handle_tPP7uint8_tP6size_t10TickType_t"></span><span id="_CPPv215sdio_slave_recvP23sdio_slave_buf_handle_tPP7uint8_tP6size_t10TickType_t"></span><span id="sdio_slave_recv__sdio_slave_buf_handle_tP.uint8_tPP.sP.TickType_t"></span><span class="target" id="sdio__slave_8h_1a619f162c33e0189aff7b33bdaea97306"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_recv</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="sdio_slave_buf_handle_t">sdio_slave_buf_handle_t</a> *<em>სახელური_დაბრუნება</em>, uint8_t **<em>out_addr</em>, size_t *<em>გარეთ_ლენი</em>, TickType_t <em>ლოდინი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv415sdio_slave_recvP23sdio_slave_buf_handle_tPP7uint8_tP6size_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიღებული მონაცემების მიღება, თუ ისინი არსებობს. დრაივერი აპლიკაციას ბუფერის საკუთრებას უბრუნებს.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Call <code class="docutils literal notranslate"><span class="pre">sdio_slave_load_buf</span></code> with the handle to re-load the buffer onto the link list, and receive with the same buffer again. The address and length of the buffer got here is the same as got from <code class="docutils literal notranslate"><span class="pre">sdio_slave_get_buffer</span></code>.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG თუ handle_ret არის NULL</li>
<li>ESP_ERR_TIMEOUT თუ ახალი მონაცემების მიღებამდე ვადა ამოიწურა</li>
<li>ESP_OK წარმატების შემთხვევაში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle_ret</span></code>: მიღებული მონაცემების შემცველი ბუფერის სახელური. გამოიყენეთ ეს სახელური <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv_load_buf</span></code> რომ ისევ იმავე ბუფერში მიიღოს. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_addr</span></code>საწყისი მისამართის გამომავალი, დაყენებულია NULL-ზე, თუ საჭირო არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_len</span></code>ბუფერში მონაცემების ფაქტობრივი სიგრძე, დაყენებულია NULL-ზე, თუ საჭირო არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait</span></code>მონაცემების მიღებამდე დროა დაველოდოთ.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423sdio_slave_recv_get_buf23sdio_slave_buf_handle_tP6size_t">
<span id="_CPPv323sdio_slave_recv_get_buf23sdio_slave_buf_handle_tP6size_t"></span><span id="_CPPv223sdio_slave_recv_get_buf23sdio_slave_buf_handle_tP6size_t"></span><span id="sdio_slave_recv_get_buf__sdio_slave_buf_handle_t.sP"></span><span class="target" id="sdio__slave_8h_1a1de241ef3dd1d90b39d08a43045ea7bf"></span>uint8_t *<code class="descname">sdio_slave_recv_get_buf</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="sdio_slave_buf_handle_t">sdio_slave_buf_handle_t</a> <em>სახელური</em>, size_t *<em>ლენ_ო</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv423sdio_slave_recv_get_buf23sdio_slave_buf_handle_tP6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოიძიეთ სახელურის შესაბამისი ბუფერი.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>buffer address if success, otherwise NULL. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: სახელური ბუფერის მისაღებად. </li>
<li><code class="docutils literal notranslate"><span class="pre">len_o</span></code>ბუფერის სიგრძის გამომავალი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv421sdio_slave_send_queueP7uint8_t6size_tPv10TickType_t">
<span id="_CPPv321sdio_slave_send_queueP7uint8_t6size_tPv10TickType_t"></span><span id="_CPPv221sdio_slave_send_queueP7uint8_t6size_tPv10TickType_t"></span><span id="sdio_slave_send_queue__uint8_tP.s.voidP.TickType_t"></span><span class="target" id="sdio__slave_8h_1a0b7744c195b2ec6a8af0b4866ba4cca7"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_send_queue</code><span class="sig-paren">(</span>uint8_t *<em>მისამართი</em>, size_t <em>ლენ</em>, void *<em>არგუმენტი</em>, TickType_t <em>ლოდინი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv421sdio_slave_send_queueP7uint8_t6size_tPv10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნის რიგში ახალი გაგზავნის გადაცემის განთავსება. დრაივერი იღებს ბუფერის მფლობელობას მანამ, სანამ ბუფერი არ დაბრუნდება. <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_get_finished</span></code> ტრანზაქციის დასრულების შემდეგ.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG, თუ სიგრძე 0-ზე მეტი არ არის.</li>
<li>ESP_ERR_TIMEOUT, თუ რიგი კვლავ სავსეა ვადის ამოწურვამდე.</li>
<li>ESP_OK წარმატების შემთხვევაში. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: მისამართი გასაგზავნი მონაცემებისთვის. ბუფერი უნდა იყოს DMA-სთან თავსებადი და 32-ბიტიანი. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>მონაცემების სიგრძე არ უნდა აღემატებოდეს 4092 ბაიტს (შესაძლოა მომავალში უფრო დიდი სიგრძე იყოს მხარდაჭერილი). </li>
<li><code class="docutils literal notranslate"><span class="pre">arg</span></code>: დასაბრუნებელი არგუმენტი <code class="docutils literal notranslate"><span class="pre">sdio_slave_send_get_finished</span></code>არგუმენტის გამოყენება შესაძლებელია იმის მითითებისთვის, თუ რომელი ტრანზაქცია დასრულდა, ან როგორც პარამეტრი უკუკავშირისთვის. დააყენეთ NULL-ზე, თუ საჭირო არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait</span></code>: თუ ბუფერი სავსეა, ლოდინის დროა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428sdio_slave_send_get_finishedPPv10TickType_t">
<span id="_CPPv328sdio_slave_send_get_finishedPPv10TickType_t"></span><span id="_CPPv228sdio_slave_send_get_finishedPPv10TickType_t"></span><span id="sdio_slave_send_get_finished__voidPP.TickType_t"></span><span class="target" id="sdio__slave_8h_1a352925cbc8f60c2f9adfb3cd5872631b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_send_get_finished</code><span class="sig-paren">(</span>void **<em>out_arg</em>, TickType_t <em>ლოდინი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv428sdio_slave_send_get_finishedPPv10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დასრულებული ტრანზაქციის საკუთრების დაბრუნება. <dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_ERR_TIMEOUT if no transaction finished, or ESP_OK if succeed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">out_arg</span></code>დასრულებული ტრანზაქციის არგუმენტი. თუ არ გამოიყენება, დააყენეთ NULL-ზე. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait</span></code>: თუ გაგზავნის ტრანზაქცია არ დასრულებულა, ლოდინის დროა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419sdio_slave_transmitP7uint8_t6size_t">
<span id="_CPPv319sdio_slave_transmitP7uint8_t6size_t"></span><span id="_CPPv219sdio_slave_transmitP7uint8_t6size_t"></span><span id="sdio_slave_transmit__uint8_tP.s"></span><span class="target" id="sdio__slave_8h_1ab27f74045c6c0bbcb1ff31cc7b15e830"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_transmit</code><span class="sig-paren">(</span>uint8_t *<em>მისამართი</em>, size_t <em>ლენ</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv419sdio_slave_transmitP7uint8_t6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაიწყეთ ახალი გადარიცხვა და დაელოდეთ მის (დაბლოკვის) დასრულებას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG, თუ აღმწერის სიგრძე 0-ზე მეტი არ არის.</li>
<li>ESP_ERR_TIMEOUT, თუ რიგი სავსეა ან ჰოსტი არ იწყებს გადაცემას ვადის ამოწურვამდე.</li>
<li>ESP_OK წარმატების შემთხვევაში. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>გასაგზავნი ბუფერის საწყისი მისამართი </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>: გასაგზავნი ბუფერის სიგრძე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419sdio_slave_read_regi">
<span id="_CPPv319sdio_slave_read_regi"></span><span id="_CPPv219sdio_slave_read_regi"></span><span id="sdio_slave_read_reg__i"></span><span class="target" id="sdio__slave_8h_1aacfaf655c1f60adb6aafde98789e8f2e"></span>uint8_t <code class="descname">sdio_slave_read_reg</code><span class="sig-paren">(</span>int <em>პოზიცია</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv419sdio_slave_read_regi" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ მასპინძელთან გაზიარებული spi slave რეესტრი.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>register 28 to 31 are reserved for interrupt vector.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>value of the register. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pos</span></code>: რეგისტრაციის მისამართი, 0-27 ან 32-63.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420sdio_slave_write_regi7uint8_t">
<span id="_CPPv320sdio_slave_write_regi7uint8_t"></span><span id="_CPPv220sdio_slave_write_regi7uint8_t"></span><span id="sdio_slave_write_reg__i.uint8_t"></span><span class="target" id="sdio__slave_8h_1a348dc68cf2127918f0e51b95f7d4ecc5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_write_reg</code><span class="sig-paren">(</span>int <em>პოზიცია</em>, uint8_t <em>რეგ</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv420sdio_slave_write_regi7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩაწერეთ ჰოსტთან გაზიარებული spi slave რეგისტრი.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>register 29 and 31 are used for interrupt vector.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_ERR_INVALID_ARG if address wrong, otherwise ESP_OK. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pos</span></code>: რეგისტრაციის მისამართი, 0-11, 14-15, 18-19, 24-27 და 32-63, სხვა მისამართები დაჯავშნილია. </li>
<li><code class="docutils literal notranslate"><span class="pre">reg</span></code>: ჩაწერის ღირებულება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426sdio_slave_get_host_intenav">
<span id="_CPPv326sdio_slave_get_host_intenav"></span><span id="_CPPv226sdio_slave_get_host_intenav"></span><span id="sdio_slave_get_host_intena__void"></span><span class="target" id="sdio__slave_8h_1aaeb6e7852a23c667bd0f9b8e64685ca3"></span><a class="reference internal" href="sdio_slave.html#_CPPv420sdio_slave_hostint_t" title="sdio_slave_hostint_t">sdio_slave_hostint_t</a> <code class="descname">sdio_slave_get_host_intena</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv426sdio_slave_get_host_intenav" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მასპინძლისთვის შეწყვეტის ჩართვა.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>the interrupt mask. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426sdio_slave_set_host_intena20sdio_slave_hostint_t">
<span id="_CPPv326sdio_slave_set_host_intena20sdio_slave_hostint_t"></span><span id="_CPPv226sdio_slave_set_host_intena20sdio_slave_hostint_t"></span><span id="sdio_slave_set_host_intena__sdio_slave_hostint_t"></span><span class="target" id="sdio__slave_8h_1a870a9f45d3d98063b06846db325e6fc2"></span>void <code class="descname">sdio_slave_set_host_intena</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv420sdio_slave_hostint_t" title="sdio_slave_hostint_t">sdio_slave_hostint_t</a> <em>ნიღაბი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv426sdio_slave_set_host_intena20sdio_slave_hostint_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მასპინძლისთვის შეფერხების ჩართვის დაყენება.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">mask</span></code>: მასპინძლის შეფერხებისთვის ნიღბის ჩართვა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424sdio_slave_send_host_int7uint8_t">
<span id="_CPPv324sdio_slave_send_host_int7uint8_t"></span><span id="_CPPv224sdio_slave_send_host_int7uint8_t"></span><span id="sdio_slave_send_host_int__uint8_t"></span><span class="target" id="sdio__slave_8h_1a0857770ed98aa745f9d6ac0754e14be4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_send_host_int</code><span class="sig-paren">(</span>uint8_t <em>პოზიცია</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv424sdio_slave_send_host_int7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მასპინძლის შეწყვეტა ზოგადი დანიშნულების შეწყვეტით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG თუ შეწყვეტის ნომრის შეცდომაა</li>
<li>სხვა შემთხვევაში ESP_OK </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pos</span></code>შეწყვეტის ნომერი, 0-7.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425sdio_slave_clear_host_int20sdio_slave_hostint_t">
<span id="_CPPv325sdio_slave_clear_host_int20sdio_slave_hostint_t"></span><span id="_CPPv225sdio_slave_clear_host_int20sdio_slave_hostint_t"></span><span id="sdio_slave_clear_host_int__sdio_slave_hostint_t"></span><span class="target" id="sdio__slave_8h_1a786abaeab087ab38d912218f45b07c6a"></span>void <code class="descname">sdio_slave_clear_host_int</code><span class="sig-paren">(</span><a class="reference internal" href="sdio_slave.html#_CPPv420sdio_slave_hostint_t" title="sdio_slave_hostint_t">sdio_slave_hostint_t</a> <em>ნიღაბი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv425sdio_slave_clear_host_int20sdio_slave_hostint_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჰოსტისთვის ზოგადი დანიშნულების შეფერხების გასუფთავება.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">mask</span></code>ბიტების გასუფთავება შეფერხებულია ბიტის ნიღბით. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419sdio_slave_wait_inti10TickType_t">
<span id="_CPPv319sdio_slave_wait_inti10TickType_t"></span><span id="_CPPv219sdio_slave_wait_inti10TickType_t"></span><span id="sdio_slave_wait_int__i.TickType_t"></span><span class="target" id="sdio__slave_8h_1ab447edce2cb6ac960bda3e83f4c2938e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">sdio_slave_wait_int</code><span class="sig-paren">(</span>int <em>პოზიცია</em>, TickType_t <em>ლოდინი</em><span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv419sdio_slave_wait_inti10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაელოდეთ ჰოსტისგან ზოგადი დანიშნულების შეწყვეტას.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>this clears the interrupt at the same time.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK if success, ESP_ERR_TIMEOUT if timeout. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pos</span></code>: დაყენებულია შეწყვეტის წყაროს ნომერი, რომელსაც უნდა ელოდოთ. </li>
<li><code class="docutils literal notranslate"><span class="pre">wait</span></code>: შეფერხების გააქტიურებამდე ლოდინის დროა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="sdio_slave.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv419sdio_slave_config_t">
<span id="_CPPv319sdio_slave_config_t"></span><span id="_CPPv219sdio_slave_config_t"></span><span id="sdio_slave_config_t"></span><span class="target" id="structsdio__slave__config__t"></span><em class="property">სტრუქტურა </em><code class="descname">sdio_slave_config_t</code><a class="headerlink" href="sdio_slave.html#_CPPv419sdio_slave_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SDIO მონა-მოთამაშის კონფიგურაცია. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t6timingE">
<span id="_CPPv3N19sdio_slave_config_t6timingE"></span><span id="_CPPv2N19sdio_slave_config_t6timingE"></span><span id="sdio_slave_config_t::timing__sdio_slave_timing_t"></span><span class="target" id="structsdio__slave__config__t_1afa759d1cb5c96beec444b1e6349a53fb"></span><a class="reference internal" href="sdio_slave.html#_CPPv419sdio_slave_timing_t" title="sdio_slave_timing_t">sdio_slave_time_t</a> <code class="descname">timing</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t6timingE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>sdio_slave-ის დროის განსაზღვრა. იხილეთ <code class="docutils literal notranslate"><span class="pre">sdio_slave_timing_t</span></code>. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t12sending_modeE">
<span id="_CPPv3N19sdio_slave_config_t12sending_modeE"></span><span id="_CPPv2N19sdio_slave_config_t12sending_modeE"></span><span id="sdio_slave_config_t::sending_mode__sdio_slave_sending_mode_t"></span><span class="target" id="structsdio__slave__config__t_1a6a445be0028999519e09744cb9377292"></span><a class="reference internal" href="sdio_slave.html#_CPPv425sdio_slave_sending_mode_t" title="sdio_slave_sending_mode_t">sdio_slave_sending_mode_t</a> <code class="descname">sending_mode</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t12sending_modeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>sdio_slave-ის რეჟიმი. <code class="docutils literal notranslate"><span class="pre">SDIO_SLAVE_MODE_STREAM</span></code> თუ საჭიროა მონაცემების რაც შეიძლება მეტი რაოდენობის გაგზავნა; <code class="docutils literal notranslate"><span class="pre">SDIO_SLAVE_MODE_PACKET</span></code> თუ მონაცემები პაკეტებად უნდა გაიგზავნოს. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t15send_queue_sizeE">
<span id="_CPPv3N19sdio_slave_config_t15send_queue_sizeE"></span><span id="_CPPv2N19sdio_slave_config_t15send_queue_sizeE"></span><span id="sdio_slave_config_t::send_queue_size__i"></span><span class="target" id="structsdio__slave__config__t_1a7a89728e19f6159b6e38a3935af995b5"></span>int <code class="descname">send_queue_size</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t15send_queue_sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მაქსიმალური ბუფერები, რომელთა რიგში განთავსებაც შესაძლებელია გაგზავნამდე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t16recv_buffer_sizeE">
<span id="_CPPv3N19sdio_slave_config_t16recv_buffer_sizeE"></span><span id="_CPPv2N19sdio_slave_config_t16recv_buffer_sizeE"></span><span id="sdio_slave_config_t::recv_buffer_size__s"></span><span class="target" id="structsdio__slave__config__t_1aa2966f45b3a59ebc242e92503c751299"></span>size_t <code class="descname">recv_buffer_size</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t16recv_buffer_sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>თუ buffer_size ძალიან პატარაა, ბუფერების დიდი რაოდენობის დამუშავებას CPU-ს მეტი დრო დასჭირდება. თუ buffer_size ძალიან დიდია, ტრანზაქციის სიგრძეზე დიდი სივრცე ცარიელი დარჩება, მაგრამ მაინც ბუფერს ჩაითვლება და ბუფერები ადვილად ივსება. ეს პარამეტრი უნდა დაყენდეს რეალურად გადაცემული მონაცემების სიგრძის მიხედვით. ყველა მონაცემი, რომელიც სრულად არ ავსებს ბუფერს, მაინც ერთ ბუფერად ჩაითვლება. მაგალითად, 10 ბაიტიანი მონაცემები 2 ბუფერს უდრის, თუ ზომა 8 ბაიტია თითო ბუფერზე. მონა-მოთამაშის ბუფერის ზომა წინასწარ განსაზღვრულია მასპინძელსა და მონა-მოთამაშეს შორის კომუნიკაციამდე. დრაივერისთვის გადაცემული ყველა მიმღები ბუფერი ამაზე დიდი უნდა იყოს. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t8event_cbE">
<span id="_CPPv3N19sdio_slave_config_t8event_cbE"></span><span id="_CPPv2N19sdio_slave_config_t8event_cbE"></span><span id="sdio_slave_config_t::event_cb__sdio_event_cb_t"></span><span class="target" id="structsdio__slave__config__t_1aef7513d4607505c18a7795b76ea3c832"></span><a class="reference internal" href="sdio_slave.html#_CPPv415sdio_event_cb_t" title="sdio_event_cb_t">sdio_event_cb_t</a> <code class="descname">event_cb</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t8event_cbE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>როდესაც ჰოსტი წყვეტს მონასთან მუშაობას, ეს უკუკავშირი გამოიძახება შეწყვეტის ნომრით (0-7). </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N19sdio_slave_config_t5flagsE">
<span id="_CPPv3N19sdio_slave_config_t5flagsE"></span><span id="_CPPv2N19sdio_slave_config_t5flagsE"></span><span id="sdio_slave_config_t::flags__uint32_t"></span><span class="target" id="structsdio__slave__config__t_1a146fc26be76c00ea7806d557759899db"></span>uint32_t <code class="descname">flags</code><a class="headerlink" href="sdio_slave.html#_CPPv4N19sdio_slave_config_t5flagsE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონა-მოთამაშისთვის ჩასართავი ფუნქციები, კომბინაციები <code class="docutils literal notranslate"><span class="pre">SDIO_SLAVE_FLAG_*</span></code>. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="sdio_slave.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.SDIO_SLAVE_RECV_MAX_BUFFER">
<span class="target" id="sdio__slave_8h_1a1b9becc8b169d7c54e7dd69cf997466b"></span><code class="descname">SDIO_SLAVE_RECV_MAX_BUFFER</code><a class="headerlink" href="sdio_slave.html#c.SDIO_SLAVE_RECV_MAX_BUFFER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.SDIO_SLAVE_FLAG_DAT2_DISABLED">
<span class="target" id="sdio__slave_8h_1af1d88403ba0944f0e01fa79966ebc701"></span><code class="descname">SDIO_SLAVE_FLAG_DAT2_DISABLED</code><a class="headerlink" href="sdio_slave.html#c.SDIO_SLAVE_FLAG_DAT2_DISABLED" title="Permalink to this definition">¶</a></dt>
<dd><p>SD სპეციფიკაციის თანახმად, 4-ვე მონაცემთა ხაზი უნდა იქნას გამოყენებული და აღებული 1-ბიტიან ან SPI რეჟიმშიც კი. თუმცა, მომხმარებელს შეუძლია ამ დროშის მითითება DAT2 პინის 1-ბიტიან რეჟიმში გამოსაყენებლად. გაითვალისწინეთ, რომ ჰოსტს არ შეუძლია CCCR რეგისტრების წაკითხვა იმის გასაგებად, რომ ჩვენ აღარ ვუჭერთ მხარს 4-ბიტიან რეჟიმს, გთხოვთ, ეს გააკეთოთ თქვენივე რისკის ქვეშ. </p>
</dd></dl>
<dl class="macro">
<dt id="c.SDIO_SLAVE_FLAG_HOST_INTR_DISABLED">
<span class="target" id="sdio__slave_8h_1a36c49fd02fae2c83bd6a078cd0fc6eeb"></span><code class="descname">SDIO_SLAVE_FLAG_HOST_INTR_DISABLED</code><a class="headerlink" href="sdio_slave.html#c.SDIO_SLAVE_FLAG_HOST_INTR_DISABLED" title="Permalink to this definition">¶</a></dt>
<dd><p>SDIO პროტოკოლში DAT1 ხაზი გამოიყენება შეწყვეტის ხაზად. თუმცა, მომხმარებელს შეუძლია მიუთითოს ეს დროშა, რათა გამოიყენოს მონა-მოთამაშის DAT1 პინი 1-ბიტიან რეჟიმში. გაითვალისწინეთ, რომ ჰოსტმა უნდა ჩაატაროს შეწყვეტის რეგისტრების გამოკითხვა იმის გასაგებად, არის თუ არა მონა-მოთამაშის შეწყვეტები. მას არ შეუძლია CCCR რეგისტრების წაკითხვა იმის გასაგებად, რომ ჩვენ აღარ ვუჭერთ მხარს 4-ბიტიან რეჟიმს, გთხოვთ, ეს გააკეთოთ თქვენივე რისკის ქვეშ. </p>
</dd></dl>
<dl class="macro">
<dt id="c.SDIO_SLAVE_FLAG_INTERNAL_PULLUP">
<span class="target" id="sdio__slave_8h_1a7a89171f2c5ce80a13e0555e9117b66f"></span><code class="descname">SDIO_SLAVE_FLAG_INTERNAL_PULLUP</code><a class="headerlink" href="sdio_slave.html#c.SDIO_SLAVE_FLAG_INTERNAL_PULLUP" title="Permalink to this definition">¶</a></dt>
<dd><p>ჩართული პინებისთვის შიდა pull-up-ების ჩართვა. SD სპეციფიკაცია მოითხოვს, რომ ყველა 4 მონაცემთა ხაზი უნდა იყოს აყვანილი 1-ბიტიან ან SPI რეჟიმშიც კი. გაითვალისწინეთ, რომ შიდა pull-up-ები არ არის საკმარისი სტაბილური კომუნიკაციისთვის, გთხოვთ, გარე pull-up-ები შეაერთოთ ავტობუსზე. ეს მხოლოდ მაგალითისთვისაა და გამართვა გამოყენებისთვისაა. </p>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="sdio_slave.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv415sdio_event_cb_t">
<span id="_CPPv315sdio_event_cb_t"></span><span id="_CPPv215sdio_event_cb_t"></span><span id="sdio_event_cb_t"></span><span class="target" id="sdio__slave_8h_1ab49582445cc2b758db280a123349cae4"></span><em class="property">typedef </em>void (*<code class="descname">sdio_event_cb_t</code>)<span class="sig-paren">(</span>uint8_t event<span class="sig-paren">)</span><a class="headerlink" href="sdio_slave.html#_CPPv415sdio_event_cb_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="type">
<dt id="_CPPv423sdio_slave_buf_handle_t">
<span id="_CPPv323sdio_slave_buf_handle_t"></span><span id="_CPPv223sdio_slave_buf_handle_t"></span><span id="sdio_slave_buf_handle_t"></span><span class="target" id="sdio__slave_8h_1ac1bb587f0d5814b1d705c889f364f7f6"></span><em class="property">typedef </em>void *<code class="descname">sdio_slave_buf_handle_t</code><a class="headerlink" href="sdio_slave.html#_CPPv423sdio_slave_buf_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიმღები ბუფერის სახელური, სახელურის რეგისტრაცია გამოძახებით <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv_register_buf</span></code>. გამოიყენეთ სახელური ბუფერის დრაივერში ჩასატვირთად ან დარეკეთ <code class="docutils literal notranslate"><span class="pre">sdio_slave_recv_unregister_buf</span></code> თუ ის აღარ გამოიყენება. </p>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="esp_slave_protocol.html" rel="next" title="Communication with ESP SDIO Slave">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="sdspi_host.html" rel="prev" title="SD SPI Host Driver"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (Shanghai) CO., LTD
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>