
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SPI Flash API — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="spiffs.html" rel="next" title="SPIFFS Filesystem"/>
<link href="sdmmc.html" rel="prev" title="SD/SDIO/MMC Driver"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/spi_flash.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/storage/spi_flash"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/storage/spi_flash.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">შენახვა</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fatfs.html">FAT ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="mass_mfg.html">მასობრივი წარმოების კომუნალური მომსახურება</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvs_flash.html">არასტაბილური საცავი</a></li>
<li class="toctree-l3"><a class="reference internal" href="nvs_partition_gen.html">NVS დანაყოფების გენერირების პროგრამა</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc.html">SD/SDIO/MMC დრაივერი</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="spi_flash.html#">SPI Flash და Partition API s</a><ul>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#overview">მიმოხილვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#initializing-a-flash-device">ფლეშ მეხსიერება მოწყობილობის ინიციალიზაცია</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#spi-flash-access-api">SPI ფლეშ მეხსიერება წვდომის API</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#spi-flash-size">SPI ფლეშის ზომა</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#concurrency-constraints-for-flash-on-spi1">SPI1-ზე ფლეშ მეხსიერება ისთვის ერთდროულობის შეზღუდვები</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#partition-table-api">დაყოფის ცხრილი API</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#spi-flash-encryption">SPI ფლეშ დაშიფვრა</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#memory-mapping-api">მეხსიერების რუკების API</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#implementation">განხორციელება</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#see-also">აგრეთვე იხილეთ</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#implementation-details">განხორციელების დეტალები</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#api-reference-spi-flash">API მითითება - SPI Flash</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#api-reference-partition-table">API მითითება - დანაყოფების ცხრილი</a></li>
<li class="toctree-l4"><a class="reference internal" href="spi_flash.html#api-reference-flash-encrypt">API მითითება - Flash Encrypt</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="spiffs.html">SPIFFS ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfs.html">ვირტუალური ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="wear-levelling.html">ცვეთის გასწორება</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">შენახვის API</a> »</li>
<li>SPI Flash API</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/storage/spi_flash.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="spi-flash-api">
<h1>SPI Flash API<a class="headerlink" href="spi_flash.html#spi-flash-api" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/api-reference/storage/spi_flash.html">[中文]</a></p>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="spi_flash.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ფლეშ მეხსიერება კომპონენტი შეიცავს API ფუნქციებს, რომლებიც დაკავშირებულია გარე ფლეშ მეხსიერება ში მონაცემების წაკითხვასთან, ჩაწერასთან, წაშლასთან, მეხსიერების შესაბამისობასთან. ფლეშ მეხსიერება კომპონენტი ასევე აქვს უფრო მაღალი დონის API ფუნქციები, რომლებიც მუშაობენ დანაყოფებთან, რომლებიც განსაზღვრულია <a class="reference internal" href="../../api-guides/partition-tables.html"><span class="doc">დანაყოფების ცხრილი</span></a>.</p>
<p>IDF v4.0-მდე არსებული API ისგან განსხვავებით, მისი ფუნქციონალობა არ შემოიფარგლება მხოლოდ „ძირითადი“ SPI ფლეშ მეხსიერება ჩიპით (იგივე SPI ფლეშ მეხსიერება ჩიპი, საიდანაც პროგრამა მუშაობს). სხვადასხვა ჩიპის მაჩვენებლებით, თქვენ შეგიძლიათ წვდომა გქონდეთ გარე ფლეშ მეხსიერება es ჩიპებზე არა მხოლოდ SPI0/1-ზე, არამედ HSPI/VSPI ავტობუსებზეც.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">IDF v4.0-ის შემდეგ Flash API ები აღარ არის <em>ატომური</em>სხვა მიმდინარე წაკითხვის ოპერაციის დროს, გადაფარულ ფლეშ მეხსიერება მისამართზე ჩაწერის ოპერაციამ შეიძლება გამოიწვიოს წაკითხვის ოპერაციიდან დაბრუნებული მონაცემების ნაწილობრივ იგივეობა, რაც ადრე იყო და ნაწილობრივ განახლება ახალი ჩაწერის სახით.</p>
</div>
<p>Kconfig-ის ვარიანტი <a class="reference internal" href="../kconfig.html#config-spi-flash-use-legacy-impl"><span class="std std-ref">CONFIG_SPI_FLASH_USE_LEGACY_IMPL</span></a> შეიძლება გამოყენებულ იქნას გადართვისთვის
<code class="docutils literal notranslate"><span class="pre">spi_flash_*</span></code> ფუნქციები IDF v4.0-მდე არსებულ იმპლემენტაციას უბრუნდება. თუმცა, კოდის ზომა შეიძლება გაიზარდოს, თუ ერთდროულად გამოიყენებთ ახალ API და ძველ API .</p>
<p>დაშიფრული კითხვა და ჩაწერა იყენებს ძველ იმპლემენტაციას, მაშინაც კი, თუ
<a class="reference internal" href="../kconfig.html#config-spi-flash-use-legacy-impl"><span class="std std-ref">CONFIG_SPI_FLASH_USE_LEGACY_IMPL</span></a> არ არის ჩართული. შესაბამისად, დაშიფრული ფლეშ მეხსიერება ოპერაციები მხარდაჭერილია მხოლოდ ძირითადი ფლეშ მეხსიერება ჩიპით (და არა SPI1-ზე არსებული სხვა ფლეშ მეხსიერება ჩიპებით, რომლებსაც აქვთ სხვა CS).</p>
</div>
<div class="section" id="initializing-a-flash-device">
<h2>ფლეშ მეხსიერება მოწყობილობის ინიციალიზაცია<a class="headerlink" href="spi_flash.html#initializing-a-flash-device" title="Permalink to this headline">¶</a></h2>
<p>გამოსაყენებლად <code class="docutils literal notranslate"><span class="pre">esp_flash_*</span></code> API s-ში, თქვენ უნდა გქონდეთ ჩიპი ინიციალიზებული კონკრეტულ SPI ავტობუსზე.</p>
<ol class="arabic simple">
<li>ზარი <a class="reference internal" href="../peripherals/spi_master.html#_CPPv418spi_bus_initialize17spi_host_device_tPK16spi_bus_config_ti" title="spi_bus_initialize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_initialize()</span></code></a> SPI ავტობუსის სწორად ინიციალიზაციისთვის. ეს ფუნქციები ინიციალიზაციას უკეთებს რესურსებს (I/O, DMA, შეფერხებები), რომლებიც გაზიარებულია ამ ავტობუსზე მიერთებულ მოწყობილობებს შორის.</li>
<li>ზარი <a class="reference internal" href="spi_flash.html#_CPPv424spi_bus_add_flash_devicePP11esp_flash_tPK29esp_flash_spi_device_config_t" title="spi_bus_add_flash_device"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_bus_add_flash_device()</span></code></a> ფლეშ მეხსიერება მოწყობილობის ავტობუსზე დასაკავშირებლად. ეს გამოყოფს მეხსიერებას და შეავსებს წევრებს
<code class="docutils literal notranslate"><span class="pre">esp_flash_t</span></code> სტრუქტურა. CS I/O ასევე ინიციალიზებულია აქ.</li>
<li>ზარი <a class="reference internal" href="spi_flash.html#_CPPv414esp_flash_initP11esp_flash_t" title="esp_flash_init"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_init()</span></code></a> ჩიპთან რეალურად კომუნიკაციისთვის. ეს ასევე აღმოაჩენს ჩიპის ტიპს და გავლენას მოახდენს შემდეგ ოპერაციებზე.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ახლა ერთსა და იმავე ავტობუსზე შესაძლებელია რამდენიმე ფლეშ მეხსიერება ჩიპის მიერთება. თუმცა, გამოყენებით <code class="docutils literal notranslate"><span class="pre">esp_flash_*</span></code> მოწყობილობები და <code class="docutils literal notranslate"><span class="pre">spi_device_*</span></code> იმავე SPI ავტობუსზე მოწყობილობების გამოყენება ჯერ არ არის მხარდაჭერილი.</p>
</div>
</div>
<div class="section" id="spi-flash-access-api">
<h2>SPI ფლეშ მეხსიერება წვდომის API<a class="headerlink" href="spi_flash.html#spi-flash-access-api" title="Permalink to this headline">¶</a></h2>
<p>ეს არის API ფუნქციების ნაკრები ფლეშ მეხსიერება ში მონაცემებთან სამუშაოდ:</p>
<ul class="simple">
<li><a class="reference internal" href="spi_flash.html#_CPPv414esp_flash_readP11esp_flash_tPv8uint32_t8uint32_t" title="esp_flash_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_read()</span></code></a> კითხულობს მონაცემებს ფლეშ მეხსიერება დან RAM-ში</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv415esp_flash_writeP11esp_flash_tPKv8uint32_t8uint32_t" title="esp_flash_write"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_write()</span></code></a> მონაცემებს ოპერატიული მეხსიერებიდან ფლეშ მეხსიერება ში წერს</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv422esp_flash_erase_regionP11esp_flash_t8uint32_t8uint32_t" title="esp_flash_erase_region"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_erase_region()</span></code></a> შლის ფლეშ მეხსიერება -ის კონკრეტულ რეგიონს</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv420esp_flash_erase_chipP11esp_flash_t" title="esp_flash_erase_chip"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_erase_chip()</span></code></a> შლის მთელ ფლეშ მეხსიერება</li>
<li><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_flash_get_chip_size()</span></code> აბრუნებს ფლეშ მეხსიერება ჩიპის ზომას, ბაიტებში, როგორც ეს კონფიგურირებულია menuconfig ში</li>
</ul>
<p>ზოგადად, ეცადეთ, თავიდან აიცილოთ SPI ფლეშ მეხსიერება ნედლი ფუნქციების გამოყენება „მთავარ“ SPI ფლეშ მეხსიერება ჩიპზე შემდეგი ფუნქციების სასარგებლოდ: <a class="reference internal" href="spi_flash.html#flash-partition-apis"><span class="std std-ref">დანაყოფ-სპეციფიკური ფუნქციები</span></a>.</p>
</div>
<div class="section" id="spi-flash-size">
<h2>SPI ფლეშის ზომა<a class="headerlink" href="spi_flash.html#spi-flash-size" title="Permalink to this headline">¶</a></h2>
<p>SPI ფლეშ მეხსიერება ზომის კონფიგურაცია ხდება პროგრამული უზრუნველყოფის ჩამტვირთავი სურათის სათაურში ველის ჩაწერით, ფლეშ მეხსიერება რედაქტირებულია 0x1000 ოფსეტით.</p>
<p>ნაგულისხმევად, SPI ფლეშ მეხსიერება ზომას esptool.py აფიქსირებს, როდესაც ეს ჩამტვირთავი იწერება ფლეშ მეხსიერება ში და სათაური განახლდება სწორი ზომით. ალტერნატიულად, შესაძლებელია ფიქსირებული ფლეშ მეხსიერება ზომის გენერირება დაყენებით <span class="target" id="index-0"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">CONFIG_ESPTOOLPY_FLASHSIZE</span></code> პროექტის კონფიგურაცია .</p>
<p>თუ საჭიროა გაშვების დროს კონფიგურირებული ფლეშ მეხსიერება ზომის გადაფარვა, შესაძლებელია დააყენოთ <code class="docutils literal notranslate"><span class="pre">chip_size</span></code> წევრი <code class="docutils literal notranslate"><span class="pre">g_rom_flashchip</span></code> სტრუქტურა. ეს ზომა გამოიყენება <code class="docutils literal notranslate"><span class="pre">esp_flash_*</span></code> ფუნქციები (როგორც პროგრამულ უზრუნველყოფაში, ასევე ROM-ში) საზღვრების შესამოწმებლად.</p>
</div>
<div class="section" id="concurrency-constraints-for-flash-on-spi1">
<h2>SPI1-ზე ფლეშ მეხსიერება ისთვის ერთდროულობის შეზღუდვები<a class="headerlink" href="spi_flash.html#concurrency-constraints-for-flash-on-spi1" title="Permalink to this headline">¶</a></h2>
<p>რადგან SPI1 ფლეშ მეხსიერება ასევე გამოიყენება პროგრამული უზრუნველყოფა შესასრულებლად ინსტრუქციებისა და მონაცემების ქეშების მეშვეობით, ეს ქეშები უნდა იყოს გამორთული წაკითხვის/ჩაწერის/წაშლის დროს. ეს ნიშნავს, რომ ორივე CPU-მ უნდა გაუშვას კოდი IRAM-დან და ფლეშ მეხსიერება ჩაწერის ოპერაციების შესრულებისას მონაცემებს მხოლოდ DRAM-დან უნდა კითხულობდეს.</p>
<p>თუ აქ დოკუმენტირებულ API ფუნქციებს გამოიყენებთ, მაშინ ეს შეზღუდვები ავტომატურად და გამჭვირვალედ გამოიყენება. თუმცა, გაითვალისწინეთ, რომ ეს გარკვეულ გავლენას მოახდენს სისტემაში არსებულ სხვა ამოცანებზე.</p>
<p>SPI0/1-ის გარდა სხვა SPI ავტობუსებზე ფლეშ მეხსიერება ჩიპებისთვის ასეთი შეზღუდვები და ზეგავლენა არ არსებობს.</p>
<p>IRAM-ს, DRAM-სა და ფლეშ მეხსიერება ქეშს შორის განსხვავებებისთვის, გთხოვთ, იხილოთ <a class="reference internal" href="../../api-guides/general-notes.html#memory-layout"><span class="std std-ref">აპლიკაციის მეხსიერების განლაგება</span></a> დოკუმენტაცია.</p>
<p>ფლეშ მეხსიერება ქეშის შემთხვევით წაკითხვის თავიდან ასაცილებლად, როდესაც ერთი CPU იწყებს ფლეშ მეხსიერება ჩაწერის ან წაშლის ოპერაციას, მეორე CPU გადადის დაბლოკილ მდგომარეობაში და ყველა არა-IRAM-უსაფრთხო შეფერხება გამორთულია ორივე CPU-ზე ფლეშ მეხსიერება ოპერაციის დასრულებამდე.</p>
<p>თუ ერთი CPU იწყებს ფლეშ მეხსიერება ჩაწერის ან წაშლის ოპერაციას, მეორე CPU გადადის დაბლოკილ მდგომარეობაში, რათა თავიდან იქნას აცილებული ფლეშ მეხსიერება ქეშის შემთხვევით წაკითხვა. ყველა შეფერხება, რომელიც არ არის უსაფრთხო IRAM-ისთვის, გამორთულია ორივე CPU-ზე ფლეშ მეხსიერება ოპერაციის დასრულებამდე.</p>
<div class="section" id="iram-safe-interrupt-handlers">
<span id="id1"></span><h3>IRAM-უსაფრთხო შეფერხების დამმუშავებლები<a class="headerlink" href="spi_flash.html#iram-safe-interrupt-handlers" title="Permalink to this headline">¶</a></h3>
<p>თუ გაქვთ შეწყვეტის დამმუშავებელი, რომლის შესრულებაც გსურთ ფლეშ მეხსიერება ოპერაციის მიმდინარეობისას (მაგალითად, დაბალი შეყოვნების ოპერაციებისთვის), დააყენეთ <code class="docutils literal notranslate"><span class="pre">ESP_INTR_FLAG_IRAM</span></code> დროშა, როდესაც <a class="reference internal" href="../system/intr_alloc.html"><span class="doc">შეფერხების დამმუშავებელი რეგისტრირებულია</span></a>.</p>
<p>თქვენ უნდა დარწმუნდეთ, რომ ყველა მონაცემი და ფუნქცია, რომელზეც წვდომა აქვთ ამ შეფერხებების დამმუშავებლებს, მათ შორის ის მონაცემები და ფუნქციები, რომლებსაც დამმუშავებლები იძახებენ, მდებარეობს IRAM-ში ან DRAM-ში.</p>
<p>გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">IRAM_ATTR</span></code> ფუნქციების ატრიბუტი:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include "esp_attr.h"</span>

<span class="n">void</span> <span class="n">IRAM_ATTR</span> <span class="n">gpio_isr_handler</span><span class="p">(</span><span class="n">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">DRAM_ATTR</span></code> და <code class="docutils literal notranslate"><span class="pre">DRAM_STR</span></code> მუდმივი მონაცემების ატრიბუტები:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">IRAM_ATTR</span> <span class="n">gpio_isr_handler</span><span class="p">(</span><span class="n">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">const</span> <span class="n">static</span> <span class="n">DRAM_ATTR</span> <span class="n">uint8_t</span> <span class="n">INDEX_DATA</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
   <span class="n">const</span> <span class="n">static</span> <span class="n">char</span> <span class="o">*</span><span class="n">MSG</span> <span class="o">=</span> <span class="n">DRAM_STR</span><span class="p">(</span><span class="s2">"I am a string stored in RAM"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>გაითვალისწინეთ, რომ იმის ცოდნა, თუ რომელი მონაცემებით უნდა მონიშნოთ <code class="docutils literal notranslate"><span class="pre">DRAM_ATTR</span></code> შეიძლება რთული იყოს, კომპილაცია r ზოგჯერ ამოიცნობს, რომ ცვლადი ან გამოსახულება მუდმივია (მაშინაც კი, თუ ის არ არის მონიშნული <code class="docutils literal notranslate"><span class="pre">const</span></code>) და ოპტიმიზაცია გაუკეთეთ მას ფლეშ მეხსიერება ში, თუ ის არ არის მონიშნული <code class="docutils literal notranslate"><span class="pre">DRAM_ATTR</span></code>.</p>
<p>თუ ფუნქცია ან სიმბოლო სწორად არ არის ჩასმული IRAM/DRAM-ში და შეფერხების დამმუშავებელი ფლეშ მეხსიერება ოპერაციის დროს ფლეშ მეხსიერება ქეშიდან კითხულობს, ეს გამოიწვევს კრახს უკანონო ინსტრუქციის გამონაკლისის გამო (იმ კოდისთვის, რომელიც IRAM-ში უნდა იყოს) ან წასაკითხი ნაგვის მონაცემების გამო (იმ მუდმივი მონაცემებისთვის, რომლებიც DRAM-ში უნდა იყოს).</p>
</div>
</div>
<div class="section" id="partition-table-api">
<span id="flash-partition-apis"></span><h2>დაყოფის ცხრილი API<a class="headerlink" href="spi_flash.html#partition-table-api" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF პროექტები იყენებენ დანაყოფების ცხრილი SPI ფლეშ მეხსიერება მეხსიერების სხვადასხვა რეგიონის შესახებ ინფორმაციის შესანახად ( ჩამტვირთავი , სხვადასხვა აპლიკაციის ბინარული ფაილები, მონაცემები, ფაილური სისტემები). დანაყოფების ცხრილი ის შესახებ დამატებითი ინფორმაციის მოძიება შესაძლებელია. <a class="reference internal" href="../../api-guides/partition-tables.html"><span class="doc">აქ</span></a>.</p>
<p>ეს კომპონენტი უზრუნველყოფს API ფუნქციებს დანაყოფების ცხრილი ში ნაპოვნი დანაყოფების ჩამოსათვლელად და მათზე ოპერაციების შესასრულებლად. ეს ფუნქციები დეკლარირებულია <code class="docutils literal notranslate"><span class="pre">esp_partition.h</span></code>:</p>
<ul class="simple">
<li><a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_find20esp_partition_type_t23esp_partition_subtype_tPKc" title="esp_partition_find"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_find()</span></code></a> ამოწმებს დანაყოფების ცხრილი კონკრეტული ტიპის ჩანაწერებს და აბრუნებს გაუმჭვირვალე იტერატორს.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv417esp_partition_get24esp_partition_iterator_t" title="esp_partition_get"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_get()</span></code></a> აბრუნებს სტრუქტურას, რომელიც აღწერს მოცემული იტერატორის დანაყოფს.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_next24esp_partition_iterator_t" title="esp_partition_next"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_next()</span></code></a> იტერატორს შემდეგ ნაპოვნი დანაყოფზე გადააქვს.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv430esp_partition_iterator_release24esp_partition_iterator_t" title="esp_partition_iterator_release"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_iterator_release()</span></code></a> რელიზების იტერატორის მიერ დაბრუნებული <code class="docutils literal notranslate"><span class="pre">esp_partition_find</span></code>.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_find_first20esp_partition_type_t23esp_partition_subtype_tPKc" title="esp_partition_find_first"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_find_first()</span></code></a> - მოხერხებულობის ფუნქცია, რომელიც აბრუნებს სტრუქტურას, რომელიც აღწერს პირველ დანაყოფის პოვნას <code class="docutils literal notranslate"><span class="pre">esp_partition_find</span></code>.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_readPK15esp_partition_t6size_tPv6size_t" title="esp_partition_read"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_read()</span></code></a>, <a class="reference internal" href="spi_flash.html#_CPPv419esp_partition_writePK15esp_partition_t6size_tPKv6size_t" title="esp_partition_write"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_write()</span></code></a>, <a class="reference internal" href="spi_flash.html#_CPPv425esp_partition_erase_rangePK15esp_partition_t6size_t6size_t" title="esp_partition_erase_range"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_erase_range()</span></code></a> ეკვივალენტურია <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_read()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_write()</span></code>, <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_erase_range()</span></code>, მაგრამ მოქმედებენ დანაყოფის საზღვრებში.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">აპლიკაციის კოდი ძირითადად ამათ უნდა იყენებდეს <code class="docutils literal notranslate"><span class="pre">esp_partition_*</span></code> API ფუნქციები ქვედა დონის ნაცვლად <code class="docutils literal notranslate"><span class="pre">spi_flash_*</span></code> API ფუნქციები. დაყოფის ცხრილის API ფუნქციები ამოწმებენ საზღვრებს და ითვლიან სწორ წანაცვლებებს ფლეშ მეხსიერება ში, დანაყოფების ცხრილი ში შენახული მონაცემების საფუძველზე.</p>
</div>
</div>
<div class="section" id="spi-flash-encryption">
<h2>SPI ფლეშ დაშიფვრა<a class="headerlink" href="spi_flash.html#spi-flash-encryption" title="Permalink to this headline">¶</a></h2>
<p>შესაძლებელია SPI ფლეშ მეხსიერება ის შინაარსის დაშიფვრა და მისი გამჭვირვალედ გაშიფვრა აპარატურით.</p>
<p>იხილეთ <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">ფლეშ დაშიფვრის დოკუმენტაცია</span></a> დამატებითი დეტალებისთვის.</p>
</div>
<div class="section" id="memory-mapping-api">
<h2>მეხსიერების რუკების API<a class="headerlink" href="spi_flash.html#memory-mapping-api" title="Permalink to this headline">¶</a></h2>
<p>ESP32-ს აქვს მეხსიერების აპარატურა, რომელიც საშუალებას იძლევა ფლეშ მეხსიერება მეხსიერების რეგიონები იყოს დაკავშირებული ინსტრუქციებისა და მონაცემთა მისამართების სივრცეებთან. ეს შესაბამისობა მუშაობს მხოლოდ წაკითხვის ოპერაციებისთვის. ფლეშ მეხსიერება მეხსიერების შინაარსის შეცვლა შეუძლებელია შესაბამის მეხსიერების რეგიონში ჩაწერით.</p>
<p>მეხსიერების შესატყვისი აპარატურის განთავსება 64 კბ-იან გვერდებზე ხდება. მეხსიერების შესატყვისი აპარატურის განთავსება მონაცემთა მისამართების სივრცეში ფლეშ მეხსიერება ის ოთხ მეგაბაიტამდე და ინსტრუქციის მისამართების სივრცეში ფლეშ მეხსიერება ის 16 მეგაბაიტამდეა შესაძლებელი. მეხსიერების შესატყვისი აპარატურის შესახებ დამატებითი ინფორმაციისთვის იხილეთ ტექნიკური სახელმძღვანელო.</p>
<p>გაითვალისწინეთ, რომ ზოგიერთი 64 კბ გვერდი გამოიყენება თავად აპლიკაციის მეხსიერებაში გადასატანად, ამიტომ ხელმისაწვდომი 64 კბ გვერდების რეალური რაოდენობა შეიძლება ნაკლები იყოს.</p>
<p>ფლეშ მეხსიერება დან მონაცემების წაკითხვა მეხსიერების შესაბამისი რეგიონის გამოყენებით ფლეშ მეხსიერება ის შინაარსის გაშიფვრის ერთადერთი გზაა, როდესაც <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">ფლეშ მეხსიერება დაშიფვრა</span></a> ჩართულია. გაშიფვრა ხორციელდება აპარატურულ დონეზე.</p>
<p>მეხსიერების განლაგების API გამოცხადებულია <code class="docutils literal notranslate"><span class="pre">esp_spi_flash.h</span></code> და <code class="docutils literal notranslate"><span class="pre">esp_partition.h</span></code>:</p>
<ul class="simple">
<li><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_mmap()</span></code> ფიზიკური ფლეშ მეხსიერება მისამართების რეგიონს CPU-ს ინსტრუქციის სივრცეში ან მონაცემთა სივრცეში ასახავს.</li>
<li><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_munmap()</span></code> ადრე მონიშნული რეგიონის რუკის გაუქმება.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t" title="esp_partition_mmap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_mmap()</span></code></a> ახდენს დანაყოფის ნაწილის მიმაგრებას CPU-ს ინსტრუქციის სივრცეში ან მონაცემთა სივრცეში.</li>
</ul>
<p>განსხვავებები <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_mmap()</span></code> და <a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t" title="esp_partition_mmap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_mmap()</span></code></a> შემდეგია:</p>
<ul class="simple">
<li><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_flash_mmap()</span></code> უნდა მიენიჭოს 64 კბ-იანი გასწორებული ფიზიკური მისამართი.</li>
<li><a class="reference internal" href="spi_flash.html#_CPPv418esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t" title="esp_partition_mmap"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_partition_mmap()</span></code></a> შეიძლება მიენიჭოს ნებისმიერი თვითნებური ოფსეტი დანაყოფში, ის საჭიროებისამებრ დაარეგულირებს დაბრუნებულ მაჩვენებელს შესაბამის მეხსიერებაზე.</li>
</ul>
<p>გაითვალისწინეთ, რომ რადგან მეხსიერების მიმაგრება ხდება 64 კბ ბლოკებში, შესაძლებელია მონაცემების წაკითხვა მოწოდებული დანაყოფის გარეთ. <code class="docutils literal notranslate"><span class="pre">esp_partition_mmap</span></code>.</p>
</div>
<div class="section" id="implementation">
<h2>განხორციელება<a class="headerlink" href="spi_flash.html#implementation" title="Permalink to this headline">¶</a></h2>
<p>ის <code class="docutils literal notranslate"><span class="pre">esp_flash_t</span></code> სტრუქტურა შეიცავს ჩიპის მონაცემებს, ასევე ამ API სამ მნიშვნელოვან ნაწილს8:</p>
<ol class="arabic simple">
<li>მასპინძელი დრაივერი, რომელიც უზრუნველყოფს ჩიპზე წვდომის აპარატურულ მხარდაჭერას;</li>
<li>ჩიპის დრაივერი, რომელიც უზრუნველყოფს სხვადასხვა ჩიპების თავსებადობის სერვისს;</li>
<li>ოპერაციული სისტემის ფუნქციები უზრუნველყოფს ზოგიერთი ოპერაციული სისტემის ფუნქციის (მაგ., დაბლოკვა, შეფერხება) მხარდაჭერას სხვადასხვა ეტაპზე (პირველი/მეორე ჩატვირთვა ან აპლიკაცია).</li>
</ol>
<div class="section" id="host-driver">
<h3>მასპინძელი დრაივერი<a class="headerlink" href="spi_flash.html#host-driver" title="Permalink to this headline">¶</a></h3>
<p>მასპინძელი დრაივერი ეყრდნობა ინტერფეისს (<code class="docutils literal notranslate"><span class="pre">spi_flash_host_driver_t</span></code>) განსაზღვრულია <code class="docutils literal notranslate"><span class="pre">spi_flash_host_drv.h</span></code> (ში <code class="docutils literal notranslate"><span class="pre">soc/include/hal</span></code> საქაღალდე). ეს ინტერფეისი ჩიპთან კომუნიკაციისთვის რამდენიმე საერთო ფუნქციას უზრუნველყოფს.</p>
<p>SPI HAL-ის სხვა ფაილებში, ზოგიერთი ეს ფუნქცია დანერგილია არსებული ESP32 მეხსიერების-spi ფუნქციონალით. თუმცა, ESP32-ის სიჩქარის შეზღუდვების გამო, HAL ფენას არ შეუძლია ზოგიერთი კითხვის ბრძანების მაღალსიჩქარიანი იმპლემენტაციის უზრუნველყოფა (ამიტომ ჩვენ ეს საერთოდ არ გაგვიკეთებია). ფაილები (<code class="docutils literal notranslate"><span class="pre">memspi_host_driver.h</span></code> და <code class="docutils literal notranslate"><span class="pre">.c</span></code>) ამ ბრძანებების მაღალსიჩქარიანი ვერსიის განხორციელება შემდეგი ბრძანებების გამოყენებით: <code class="docutils literal notranslate"><span class="pre">common_command</span></code> HAL-ში მოცემული ფუნქცია და შეფუთეთ ეს ფუნქციები, როგორც <code class="docutils literal notranslate"><span class="pre">spi_flash_host_driver_t</span></code> ზედა ფენისთვის გამოსაყენებლად.</p>
<p>ასევე შეგიძლიათ საკუთარი ჰოსტის დრაივერის იმპლემენტაცია, თუნდაც GPIO ით. სანამ ყველა ფუნქცია <code class="docutils literal notranslate"><span class="pre">spi_flash_host_driver_t</span></code> იმპლემენტაციის შემთხვევაში, esp_ ფლეშ მეხსიერება API შეუძლია ფლეშ მეხსიერება ზე წვდომა დაბალი დონის აპარატურის მიუხედავად.</p>
</div>
<div class="section" id="chip-driver">
<h3>ჩიპის დრაივერი<a class="headerlink" href="spi_flash.html#chip-driver" title="Permalink to this headline">¶</a></h3>
<p>ჩიპის დრაივერი, განსაზღვრული <code class="docutils literal notranslate"><span class="pre">spi_flash_chip_driver.h</span></code>, ახვევს ძირითად ფუნქციებს, რომლებიც მოწოდებულია მასპინძელი დრაივერის მიერ API ფენისთვის გამოსაყენებლად.</p>
<p>ზოგიერთი ოპერაციისთვის ჯერ გარკვეული ბრძანებების გაგზავნა ან სტატუსის წაკითხვაა საჭირო. ზოგიერთ ჩიპს განსხვავებული ბრძანება ან მნიშვნელობა სჭირდება, ან კომუნიკაციის სპეციალური გზები სჭირდება.</p>
<p>არსებობს ჩიპის ტიპი, რომელსაც ე.წ. <code class="docutils literal notranslate"><span class="pre">generic</span> <span class="pre">chip</span></code> რაც საერთო ჩიპებს ნიშნავს. სხვა სპეციალური ჩიპის დრაივერები შეიძლება შეიქმნას ზოგადი ჩიპის საფუძველზე.</p>
<p>ჩიპის დრაივერი დამოკიდებულია მასპინძელ დრაივერზე.</p>
</div>
<div class="section" id="os-functions">
<h3>ოპერაციული სისტემის ფუნქციები<a class="headerlink" href="spi_flash.html#os-functions" title="Permalink to this headline">¶</a></h3>
<p>ამჟამად, OS ფუნქციური დონე უზრუნველყოფს დაბლოკვის და შეფერხების ჩანაწერებს.</p>
<p>საკეტი გამოიყენება SPI ჩიპზე წვდომასა და სხვა ფუნქციებს შორის კონფლიქტების მოსაგვარებლად. მაგალითად, ქეში (რომელიც გამოიყენება კოდისა და PSRAM მონაცემების მისაღებად) უნდა იყოს გამორთული, როდესაც ხდება SPI0/1-ზე ფლეშ მეხსიერება ჩიპზე წვდომა. ასევე, ზოგიერთ მოწყობილობას, რომელსაც არ აქვს CS მავთული, ან მავთული კონტროლდება პროგრამული უზრუნველყოფით (მაგალითად, SD ბარათი SPI ინტერფეისის საშუალებით), გარკვეული პერიოდის განმავლობაში ავტობუსის მონოპოლიზაცია სჭირდება.</p>
<p>შეფერხება გამოიყენება ზოგიერთი ხანგრძლივი ოპერაციის დროს, რაც მოითხოვს მთავარ ოპერატორს პერიოდულად ლოდინი ან გამოკითხვის ჩატარება.</p>
<p>ზედა API 8 ჩიპის დრაივერისა და ოპერაციული სისტემის ფუნქციებს მთლიან კომპონენტი ათავსებს და ასევე უზრუნველყოფს არგუმენტების შემოწმებას.</p>
</div>
</div>
<div class="section" id="see-also">
<h2>აგრეთვე იხილეთ<a class="headerlink" href="spi_flash.html#see-also" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="../../api-guides/partition-tables.html"><span class="doc">დანაყოფების ცხრილის დოკუმენტაცია</span></a></li>
<li><a class="reference internal" href="../system/ota.html"><span class="doc">უსადენო განახლება (OTA) API</span></a> ფლეშ მეხსიერება ში შენახული აპლიკაციის პროგრამული უზრუნველყოფა განახლებისთვის უზრუნველყოფს მაღალი დონის API .</li>
<li><a class="reference internal" href="nvs_flash.html"><span class="doc">არასტაბილური შენახვის (NVS) API</span></a> SPI ფლეშ მეხსიერება ში მონაცემთა მცირე ნაწილების შესანახად სტრუქტურირებულ API იძლევა.</li>
</ul>
</div>
<div class="section" id="implementation-details">
<span id="spi-flash-implementation-details"></span><h2>განხორციელების დეტალები<a class="headerlink" href="spi_flash.html#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>ფლეშ მეხსიერება ზოგიერთი ოპერაციის შესასრულებლად, აუცილებელია დარწმუნდეთ, რომ ორივე CPU არ ამუშავებს ფლეშ მეხსიერება კოდს ფლეშ მეხსიერება ოპერაციის მთელი ხანგრძლივობის განმავლობაში: - ერთბირთვიან სისტემაში, SDK ამას აკეთებს ფლეშ მეხსიერება ოპერაციის შესრულებამდე შეფერხებების/დაგეგმარების გამორთვით. - ორბირთვიან სისტემაში ეს ოდნავ უფრო რთულია, რადგან SDK უნდა დარწმუნდეს, რომ მეორე CPU არ ამუშავებს ფლეშ მეხსიერება ის კოდს.</p>
<p>როდესაც SPI ფლეშ მეხსიერება API გამოიძახება CPU A-ზე (შეიძლება იყოს PRO ან APP), დაიწყეთ spi_ ფლეშ მეხსიერება _op_block_func ფუნქცია CPU B-ზე esp_ipc_call API გამოყენებით. ეს API აღვიძებს მაღალი პრიორიტეტის დავალებას CPU B-ზე და ეუბნება მას, შეასრულოს მოცემული ფუნქცია, ამ შემთხვევაში, spi_ ფლეშ მეხსიერება _op_block_func. ეს ფუნქცია თიშავს ქეშს CPU B-ზე და s_ ფლეშ მეხსიერება _op_can_start დროშის დაყენებით აგზავნის სიგნალს, რომ ქეში გამორთულია. შემდეგ CPU A-ზე დავალება ასევე თიშავს ქეშს და აგრძელებს ფლეშ მეხსიერება ოპერაციის შესრულებას.</p>
<p>ფლეშ მეხსიერება ოპერაციის შესრულებისას, შეფერხებები კვლავ შეიძლება შესრულდეს A და B პროცესორებზე. ვარაუდობენ, რომ ყველა შეფერხების კოდი მოთავსებულია ოპერატიულ მეხსიერებაში. როგორც კი შეფერხების განაწილება API დაემატება, უნდა დაემატოს დროშა, რომელიც მოითხოვს შეფერხების გამორთვას ფლეშ მეხსიერება ოპერაციების ხანგრძლივობის განმავლობაში.</p>
<p>ფლეშ მეხსიერება ოპერაციის დასრულების შემდეგ, CPU A-ზე ფუნქცია აყენებს სხვა ფლაგს, ფლეშ მეხსიერება _op_complete, რათა აცნობოს CPU B-ზე დავალებას, რომ მას შეუძლია ქეშის ხელახლა ჩართვა და CPU-ს გათავისუფლება. შემდეგ CPU A-ზე ფუნქცია ასევე ხელახლა რთავს ქეშს CPU A-ზე და კონტროლს უბრუნებს გამომძახებელ კოდს.</p>
<p>გარდა ამისა, ყველა API ფუნქცია დაცულია mutex-ით (s_ ფლეშ მეხსიერება _op_mutex).</p>
<p>ერთ ბირთვიან გარემოში (<a class="reference internal" href="../kconfig.html#config-freertos-unicore"><span class="std std-ref">CONFIG_FREE RTOS _UNICORE</span></a> ჩართულია), თქვენ უნდა გამორთოთ ორივე ქეში, რათა ვერ მოხდეს CPU-ებს შორის კომუნიკაცია.</p>
</div>
<div class="section" id="api-reference-spi-flash">
<h2>API მითითება - SPI Flash<a class="headerlink" href="spi_flash.html#api-reference-spi-flash" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="spi_flash.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/spi_flash/include/esp_flash_spi_init.h">spi_ ფლეშ მეხსიერება /include/esp_ ფლეშ მეხსიერება _spi_init.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="spi_flash.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv424spi_bus_add_flash_devicePP11esp_flash_tPK29esp_flash_spi_device_config_t">
<span id="_CPPv324spi_bus_add_flash_devicePP11esp_flash_tPK29esp_flash_spi_device_config_t"></span><span id="_CPPv224spi_bus_add_flash_devicePP11esp_flash_tPK29esp_flash_spi_device_config_t"></span><span id="spi_bus_add_flash_device__esp_flash_tPP.esp_flash_spi_device_config_tCP"></span><span class="target" id="esp__flash__spi__init_8h_1a91f9a2f5db19be83b03387603841d117"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">spi_bus_add_flash_device</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> **<em>ჩიპის გარეთ</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv429esp_flash_spi_device_config_t" title="esp_flash_spi_device_config_t">esp_ ფლეშ მეხსიერება _spi_device_config_t</a> *<em>კონფიგურაცია</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv424spi_bus_add_flash_devicePP11esp_flash_tPK29esp_flash_spi_device_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაამატეთ SPI Flash მოწყობილობა SPI ავტობუსზე.</p>
<p>ავტობუსი უკვე ინიციალიზებული უნდა იყოს <code class="docutils literal notranslate"><span class="pre">spi_bus_initialization</span></code>.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG: out_chip არის NULL, ან კონფიგურაციაში რომელიმე ველი არასწორია.</li>
<li>ESP_ERR_NO_MEM: ჩიპური სტრუქტურებისთვის მეხსიერების გამოყოფა ვერ მოხერხდა.</li>
<li>ESP_OK: წარმატება. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">out_chip</span></code>: ინიციალიზებული ჩიპის შესანახი მაჩვენებელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">config</span></code>ინიციალიზაციისთვის განკუთვნილი ჩიპების კონფიგურაცია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv427spi_bus_remove_flash_deviceP11esp_flash_t">
<span id="_CPPv327spi_bus_remove_flash_deviceP11esp_flash_t"></span><span id="_CPPv227spi_bus_remove_flash_deviceP11esp_flash_t"></span><span id="spi_bus_remove_flash_device__esp_flash_tP"></span><span class="target" id="esp__flash__spi__init_8h_1af932953fb19d81948fead481075d10bb"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">spi_bus_remove_flash_device</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv427spi_bus_remove_flash_deviceP11esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ამოიღეთ SPI Flash მოწყობილობა SPI ავტობუსიდან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_ERR_INVALID_ARG: ჩიპი არასწორია.</li>
<li>ESP_OK: წარმატება. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება მოწყობილობა, რომლის ამოღებაც საჭიროა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="spi_flash.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv429esp_flash_spi_device_config_t">
<span id="_CPPv329esp_flash_spi_device_config_t"></span><span id="_CPPv229esp_flash_spi_device_config_t"></span><span id="esp_flash_spi_device_config_t"></span><span class="target" id="structesp__flash__spi__device__config__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_flash_spi_device_config_t</code><a class="headerlink" href="spi_flash.html#_CPPv429esp_flash_spi_device_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI Flash-ის ინიციალიზაციისთვის კონფიგურაციები. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t7host_idE">
<span id="_CPPv3N29esp_flash_spi_device_config_t7host_idE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t7host_idE"></span><span id="esp_flash_spi_device_config_t::host_id__spi_host_device_t"></span><span class="target" id="structesp__flash__spi__device__config__t_1ad34262ef8627302941d6a1b5a214afb1"></span><a class="reference internal" href="../peripherals/spi_master.html#_CPPv417spi_host_device_t" title="spi_host_device_t">spi_host_device_t</a> <code class="descname">host_id</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t7host_idE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოსაყენებელი ავტობუსი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t5cs_idE">
<span id="_CPPv3N29esp_flash_spi_device_config_t5cs_idE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t5cs_idE"></span><span id="esp_flash_spi_device_config_t::cs_id__i"></span><span class="target" id="structesp__flash__spi__device__config__t_1a8f0fb034115335b6d9a91f99e29e0f08"></span>int <code class="descname">cs_id</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t5cs_idE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოსაყენებელი CS პინი (სიგნალი). </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t9cs_io_numE">
<span id="_CPPv3N29esp_flash_spi_device_config_t9cs_io_numE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t9cs_io_numE"></span><span id="esp_flash_spi_device_config_t::cs_io_num__i"></span><span class="target" id="structesp__flash__spi__device__config__t_1a228ae8731be27d9550bee1343607cb8a"></span>int <code class="descname">cs_io_num</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t9cs_io_numE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>GPIO პინი CS სიგნალის გამოსატანად. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t7io_modeE">
<span id="_CPPv3N29esp_flash_spi_device_config_t7io_modeE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t7io_modeE"></span><span id="esp_flash_spi_device_config_t::io_mode__esp_flash_io_mode_t"></span><span class="target" id="structesp__flash__spi__device__config__t_1a75cf3f8db7fd32e01a37fab65eaea996"></span><a class="reference internal" href="spi_flash.html#_CPPv419esp_flash_io_mode_t" title="esp_flash_io_mode_t">esp_ ფლეშ მეხსიერება _io_mode_t</a> <code class="descname">io_mode</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t7io_modeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>IO რეჟიმი Flash-დან წასაკითხად. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t5speedE">
<span id="_CPPv3N29esp_flash_spi_device_config_t5speedE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t5speedE"></span><span id="esp_flash_spi_device_config_t::speed__esp_flash_speed_t"></span><span class="target" id="structesp__flash__spi__device__config__t_1adb4e0ff99304ada1ba600af7dcaf8ef5"></span><a class="reference internal" href="spi_flash.html#_CPPv417esp_flash_speed_t" title="esp_flash_speed_t">esp_ ფლეშ მეხსიერება _speed_t</a> <code class="descname">speed</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t5speedE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ საათის სიჩქარე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29esp_flash_spi_device_config_t14input_delay_nsE">
<span id="_CPPv3N29esp_flash_spi_device_config_t14input_delay_nsE"></span><span id="_CPPv2N29esp_flash_spi_device_config_t14input_delay_nsE"></span><span id="esp_flash_spi_device_config_t::input_delay_ns__i"></span><span class="target" id="structesp__flash__spi__device__config__t_1a2e1b987113f9c99aa18108ec60a73fdd"></span>int <code class="descname">input_delay_ns</code><a class="headerlink" href="spi_flash.html#_CPPv4N29esp_flash_spi_device_config_t14input_delay_nsE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემთა პინების შეყვანის დაყოვნება, ns-ში. თუ უცნობია, დააყენეთ 0-ზე. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id2">
<h3>სათაურის ფაილი<a class="headerlink" href="spi_flash.html#id2" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/spi_flash/include/esp_flash.h">spi_ ფლეშ მეხსიერება /include/esp_ ფლეშ მეხსიერება .h</a></li>
</ul>
</div>
<div class="section" id="id3">
<h3>ფუნქციები<a class="headerlink" href="spi_flash.html#id3" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv414esp_flash_initP11esp_flash_t">
<span id="_CPPv314esp_flash_initP11esp_flash_t"></span><span id="_CPPv214esp_flash_initP11esp_flash_t"></span><span id="esp_flash_init__esp_flash_tP"></span><span class="target" id="esp__flash_8h_1a7b78c01ff9b885e28ae530d520cf2cd4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_init</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv414esp_flash_initP11esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება ჩიპის ინტერფეისის ინიცირება. </p>
<p>ეს ფუნქცია უნდა გამოიძახოს ამ ჩიპისთვის სხვა API ფუნქციების გამოძახებამდე.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Only the <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">read_mode</span></code> fields of the chip structure must be initialised before this function is called. Other fields may be auto-detected if left set to zero or NULL.</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>If the chip-&gt;drv pointer is NULL, chip chip_drv will be auto-detected based on its manufacturer &amp; product IDs. See <code class="docutils literal notranslate"><span class="pre">esp_flash_registered_flash_drivers</span></code> pointer for details of this process.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if initialisation fails. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: მითითება გამოსაყენებელ SPI ფლეშ მეხსიერება ჩიპზე. თუ NULL, ჩანაცვლდება esp_ ფლეშ მეხსიერება _default_chip-ით. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv433esp_flash_chip_driver_initializedPK11esp_flash_t">
<span id="_CPPv333esp_flash_chip_driver_initializedPK11esp_flash_t"></span><span id="_CPPv233esp_flash_chip_driver_initializedPK11esp_flash_t"></span><span id="esp_flash_chip_driver_initialized__esp_flash_tCP"></span><span class="target" id="esp__flash_8h_1ac0479599990e1a1c4453c14ad36c5869"></span>bool <code class="descname">esp_flash_chip_driver_initialized</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv433esp_flash_chip_driver_initializedPK11esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ, დაყენებულია თუ არა შესაბამისი ჩიპის დრაივერი.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>true if set, otherwise false. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: მითითება გამოსაყენებელ SPI ფლეშ მეხსიერება ჩიპზე. თუ NULL, ჩანაცვლდება esp_ ფლეშ მეხსიერება _default_chip-ით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417esp_flash_read_idP11esp_flash_tP8uint32_t">
<span id="_CPPv317esp_flash_read_idP11esp_flash_tP8uint32_t"></span><span id="_CPPv217esp_flash_read_idP11esp_flash_tP8uint32_t"></span><span id="esp_flash_read_id__esp_flash_tP.uint32_tP"></span><span class="target" id="esp__flash_8h_1a9ae74399552dabafaae8b221c7b13f1e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_read_id</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, uint32_t *<em>out_id</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv417esp_flash_read_idP11esp_flash_tP8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება ID-ის წაკითხვა ჩვეულებრივი „RDID“ SPI ფლეშ მეხსიერება ბრძანების მეშვეობით. </p>
<p><p>ID არის 24-ბიტიანი მნიშვნელობა. „id“-ის ქვედა 16 ბიტი ჩიპის ID-ს წარმოადგენს, ზედა 8 ბიტი კი მწარმოებლის ID-ს.</p>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_id</span></code>: მაჩვენებელი ID მნიშვნელობის მისაღებად.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_flash_get_sizeP11esp_flash_tP8uint32_t">
<span id="_CPPv318esp_flash_get_sizeP11esp_flash_tP8uint32_t"></span><span id="_CPPv218esp_flash_get_sizeP11esp_flash_tP8uint32_t"></span><span id="esp_flash_get_size__esp_flash_tP.uint32_tP"></span><span class="target" id="esp__flash_8h_1a3e88353604d41a67589c1516e28f7967"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_get_size</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, uint32_t *<em>დიდი ზომის</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv418esp_flash_get_sizeP11esp_flash_tP8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება ზომის დადგენა ფლეშ მეხსიერება ID-ის მიხედვით. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Most flash chips use a common format for flash ID, where the lower 4 bits specify the size as a power of 2. If the manufacturer doesn’t follow this convention, the size may be incorrectly detected.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_size</span></code>: ზომა ბაიტებშია გამოვლენილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420esp_flash_erase_chipP11esp_flash_t">
<span id="_CPPv320esp_flash_erase_chipP11esp_flash_t"></span><span id="_CPPv220esp_flash_erase_chipP11esp_flash_t"></span><span id="esp_flash_erase_chip__esp_flash_tP"></span><span class="target" id="esp__flash_8h_1aa3ce75afa86644bcd48458b438fc97de"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_erase_chip</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv420esp_flash_erase_chipP11esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება ჩიპის შიგთავსის წაშლა. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422esp_flash_erase_regionP11esp_flash_t8uint32_t8uint32_t">
<span id="_CPPv322esp_flash_erase_regionP11esp_flash_t8uint32_t8uint32_t"></span><span id="_CPPv222esp_flash_erase_regionP11esp_flash_t8uint32_t8uint32_t"></span><span id="esp_flash_erase_region__esp_flash_tP.uint32_t.uint32_t"></span><span class="target" id="esp__flash_8h_1a3463ff7939e150a484c2bfbd5f234611"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_erase_region</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, uint32_t <em>დაწყება</em>, uint32_t <em>ლენ</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv422esp_flash_erase_regionP11esp_flash_t8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება ჩიპის რეგიონის წაშლა. </p>
<p><p>სექტორის ზომა მითითებულია chip-&amp;gt;drv-&amp;gt;sector_size ველში (როგორც წესი, 4096 ბაიტი). ESP_ERR_INVALID_ARG დაბრუნდება, თუ start &amp;amp; length არ არის ამ ზომის ჯერადი.</p>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>მისამართი, საიდანაც უნდა დაიწყოს ფლეშ მეხსიერება წაშლა. სექტორულად უნდა იყოს გასწორებული. </li>
<li><code class="docutils literal notranslate"><span class="pre">len</span></code>წასაშლელი რეგიონის სიგრძე. ასევე უნდა იყოს სექტორულად გასწორებული.</li>
</ul>
</dd>
</dl>
</p>
<p>წაშლა ხორციელდება ბლოკის (მრავალსექტორიანი) წაშლის გამოყენებით, სადაც ეს შესაძლებელია (ბლოკის ზომა მითითებულია chip-&amp;gt;drv-&amp;gt;block_erase_size ველში, როგორც წესი, 65536 ბაიტი). დარჩენილი სექტორები იშლება ცალკეული სექტორის წაშლის ბრძანებების გამოყენებით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv432esp_flash_get_chip_write_protectP11esp_flash_tPb">
<span id="_CPPv332esp_flash_get_chip_write_protectP11esp_flash_tPb"></span><span id="_CPPv232esp_flash_get_chip_write_protectP11esp_flash_tPb"></span><span id="esp_flash_get_chip_write_protect__esp_flash_tP.bP"></span><span class="target" id="esp__flash_8h_1af75fd1e9580c974db822206667aa36f3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_get_chip_write_protect</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, bool *<em>ჩაწერის_დაცვა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv432esp_flash_get_chip_write_protectP11esp_flash_tPb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ, თუ მთელი ჩიპი ჩაწერისგან დაცულია. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>A correct result for this flag depends on the SPI flash chip model and chip_drv in use (via the ‘chip-&gt;drv’ field).</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">write_protected</span></code>: ლოგიკური მნიშვნელობის მაჩვენებელი, დაყენებული ჩაწერის დაცვის დროშის მნიშვნელობად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv432esp_flash_set_chip_write_protectP11esp_flash_tb">
<span id="_CPPv332esp_flash_set_chip_write_protectP11esp_flash_tb"></span><span id="_CPPv232esp_flash_set_chip_write_protectP11esp_flash_tb"></span><span id="esp_flash_set_chip_write_protect__esp_flash_tP.b"></span><span class="target" id="esp__flash_8h_1a26139972a2be6514ca2174ff9833e39a"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_set_chip_write_protect</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, bool <em>ჩაწერის_დაცვა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv432esp_flash_set_chip_write_protectP11esp_flash_tb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება ჩიპისთვის ჩაწერის დაცვის დაყენება. </p>
<p><p>ზოგიერთ SPI ფლეშ მეხსიერება ჩიპს შეიძლება დასჭირდეს ჩართვის ციკლი ჩაწერის დაცვის სტატუსის გასუფთავებამდე. წინააღმდეგ შემთხვევაში, ჩაწერის დაცვის მოხსნა შესაძლებელია ამ ფუნქციის შემდგომი გამოძახებით.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the ‘chip-&gt;drv’ field).</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">write_protect</span></code>ჩაწერის დაცვის დროშის ლოგიკური მნიშვნელობა</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv433esp_flash_get_protectable_regionsPK11esp_flash_tPPK18esp_flash_region_tP8uint32_t">
<span id="_CPPv333esp_flash_get_protectable_regionsPK11esp_flash_tPPK18esp_flash_region_tP8uint32_t"></span><span id="_CPPv233esp_flash_get_protectable_regionsPK11esp_flash_tPPK18esp_flash_region_tP8uint32_t"></span><span id="esp_flash_get_protectable_regions__esp_flash_tCP.esp_flash_region_tCPP.uint32_tP"></span><span class="target" id="esp__flash_8h_1a868adb2e74e8d9697ec1b9434e7f2021"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_get_protectable_regions</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv418esp_flash_region_t" title="esp_flash_region_t">esp_ ფლეშ მეხსიერება _region_t</a> **<em>გარე_რეგიონები</em>, uint32_t *<em>რეგიონების_გარე_რიცხვა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv433esp_flash_get_protectable_regionsPK11esp_flash_tPPK18esp_flash_region_tP8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ ამ SPI ფლეშ მეხსიერება ჩიპის ინდივიდუალურად დაცული რეგიონების სია. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the ‘chip-&gt;drv’ field).</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_regions</span></code>: მაჩვენებელი ჩიპის დაცული რეგიონების მასივზე მაჩვენებლის მისაღებად. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_num_regions</span></code>: მაჩვენებელი მთელ რიცხვზე, რომელიც იღებს მასივში დაცული რეგიონების რაოდენობას, რომელიც დაბრუნებულია &amp;#39;regions&amp;#39;-ში.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430esp_flash_get_protected_regionP11esp_flash_tPK18esp_flash_region_tPb">
<span id="_CPPv330esp_flash_get_protected_regionP11esp_flash_tPK18esp_flash_region_tPb"></span><span id="_CPPv230esp_flash_get_protected_regionP11esp_flash_tPK18esp_flash_region_tPb"></span><span id="esp_flash_get_protected_region__esp_flash_tP.esp_flash_region_tCP.bP"></span><span class="target" id="esp__flash_8h_1a7d0c5c4e6f976774c70712637315c55b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_get_protected_region</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv418esp_flash_region_t" title="esp_flash_region_t">esp_ ფლეშ მეხსიერება _region_t</a> *<em>რეგიონი</em>, bool *<em>დაუცველი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv430esp_flash_get_protected_regionP11esp_flash_tPK18esp_flash_region_tPb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაადგინეთ, დაცულია თუ არა SPI ფლეშ მეხსიერება ჩიპის რომელიმე რეგიონი. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>It is possible for this result to be false and write operations to still fail, if protection is enabled for the entire chip.</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the ‘chip-&gt;drv’ field).</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">region</span></code>: მაჩვენებელი დაცულ რეგიონს აღმწერ სტრუქტურაზე. ეს უნდა ემთხვეოდეს esp_ ფლეშ მეხსიერება _get_protectable_regions(…)-დან დაბრუნებულ ერთ-ერთ რეგიონს. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_protected</span></code>: მიუთითებს დროშაზე, რომელიც დაყენებულია ამ რეგიონის დაცული სტატუსის მიხედვით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430esp_flash_set_protected_regionP11esp_flash_tPK18esp_flash_region_tb">
<span id="_CPPv330esp_flash_set_protected_regionP11esp_flash_tPK18esp_flash_region_tb"></span><span id="_CPPv230esp_flash_set_protected_regionP11esp_flash_tPK18esp_flash_region_tb"></span><span id="esp_flash_set_protected_region__esp_flash_tP.esp_flash_region_tCP.b"></span><span class="target" id="esp__flash_8h_1a8e088c0f36263ee7198225afeffca8e3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_set_protected_region</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv418esp_flash_region_t" title="esp_flash_region_t">esp_ ფლეშ მეხსიერება _region_t</a> *<em>რეგიონი</em>, bool <em>დაცვა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv430esp_flash_set_protected_regionP11esp_flash_tPK18esp_flash_region_tb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განაახლეთ დაცული სტატუსი SPI ფლეშ მეხსიერება ჩიპის რეგიონისთვის. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>It is possible for the region protection flag to be cleared and write operations to still fail, if protection is enabled for the entire chip.</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>Correct behaviour of this function depends on the SPI flash chip model and chip_drv in use (via the ‘chip-&gt;drv’ field).</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">region</span></code>: მაჩვენებელი დაცულ რეგიონს აღმწერ სტრუქტურაზე. ეს უნდა ემთხვეოდეს esp_ ფლეშ მეხსიერება _get_protectable_regions(…)-დან დაბრუნებულ ერთ-ერთ რეგიონს. </li>
<li><code class="docutils literal notranslate"><span class="pre">protect</span></code>დააყენეთ დაცვის დროშა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414esp_flash_readP11esp_flash_tPv8uint32_t8uint32_t">
<span id="_CPPv314esp_flash_readP11esp_flash_tPv8uint32_t8uint32_t"></span><span id="_CPPv214esp_flash_readP11esp_flash_tPv8uint32_t8uint32_t"></span><span id="esp_flash_read__esp_flash_tP.voidP.uint32_t.uint32_t"></span><span class="target" id="esp__flash_8h_1a3124eba3c0428aa810be82593d49f164"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_read</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, void *<em>ბუფერი</em>, uint32_t <em>მისამართი</em>, uint32_t <em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv414esp_flash_readP11esp_flash_tPv8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ მონაცემები SPI ფლეშ მეხსიერება ჩიპიდან. </p>
<p><p>ბუფერზე, მისამართზე ან სიგრძეზე გასწორების შეზღუდვები არ არსებობს.</p>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: ბუფერის მიმთითებელი, სადაც მონაცემები წაიკითხება. უკეთესი მუშაობისთვის, ის DRAM-ში უნდა იყოს და სიტყვები გასწორებული. </li>
<li><code class="docutils literal notranslate"><span class="pre">address</span></code>მისამართი ფლეშ მეხსიერება ზე, საიდანაც წასაკითხია. უნდა იყოს chip-&amp;gt;size ველზე ნაკლები. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>წასაკითხი მონაცემების სიგრძე (ბაიტებში).</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>If on-chip flash encryption is used, this function returns raw (ie encrypted) data. Use the flash cache to transparently decrypt data.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_NO_MEM: ბუფერი არასწორია, თუმცა malloc-ის შექმნა გროვაზე ვერ მოხერხდა.</li>
<li>ან ფლეშ მეხსიერება შეცდომის კოდი, თუ ოპერაცია ვერ შესრულდა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415esp_flash_writeP11esp_flash_tPKv8uint32_t8uint32_t">
<span id="_CPPv315esp_flash_writeP11esp_flash_tPKv8uint32_t8uint32_t"></span><span id="_CPPv215esp_flash_writeP11esp_flash_tPKv8uint32_t8uint32_t"></span><span id="esp_flash_write__esp_flash_tP.voidCP.uint32_t.uint32_t"></span><span class="target" id="esp__flash_8h_1ac797be419c7ec74a897ec2292d003f2f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_write</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, <em class="property">კონსტ</em> void *<em>ბუფერი</em>, uint32_t <em>მისამართი</em>, uint32_t <em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv415esp_flash_writeP11esp_flash_tPKv8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების ჩაწერა SPI ფლეშ მეხსიერება ჩიპზე. </p>
<p><p>ბუფერზე, მისამართზე ან სიგრძეზე გასწორების შეზღუდვები არ არსებობს.</p>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების მაჩვენებელი. წარმატებით უნდა იყოს ინიციალიზებული esp_ ფლეშ მეხსიერება _init()-ის მეშვეობით. </li>
<li><code class="docutils literal notranslate"><span class="pre">address</span></code>მისამართი ფლეშ მეხსიერება ზე, რომელზეც უნდა ჩაიწეროს. წინასწარ უნდა წაიშალოს (SPI და არც ფლეშ მეხსიერება შეუძლია მხოლოდ 1-&amp;gt;0 ბიტების ჩაწერა). </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: ჩასაწერი მონაცემების ბუფერზე მითითება. უკეთესი შესრულებისთვის, ის DRAM-ში უნდა იყოს და სიტყვები ერთმანეთს უნდა შეესაბამებოდეს. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>ჩასაწერი მონაცემების სიგრძე (ბაიტებში).</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, or a flash error code if operation failed. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425esp_flash_write_encryptedP11esp_flash_t8uint32_tPKv8uint32_t">
<span id="_CPPv325esp_flash_write_encryptedP11esp_flash_t8uint32_tPKv8uint32_t"></span><span id="_CPPv225esp_flash_write_encryptedP11esp_flash_t8uint32_tPKv8uint32_t"></span><span id="esp_flash_write_encrypted__esp_flash_tP.uint32_t.voidCP.uint32_t"></span><span class="target" id="esp__flash_8h_1ad30649c5e250eccada206c555be21d34"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_write_encrypted</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, uint32_t <em>მისამართი</em>, <em class="property">კონსტ</em> void *<em>ბუფერი</em>, uint32_t <em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv425esp_flash_write_encryptedP11esp_flash_t8uint32_tPKv8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების დაშიფვრა და SPI ფლეშ მეხსიერება ჩიპზე ჩაწერა ჩიპში ჩაშენებული აპარატურული ფლეშ მეხსიერება დაშიფვრის გამოყენებით. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Both address &amp; length must be 16 byte aligned, as this is the encryption block size</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_SUPPORTED: დაშიფრული ჩაწერა ამ ჩიპისთვის მხარდაჭერილი არ არის.</li>
<li>ESP_ERR_INVALID_ARG: მისამართი, ბუფერი ან სიგრძე არასწორია.</li>
<li>ან spi_ ფლეშ მეხსიერება _write_encrypted()-დან სხვა ფლეშ მეხსიერება შეცდომის კოდი. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: მაჩვენებელი ფლეშ მეხსიერება ჩიპის იდენტიფიცირებისთვის. უნდა იყოს NULL (ძირითადი ფლეშ მეხსიერება ჩიპი). სხვა ჩიპებისთვის დაშიფრული ჩაწერა მხარდაჭერილი არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">address</span></code>მისამართი ფლეშ მეხსიერება ზე ჩასაწერად. 16 ბაიტი გასწორებულია. წინასწარ უნდა წაიშალოს (SPI NOR ფლეშ მეხსიერება მხოლოდ 1-&amp;gt;0 ბიტების ჩაწერა შეუძლია). </li>
<li><code class="docutils literal notranslate"><span class="pre">buffer</span></code>: მიმთითებელი ბუფერზე, რომელშიც ჩასაწერი მონაცემებია. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>ჩასაწერი მონაცემების სიგრძე (ბაიტებში). 16 ბაიტი გასწორებულია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424esp_flash_read_encryptedP11esp_flash_t8uint32_tPv8uint32_t">
<span id="_CPPv324esp_flash_read_encryptedP11esp_flash_t8uint32_tPv8uint32_t"></span><span id="_CPPv224esp_flash_read_encryptedP11esp_flash_t8uint32_tPv8uint32_t"></span><span id="esp_flash_read_encrypted__esp_flash_tP.uint32_t.voidP.uint32_t"></span><span class="target" id="esp__flash_8h_1a7a5baa4846df3db2e6a905ffa2ab6272"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_read_encrypted</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em>, uint32_t <em>მისამართი</em>, void *<em>გარეთ_ბუფერი</em>, uint32_t <em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv424esp_flash_read_encryptedP11esp_flash_t8uint32_tPv8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება ჩიპიდან მონაცემების წაკითხვა და გაშიფვრა ჩიპზე დამონტაჟებული აპარატურული ფლეშ მეხსიერება დაშიფვრის გამოყენებით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_SUPPORTED: დაშიფრული წაკითხვა ამ ჩიპისთვის მხარდაჭერილი არ არის.</li>
<li>ან spi_ ფლეშ მეხსიერება _read_encrypted()-დან სხვა ფლეშ მეხსიერება შეცდომის კოდი. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: მაჩვენებელი ფლეშ მეხსიერება ჩიპის იდენტიფიცირებისთვის. უნდა იყოს NULL (ძირითადი ფლეშ მეხსიერება ჩიპი). სხვა ჩიპებისთვის დაშიფრული წაკითხვა მხარდაჭერილი არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">address</span></code>: მისამართი ფლეშ მეხსიერება ზე წასაკითხად. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_buffer</span></code>: მაჩვენებელი ბუფერზე, რომელშიც მონაცემები წაიკითხავს. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>წასაკითხი მონაცემების სიგრძე (ბაიტებში).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422esp_flash_is_quad_modePK11esp_flash_t">
<span id="_CPPv322esp_flash_is_quad_modePK11esp_flash_t"></span><span id="_CPPv222esp_flash_is_quad_modePK11esp_flash_t"></span><span id="esp_flash_is_quad_mode__esp_flash_tCP"></span><span class="target" id="esp__flash_8h_1a19d9adf990cd3939c2cccebd1fc5c870"></span><em class="property">სტატიკური</em> bool <code class="descname">esp_flash_is_quad_mode</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ჩიპი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv422esp_flash_is_quad_modePK11esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს true-ს, თუ ჩიპი კონფიგურირებულია Quad I/O-სთვის ან Quad Fast Read-ისთვის. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>true if flash works in quad mode, otherwise false </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chip</span></code>: მითითება გამოსაყენებელ SPI ფლეშ მეხსიერება ჩიპზე. თუ NULL, ჩანაცვლდება esp_ ფლეშ მეხსიერება _default_chip-ით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id4">
<h3>სტრუქტურები<a class="headerlink" href="spi_flash.html#id4" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv418esp_flash_region_t">
<span id="_CPPv318esp_flash_region_t"></span><span id="_CPPv218esp_flash_region_t"></span><span id="esp_flash_region_t"></span><span class="target" id="structesp__flash__region__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_flash_region_t</code><a class="headerlink" href="spi_flash.html#_CPPv418esp_flash_region_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სტრუქტურა ფლეშ მეხსიერება ის რეგიონის აღსაწერად. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N18esp_flash_region_t6offsetE">
<span id="_CPPv3N18esp_flash_region_t6offsetE"></span><span id="_CPPv2N18esp_flash_region_t6offsetE"></span><span id="esp_flash_region_t::offset__uint32_t"></span><span class="target" id="structesp__flash__region__t_1aac5c054796d5b4d448fa9c2a90d98533"></span>uint32_t <code class="descname">offset</code><a class="headerlink" href="spi_flash.html#_CPPv4N18esp_flash_region_t6offsetE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ამ რეგიონის საწყისი მისამართი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18esp_flash_region_t4sizeE">
<span id="_CPPv3N18esp_flash_region_t4sizeE"></span><span id="_CPPv2N18esp_flash_region_t4sizeE"></span><span id="esp_flash_region_t::size__uint32_t"></span><span class="target" id="structesp__flash__region__t_1a7d518629b202fc1e31691b954ee9a62b"></span>uint32_t <code class="descname">size</code><a class="headerlink" href="spi_flash.html#_CPPv4N18esp_flash_region_t4sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რეგიონის ზომა. </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv424esp_flash_os_functions_t">
<span id="_CPPv324esp_flash_os_functions_t"></span><span id="_CPPv224esp_flash_os_functions_t"></span><span id="esp_flash_os_functions_t"></span><span class="target" id="structesp__flash__os__functions__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_flash_os_functions_t</code><a class="headerlink" href="spi_flash.html#_CPPv424esp_flash_os_functions_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ოპერაციული სისტემის დონის ინტეგრაციის კაუჭები გაშვებულ ოპერაციულ სისტემაში ფლეშ მეხსიერება ჩიპებზე წვდომისთვის </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N24esp_flash_os_functions_t5startE">
<span id="_CPPv3N24esp_flash_os_functions_t5startE"></span><span id="_CPPv2N24esp_flash_os_functions_t5startE"></span><span class="target" id="structesp__flash__os__functions__t_1a03327849d6fe7e61ab47c4cb9b7e8f6c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">start</code>)<span class="sig-paren">(</span>void *arg<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N24esp_flash_os_functions_t5startE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიძახება ფლეშ მეხსიერება ოპერაციის დაწყებამდე. არ არის აუცილებელი იყოს რეკურსიული (ანუ გამოიძახება მაქსიმუმ ერთხელ თითოეული გამოძახებისთვის „დასასრულის“ მიზნით). </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N24esp_flash_os_functions_t3endE">
<span id="_CPPv3N24esp_flash_os_functions_t3endE"></span><span id="_CPPv2N24esp_flash_os_functions_t3endE"></span><span class="target" id="structesp__flash__os__functions__t_1acb785e0f059ab204a63ecd9b68afa192"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">end</code>)<span class="sig-paren">(</span>void *arg<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N24esp_flash_os_functions_t3endE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიძახება ნებისმიერი ფლეშ მეხსიერება ოპერაციის დასრულების შემდეგ. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N24esp_flash_os_functions_t16region_protectedE">
<span id="_CPPv3N24esp_flash_os_functions_t16region_protectedE"></span><span id="_CPPv2N24esp_flash_os_functions_t16region_protectedE"></span><span class="target" id="structesp__flash__os__functions__t_1aed1c7236b628522b78582c38da148b4c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">region_protected</code>)<span class="sig-paren">(</span>void *arg, size_t start_addr, size_t size<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N24esp_flash_os_functions_t16region_protectedE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიძახება ნებისმიერი წაშლის/ჩაწერის ოპერაციის წინ, რათა შემოწმდეს, შეზღუდულია თუ არა რეგიონი ოპერაციული სისტემით. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N24esp_flash_os_functions_t8delay_msE">
<span id="_CPPv3N24esp_flash_os_functions_t8delay_msE"></span><span id="_CPPv2N24esp_flash_os_functions_t8delay_msE"></span><span class="target" id="structesp__flash__os__functions__t_1a9753ea3ced1f28ad3b79a3ca19f6129c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">delay_ms</code>)<span class="sig-paren">(</span>void *arg, unsigned ms<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N24esp_flash_os_functions_t8delay_msE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეყოვნება მინიმუმ &amp;#39;ms&amp;#39; მილიწამით. გამოიძახება &amp;#39;დაწყებას&amp;#39; და &amp;#39;დასასრულს&amp;#39; შორის. </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv411esp_flash_t">
<span id="_CPPv311esp_flash_t"></span><span id="_CPPv211esp_flash_t"></span><span id="esp_flash_t"></span><span class="target" id="structesp__flash__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_flash_t</code><a class="headerlink" href="spi_flash.html#_CPPv411esp_flash_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სტრუქტურა, რომელიც აღწერს სისტემასთან დაკავშირებულ SPI ფლეშ მეხსიერება ჩიპს. </p>
<p>გამოყენებამდე სტრუქტურა უნდა იყოს ინიციალიზებული (გადაეცემა esp_ ფლეშ მეხსიერება _init()-ს). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t4hostE">
<span id="_CPPv3N11esp_flash_t4hostE"></span><span id="_CPPv2N11esp_flash_t4hostE"></span><span id="esp_flash_t::host__spi_flash_host_driver_tP"></span><span class="target" id="structesp__flash__t_1a3c275fb310563d40ab3a1d6cae663be2"></span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *<code class="descname">host</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t4hostE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აპარატურულ-სპეციფიკურ „host_driver“ სტრუქტურაზე მითითება. გამოყენებამდე აუცილებელია მისი ინიციალიზაცია. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t8chip_drvE">
<span id="_CPPv3N11esp_flash_t8chip_drvE"></span><span id="_CPPv2N11esp_flash_t8chip_drvE"></span><span id="esp_flash_t::chip_drv__spi_flash_chip_tCP"></span><span class="target" id="structesp__flash__t_1aab7d29613cd6dff8966fbca826131982"></span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv416spi_flash_chip_t" title="spi_flash_chip_t">spi_ ფლეშ მეხსიერება _chip_t</a> *<code class="descname">chip_drv</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t8chip_drvE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩიპ-მოდელ-სპეციფიკური „ადაპტერის“ სტრუქტურის მაჩვენებელი. თუ NULL მნიშვნელობაა, ის ინიციალიზაციის დროს გამოვლინდება. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t7os_funcE">
<span id="_CPPv3N11esp_flash_t7os_funcE"></span><span id="_CPPv2N11esp_flash_t7os_funcE"></span><span id="esp_flash_t::os_func__esp_flash_os_functions_tCP"></span><span class="target" id="structesp__flash__t_1aae53f01d3709cad4e387165691f248bc"></span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv424esp_flash_os_functions_t" title="esp_flash_os_functions_t">esp_ ფლეშ მეხსიერება _os_functions_t</a> *<code class="descname">os_func</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t7os_funcE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>os-სპეციფიკური ჰუკის სტრუქტურის მაჩვენებელი. გამოძახება <code class="docutils literal notranslate"><span class="pre">esp_flash_init_os_functions()</span></code> ამ ველის დასაყენებლად, მასპინძლის სწორად ინიციალიზაციის შემდეგ. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t12os_func_dataE">
<span id="_CPPv3N11esp_flash_t12os_func_dataE"></span><span id="_CPPv2N11esp_flash_t12os_func_dataE"></span><span id="esp_flash_t::os_func_data__voidP"></span><span class="target" id="structesp__flash__t_1a72ca149555a0d3617ac0737f5c06f0ce"></span>void *<code class="descname">os_func_data</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t12os_func_dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>os-სპეციფიკური ჰუკების არგუმენტის მითითება. დატოვეთ NULL და ინიციალიზაცია მოხდება <code class="docutils literal notranslate"><span class="pre">os_func</span></code>. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t9read_modeE">
<span id="_CPPv3N11esp_flash_t9read_modeE"></span><span id="_CPPv2N11esp_flash_t9read_modeE"></span><span id="esp_flash_t::read_mode__esp_flash_io_mode_t"></span><span class="target" id="structesp__flash__t_1a7a2be47d1127ec3a6666c1ed492d5549"></span><a class="reference internal" href="spi_flash.html#_CPPv419esp_flash_io_mode_t" title="esp_flash_io_mode_t">esp_ ფლეშ მეხსიერება _io_mode_t</a> <code class="descname">read_mode</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t9read_modeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>კონფიგურირებული SPI ფლეშ მეხსიერება წაკითხვის რეჟიმი. დაყენებულია ადრე <code class="docutils literal notranslate"><span class="pre">esp_flash_init</span></code> ეწოდება. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t4sizeE">
<span id="_CPPv3N11esp_flash_t4sizeE"></span><span id="_CPPv2N11esp_flash_t4sizeE"></span><span id="esp_flash_t::size__uint32_t"></span><span class="target" id="structesp__flash__t_1a241862dd55bf586b82030d6c43ec47cc"></span>uint32_t <code class="descname">size</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t4sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება ის ზომა ბაიტებში. თუ 0, ზომა დაფიქსირდება ინიციალიზაციის დროს. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11esp_flash_t7chip_idE">
<span id="_CPPv3N11esp_flash_t7chip_idE"></span><span id="_CPPv2N11esp_flash_t7chip_idE"></span><span id="esp_flash_t::chip_id__uint32_t"></span><span class="target" id="structesp__flash__t_1a6b0bbaac1061e0ca1c3498c60dbb4118"></span>uint32_t <code class="descname">chip_id</code><a class="headerlink" href="spi_flash.html#_CPPv4N11esp_flash_t7chip_idE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩიპის ID აღმოჩენილია. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="spi_flash.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv416spi_flash_chip_t">
<span id="_CPPv316spi_flash_chip_t"></span><span id="_CPPv216spi_flash_chip_t"></span><span id="spi_flash_chip_t"></span><span class="target" id="esp__flash_8h_1a0ebb6ac2b4a1b31b03c091308f6645c1"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="spi_flash.html#_CPPv416spi_flash_chip_t" title="spi_flash_chip_t">spi_ ფლეშ მეხსიერება _chip_t</a> <code class="descname">spi_flash_chip_t</code><a class="headerlink" href="spi_flash.html#_CPPv416spi_flash_chip_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="type">
<dt id="_CPPv411esp_flash_t">
<span id="_CPPv311esp_flash_t"></span><span id="_CPPv211esp_flash_t"></span><span class="target" id="esp__flash_8h_1a68028cb8a9c46815ee257469d301a565"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> <code class="descname">esp_flash_t</code><br/></dt>
<dd></dd></dl>
</div>
<div class="section" id="id5">
<h3>სათაურის ფაილი<a class="headerlink" href="spi_flash.html#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/soc/include/hal/spi_flash_types.h">soc/include/hal/spi_ ფლეშ მეხსიერება _types.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>სტრუქტურები<a class="headerlink" href="spi_flash.html#id6" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv417spi_flash_trans_t">
<span id="_CPPv317spi_flash_trans_t"></span><span id="_CPPv217spi_flash_trans_t"></span><span id="spi_flash_trans_t"></span><span class="target" id="structspi__flash__trans__t"></span><em class="property">სტრუქტურა </em><code class="descname">spi_flash_trans_t</code><a class="headerlink" href="spi_flash.html#_CPPv417spi_flash_trans_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩვეულებრივი ტრანზაქციის განმარტება. ასევე შეიცავს დაბრუნებულ მნიშვნელობას. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t7commandE">
<span id="_CPPv3N17spi_flash_trans_t7commandE"></span><span id="_CPPv2N17spi_flash_trans_t7commandE"></span><span id="spi_flash_trans_t::command__uint8_t"></span><span class="target" id="structspi__flash__trans__t_1a27a14d86dff6457f55c9d5d31e7616bc"></span>uint8_t <code class="descname">command</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t7commandE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაგზავნის ბრძანება, ყოველთვის 8 ბიტიანი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t8mosi_lenE">
<span id="_CPPv3N17spi_flash_trans_t8mosi_lenE"></span><span id="_CPPv2N17spi_flash_trans_t8mosi_lenE"></span><span id="spi_flash_trans_t::mosi_len__uint8_t"></span><span class="target" id="structspi__flash__trans__t_1af459e3524ab8fd4760d04a909006d5f5"></span>uint8_t <code class="descname">mosi_len</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t8mosi_lenE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამომავალი მონაცემების სიგრძე, ბაიტებში. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t8miso_lenE">
<span id="_CPPv3N17spi_flash_trans_t8miso_lenE"></span><span id="_CPPv2N17spi_flash_trans_t8miso_lenE"></span><span id="spi_flash_trans_t::miso_len__uint8_t"></span><span class="target" id="structspi__flash__trans__t_1a8d022195b8e91be82884b7868796679a"></span>uint8_t <code class="descname">miso_len</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t8miso_lenE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეყვანის მონაცემების სიგრძე, ბაიტებში. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t14address_bitlenE">
<span id="_CPPv3N17spi_flash_trans_t14address_bitlenE"></span><span id="_CPPv2N17spi_flash_trans_t14address_bitlenE"></span><span id="spi_flash_trans_t::address_bitlen__uint8_t"></span><span class="target" id="structspi__flash__trans__t_1ab75a75e9f5d0bf420609a6084fc5a930"></span>uint8_t <code class="descname">address_bitlen</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t14address_bitlenE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მისამართის სიგრძე ბიტებში, დაყენებულია 0-ზე, თუ ბრძანებას მისამართი არ სჭირდება. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t7addressE">
<span id="_CPPv3N17spi_flash_trans_t7addressE"></span><span id="_CPPv2N17spi_flash_trans_t7addressE"></span><span id="spi_flash_trans_t::address__uint32_t"></span><span class="target" id="structspi__flash__trans__t_1a1907ba6ba0c2f8d4cf4a58e78442d3de"></span>uint32_t <code class="descname">address</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t7addressE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მისამართი, რომელზეც ოპერაცია უნდა შესრულდეს. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t9mosi_dataE">
<span id="_CPPv3N17spi_flash_trans_t9mosi_dataE"></span><span id="_CPPv2N17spi_flash_trans_t9mosi_dataE"></span><span id="spi_flash_trans_t::mosi_data__uint8_tCP"></span><span class="target" id="structspi__flash__trans__t_1a03550980011273b84e961893c9f4e675"></span><em class="property">კონსტ</em> uint8_t *<code class="descname">mosi_data</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t9mosi_dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გადასარჩენად მონაცემების გამოტანა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17spi_flash_trans_t9miso_dataE">
<span id="_CPPv3N17spi_flash_trans_t9miso_dataE"></span><span id="_CPPv2N17spi_flash_trans_t9miso_dataE"></span><span id="spi_flash_trans_t::miso_data__uint8_tP"></span><span class="target" id="structspi__flash__trans__t_1a87ee657fb9bf3d8e3adb01fdc8a23997"></span>uint8_t *<code class="descname">miso_data</code><a class="headerlink" href="spi_flash.html#_CPPv4N17spi_flash_trans_t9miso_dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>[გამომავალი] შეყვანის მონაცემები მონიდან, პატარა ენდიანიდან </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv423spi_flash_host_driver_t">
<span id="_CPPv323spi_flash_host_driver_t"></span><span id="_CPPv223spi_flash_host_driver_t"></span><span id="spi_flash_host_driver_t"></span><span class="target" id="structspi__flash__host__driver__t"></span><em class="property">სტრუქტურა </em><code class="descname">spi_flash_host_driver_t</code><a class="headerlink" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჰოსტის დრაივერის კონფიგურაცია და კონტექსტური სტრუქტურა. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t11driver_dataE">
<span id="_CPPv3N23spi_flash_host_driver_t11driver_dataE"></span><span id="_CPPv2N23spi_flash_host_driver_t11driver_dataE"></span><span id="spi_flash_host_driver_t::driver_data__voidP"></span><span class="target" id="structspi__flash__host__driver__t_1a3ae02aad1b74e86691ad24c40940b1a4"></span>void *<code class="descname">driver_data</code><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t11driver_dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>კონკრეტული ჰოსტის დრაივერის მიერ გამოყენებული კონფიგურაცია და სტატიკური მონაცემები. ტიპი განისაზღვრება ჰოსტის დრაივერის მიერ. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t10dev_configE">
<span id="_CPPv3N23spi_flash_host_driver_t10dev_configE"></span><span id="_CPPv2N23spi_flash_host_driver_t10dev_configE"></span><span class="target" id="structspi__flash__host__driver__t_1a28a7fdd1293ecfad7172158fd943ca78"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">dev_config</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t10dev_configE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოწყობილობასთან დაკავშირებული რეგისტრის კონფიგურაცია ტრანზაქციების დაწყებამდე. ეს ზოგავს გარკვეულ დროს ამ რეგისტრების ხელახლა კონფიგურაციისთვის, როდესაც ჩვენ უწყვეტად ვაგზავნით. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t14common_commandE">
<span id="_CPPv3N23spi_flash_host_driver_t14common_commandE"></span><span id="_CPPv2N23spi_flash_host_driver_t14common_commandE"></span><span class="target" id="structspi__flash__host__driver__t_1ace0f9954836dec8079ac6968914be4f3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">common_command</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, <a class="reference internal" href="spi_flash.html#_CPPv417spi_flash_trans_t" title="spi_flash_trans_t">spi_ ფლეშ მეხსიერება _trans_t</a> *t<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t14common_commandE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოწყობილობისთვის მომხმარებლის მიერ განსაზღვრული spi ტრანზაქციის გაგზავნა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t7read_idE">
<span id="_CPPv3N23spi_flash_host_driver_t7read_idE"></span><span id="_CPPv2N23spi_flash_host_driver_t7read_idE"></span><span class="target" id="structspi__flash__host__driver__t_1aeb3a4445babe1db85ea8a060751ab34b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">read_id</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint32_t *id<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t7read_idE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ ფლეშ მეხსიერება ID. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t10erase_chipE">
<span id="_CPPv3N23spi_flash_host_driver_t10erase_chipE"></span><span id="_CPPv2N23spi_flash_host_driver_t10erase_chipE"></span><span class="target" id="structspi__flash__host__driver__t_1a284b37bcc4a376ee49e6b3c8cecf3492"></span>void (*<code class="descname">erase_chip</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t10erase_chipE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაშალეთ მთელი ფლეშ მეხსიერება ჩიპი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t12erase_sectorE">
<span id="_CPPv3N23spi_flash_host_driver_t12erase_sectorE"></span><span id="_CPPv2N23spi_flash_host_driver_t12erase_sectorE"></span><span class="target" id="structspi__flash__host__driver__t_1a58b531a9f1c8ba6946b780db6b7f8645"></span>void (*<code class="descname">erase_sector</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint32_t start_address<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t12erase_sectorE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>კონკრეტული სექტორის წაშლა მისი საწყისი მისამართით. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t11erase_blockE">
<span id="_CPPv3N23spi_flash_host_driver_t11erase_blockE"></span><span id="_CPPv2N23spi_flash_host_driver_t11erase_blockE"></span><span class="target" id="structspi__flash__host__driver__t_1aea205b59bfb173d65b59610b5cc9fb54"></span>void (*<code class="descname">erase_block</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint32_t start_address<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t11erase_blockE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>კონკრეტული ბლოკის წაშლა მისი საწყისი მისამართით. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t11read_statusE">
<span id="_CPPv3N23spi_flash_host_driver_t11read_statusE"></span><span id="_CPPv2N23spi_flash_host_driver_t11read_statusE"></span><span class="target" id="structspi__flash__host__driver__t_1a3015014d6500993e2282347ce2c08ccf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">read_status</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint8_t *out_sr<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t11read_statusE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ ფლეშ მეხსიერება ჩიპის სტატუსი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t17set_write_protectE">
<span id="_CPPv3N23spi_flash_host_driver_t17set_write_protectE"></span><span id="_CPPv2N23spi_flash_host_driver_t17set_write_protectE"></span><span class="target" id="structspi__flash__host__driver__t_1a86cbdd18a1ee664517b846a3d03b32f2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">set_write_protect</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, bool wp<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t17set_write_protectE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩაწერის დაცვის გამორთვა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t12program_pageE">
<span id="_CPPv3N23spi_flash_host_driver_t12program_pageE"></span><span id="_CPPv2N23spi_flash_host_driver_t12program_pageE"></span><span class="target" id="structspi__flash__host__driver__t_1aa4b937218b7605e23d5b7b2d63ccc6ee"></span>void (*<code class="descname">program_page</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, <em class="property">კონსტ</em> void *buffer, uint32_t address, uint32_t length<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t12program_pageE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაპროგრამეთ ფლეშ მეხსიერება ის გვერდი. შეამოწმეთ <code class="docutils literal notranslate"><span class="pre">max_write_bytes</span></code> მაქსიმალური დაშვებული ჩაწერის სიგრძისთვის. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t21supports_direct_writeE">
<span id="_CPPv3N23spi_flash_host_driver_t21supports_direct_writeE"></span><span id="_CPPv2N23spi_flash_host_driver_t21supports_direct_writeE"></span><span class="target" id="structspi__flash__host__driver__t_1aba51fd8f22490b15e799b00f00f6f846"></span>bool (*<code class="descname">supports_direct_write</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, <em class="property">კონსტ</em> void *p<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t21supports_direct_writeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ, საჭიროა თუ არა ჩასაწერად ახალი ბუფერის გამოყოფა </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t20supports_direct_readE">
<span id="_CPPv3N23spi_flash_host_driver_t20supports_direct_readE"></span><span id="_CPPv2N23spi_flash_host_driver_t20supports_direct_readE"></span><span class="target" id="structspi__flash__host__driver__t_1ae7c0d8e6a06edc0c86a472429231a400"></span>bool (*<code class="descname">supports_direct_read</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, <em class="property">კონსტ</em> void *p<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t20supports_direct_readE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ, საჭიროა თუ არა წასაკითხად ახალი ბუფერის გამოყოფა </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t15max_write_bytesE">
<span id="_CPPv3N23spi_flash_host_driver_t15max_write_bytesE"></span><span id="_CPPv2N23spi_flash_host_driver_t15max_write_bytesE"></span><span id="spi_flash_host_driver_t::max_write_bytes__i"></span><span class="target" id="structspi__flash__host__driver__t_1a7aea5a981def907f1a7182d7bbf7e18b"></span>int <code class="descname">max_write_bytes</code><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t15max_write_bytesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პროგრამის_გვერდის მაქსიმალური სიგრძე </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t4readE">
<span id="_CPPv3N23spi_flash_host_driver_t4readE"></span><span id="_CPPv2N23spi_flash_host_driver_t4readE"></span><span class="target" id="structspi__flash__host__driver__t_1a5af42e7cf41c360af76c1d98ebe9491b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">read</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, void *buffer, uint32_t address, uint32_t read_len<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t4readE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ მონაცემები ფლეშ მეხსიერება დან. შეამოწმეთ <code class="docutils literal notranslate"><span class="pre">max_read_bytes</span></code> მაქსიმალური დასაშვები კითხვის სიგრძისთვის. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t14max_read_bytesE">
<span id="_CPPv3N23spi_flash_host_driver_t14max_read_bytesE"></span><span id="_CPPv2N23spi_flash_host_driver_t14max_read_bytesE"></span><span id="spi_flash_host_driver_t::max_read_bytes__i"></span><span class="target" id="structspi__flash__host__driver__t_1afaa441765522f17ed2e59a52a01e6128"></span>int <code class="descname">max_read_bytes</code><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t14max_read_bytesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაკითხვის მაქსიმალური ხანგრძლივობა </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t9host_idleE">
<span id="_CPPv3N23spi_flash_host_driver_t9host_idleE"></span><span id="_CPPv2N23spi_flash_host_driver_t9host_idleE"></span><span class="target" id="structspi__flash__host__driver__t_1a0266ffc791c9534adaf552af0e392de6"></span>bool (*<code class="descname">host_idle</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t9host_idleE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ, ჰოსტი უმოქმედოა თუ არა ახალი ოპერაციების შესასრულებლად. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t22configure_host_io_modeE">
<span id="_CPPv3N23spi_flash_host_driver_t22configure_host_io_modeE"></span><span id="_CPPv2N23spi_flash_host_driver_t22configure_host_io_modeE"></span><span class="target" id="structspi__flash__host__driver__t_1a4082336a3e8751be7e07617a2713d2e9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">configure_host_io_mode</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint32_t command, uint32_t addr_bitlen, int dummy_bitlen_base, <a class="reference internal" href="spi_flash.html#_CPPv419esp_flash_io_mode_t" title="esp_flash_io_mode_t">esp_ ფლეშ მეხსიერება _io_mode_t</a> io_mode<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t22configure_host_io_modeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჰოსტის კონფიგურაცია სხვადასხვა წაკითხვის რეჟიმში სამუშაოდ. პასუხისმგებელია დროის კომპენსაციაზე და IO რეჟიმის დაყენებაზე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t13poll_cmd_doneE">
<span id="_CPPv3N23spi_flash_host_driver_t13poll_cmd_doneE"></span><span id="_CPPv2N23spi_flash_host_driver_t13poll_cmd_doneE"></span><span class="target" id="structspi__flash__host__driver__t_1aa9126c0b580942387dbf7832c4ad51c5"></span>void (*<code class="descname">poll_cmd_done</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t13poll_cmd_doneE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შიდა გამოყენებისთვის, აპარატურის გამოკითხვა ბოლო ოპერაციის დასრულებამდე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N23spi_flash_host_driver_t11flush_cacheE">
<span id="_CPPv3N23spi_flash_host_driver_t11flush_cacheE"></span><span id="_CPPv2N23spi_flash_host_driver_t11flush_cacheE"></span><span class="target" id="structspi__flash__host__driver__t_1a6772f98e69c2d60425c648e73cde1e05"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">flush_cache</code>)<span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> *driver, uint32_t addr, uint32_t size<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv4N23spi_flash_host_driver_t11flush_cacheE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ზოგიერთი ჰოსტის (SPI1) შემთხვევაში, ისინი ქეშთან არის გაზიარებული. მონაცემების შეცვლისას, ქეში უნდა გაიწმინდოს. თუ არ არის მხარდაჭერილი, დატოვეთ NULL. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="spi_flash.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.ESP_FLASH_SPEED_MIN">
<span class="target" id="spi__flash__types_8h_1a09572757aee5bd5400c465c0f0673e11"></span><code class="descname">ESP_FLASH_SPEED_MIN</code><a class="headerlink" href="spi_flash.html#c.ESP_FLASH_SPEED_MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>დრაივერის მიერ მხარდაჭერილი ყველაზე დაბალი სიჩქარე, ამჟამად 5 MHz. </p>
</dd></dl>
<dl class="macro">
<dt id="c.SPI_FLASH_READ_MODE_MIN">
<span class="target" id="spi__flash__types_8h_1a08d0d2c78907587f31fb100bc7322726"></span><code class="descname">SPI_FLASH_READ_MODE_MIN</code><a class="headerlink" href="spi_flash.html#c.SPI_FLASH_READ_MODE_MIN" title="Permalink to this definition">¶</a></dt>
<dd><p>ESP32-ის მიერ მხარდაჭერილი ყველაზე ნელი io რეჟიმი, ამჟამად SlowRd. </p>
</dd></dl>
</div>
<div class="section" id="id7">
<h3>ტიპის განმარტებები<a class="headerlink" href="spi_flash.html#id7" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv423spi_flash_host_driver_t">
<span id="_CPPv323spi_flash_host_driver_t"></span><span id="_CPPv223spi_flash_host_driver_t"></span><span class="target" id="spi__flash__types_8h_1a7a9ac73d851df02f3fb297c1bd1af36a"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="spi_flash.html#_CPPv423spi_flash_host_driver_t" title="spi_flash_host_driver_t">spi_ ფლეშ მეხსიერება _host_driver_t</a> <code class="descname">spi_flash_host_driver_t</code><br/></dt>
<dd></dd></dl>
</div>
<div class="section" id="enumerations">
<h3>ჩამოთვლები<a class="headerlink" href="spi_flash.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv417esp_flash_speed_t">
<span id="_CPPv317esp_flash_speed_t"></span><span id="_CPPv217esp_flash_speed_t"></span><span id="esp_flash_speed_t"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_flash_speed_t</code><a class="headerlink" href="spi_flash.html#_CPPv417esp_flash_speed_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება საათის სიჩქარის მნიშვნელობებისთვის, ყოველთვის მიუთითეთ ისინი ჩამოთვლით და არა ფაქტობრივი მნიშვნელობით (სიაში შეიძლება დაემატოს მეტი სიჩქარე). </p>
<p>მაქსიმალური დაშვებული სიჩქარის შესარჩევად ერთ-ერთი სტრატეგიაა ჩამოთვლა შემდეგიდან: <code class="docutils literal notranslate"><span class="pre">ESP_FLSH_SPEED_MAX-1</span></code> ან თქვენი ფლეშ მეხსიერება მიერ მხარდაჭერილი ყველაზე მაღალი სიხშირე და შეამცირეთ სიჩქარე ზონდირების წარმატებამდე. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv414ESP_FLASH_5MHZ">
<span id="_CPPv314ESP_FLASH_5MHZ"></span><span id="_CPPv214ESP_FLASH_5MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3a1cab8d6e02721883cfc7ff5461ef8785"></span><code class="descname">ESP_FLASH_5MHZ</code> = 0<a class="headerlink" href="spi_flash.html#_CPPv414ESP_FLASH_5MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 5 MHz სიხშირეზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv415ESP_FLASH_10MHZ">
<span id="_CPPv315ESP_FLASH_10MHZ"></span><span id="_CPPv215ESP_FLASH_10MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3ae55c8e7045c3263b6cad136cad565bcf"></span><code class="descname">ESP_FLASH_10MHZ</code><a class="headerlink" href="spi_flash.html#_CPPv415ESP_FLASH_10MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 10 MHz-ზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv415ESP_FLASH_20MHZ">
<span id="_CPPv315ESP_FLASH_20MHZ"></span><span id="_CPPv215ESP_FLASH_20MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3a632abdc5eb62f5a6ce23eaa199aac478"></span><code class="descname">ESP_FLASH_20MHZ</code><a class="headerlink" href="spi_flash.html#_CPPv415ESP_FLASH_20MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 20 MHz-ზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv415ESP_FLASH_26MHZ">
<span id="_CPPv315ESP_FLASH_26MHZ"></span><span id="_CPPv215ESP_FLASH_26MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3acabc9fa546bce680962b7ff66426b6c9"></span><code class="descname">ESP_FLASH_26MHZ</code><a class="headerlink" href="spi_flash.html#_CPPv415ESP_FLASH_26MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 26 MHz სიხშირეზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv415ESP_FLASH_40MHZ">
<span id="_CPPv315ESP_FLASH_40MHZ"></span><span id="_CPPv215ESP_FLASH_40MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3a9fb715119a227e64c18e5d57616ee45d"></span><code class="descname">ESP_FLASH_40MHZ</code><a class="headerlink" href="spi_flash.html#_CPPv415ESP_FLASH_40MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 40 MHz-ზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv415ESP_FLASH_80MHZ">
<span id="_CPPv315ESP_FLASH_80MHZ"></span><span id="_CPPv215ESP_FLASH_80MHZ"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3a10a689d90b3fef763fedecc27b5a0d5f"></span><code class="descname">ESP_FLASH_80MHZ</code><a class="headerlink" href="spi_flash.html#_CPPv415ESP_FLASH_80MHZ" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება მუშაობს 80 MHz სიხშირეზე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv419ESP_FLASH_SPEED_MAX">
<span id="_CPPv319ESP_FLASH_SPEED_MAX"></span><span id="_CPPv219ESP_FLASH_SPEED_MAX"></span><span class="target" id="spi__flash__types_8h_1a1d61b6d6460ebab8969b7adf0495d1f3a612f2e1e2af71c2f0c83b7dfefd21a50"></span><code class="descname">ESP_FLASH_SPEED_MAX</code><a class="headerlink" href="spi_flash.html#_CPPv419ESP_FLASH_SPEED_MAX" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მასპინძლის მიერ მხარდაჭერილი მაქსიმალური სიხშირეა <code class="docutils literal notranslate"><span class="pre">ESP_FLASH_SPEED_MAX-1</span></code>. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv419esp_flash_io_mode_t">
<span id="_CPPv319esp_flash_io_mode_t"></span><span id="_CPPv219esp_flash_io_mode_t"></span><span id="esp_flash_io_mode_t"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_flash_io_mode_t</code><a class="headerlink" href="spi_flash.html#_CPPv419esp_flash_io_mode_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება დან წასაკითხად გამოყენებული რეჟიმი. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv416SPI_FLASH_SLOWRD">
<span id="_CPPv316SPI_FLASH_SLOWRD"></span><span id="_CPPv216SPI_FLASH_SLOWRD"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88a33fa10dbe9954678f51a2b879ecf8ea0"></span><code class="descname">SPI_FLASH_SLOWRD</code> = 0<a class="headerlink" href="spi_flash.html#_CPPv416SPI_FLASH_SLOWRD" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების წაკითხვა ხდება ერთი შეყვანის/გამოყვანის გამოყენებით, სიჩქარის გარკვეული შეზღუდვებით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv416SPI_FLASH_FASTRD">
<span id="_CPPv316SPI_FLASH_FASTRD"></span><span id="_CPPv216SPI_FLASH_FASTRD"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88a9ecddeabc897117f4b973ab6cf9aeb86"></span><code class="descname">SPI_FLASH_FASTRD</code><a class="headerlink" href="spi_flash.html#_CPPv416SPI_FLASH_FASTRD" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების წაკითხვა შესაძლებელია ერთი შეყვანის/გამოყვანის გამოყენებით, სიჩქარის შეზღუდვის გარეშე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv414SPI_FLASH_DOUT">
<span id="_CPPv314SPI_FLASH_DOUT"></span><span id="_CPPv214SPI_FLASH_DOUT"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88aa36a6bbcf39b8c0aaf335e04910f8b7d"></span><code class="descname">SPI_FLASH_DOUT</code><a class="headerlink" href="spi_flash.html#_CPPv414SPI_FLASH_DOUT" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების წაკითხვა ორმაგი შეყვანის/გამოყვანის გამოყენებით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv413SPI_FLASH_DIO">
<span id="_CPPv313SPI_FLASH_DIO"></span><span id="_CPPv213SPI_FLASH_DIO"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88aa860b6d73aecb05afdf29a316be8a192"></span><code class="descname">SPI_FLASH_DIO</code><a class="headerlink" href="spi_flash.html#_CPPv413SPI_FLASH_DIO" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>როგორც მისამართი, ასევე მონაცემები გადაიცემა ორმაგი შეყვანის/გამოყვანის გამოყენებით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv414SPI_FLASH_QOUT">
<span id="_CPPv314SPI_FLASH_QOUT"></span><span id="_CPPv214SPI_FLASH_QOUT"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88aee60fb3a08f89320a8b8f17febfd3c04"></span><code class="descname">SPI_FLASH_QOUT</code><a class="headerlink" href="spi_flash.html#_CPPv414SPI_FLASH_QOUT" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების წაკითხვა quad I/O-ს გამოყენებით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv413SPI_FLASH_QIO">
<span id="_CPPv313SPI_FLASH_QIO"></span><span id="_CPPv213SPI_FLASH_QIO"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88af170aa9a057beb7aa7e0fa75823413cc"></span><code class="descname">SPI_FLASH_QIO</code><a class="headerlink" href="spi_flash.html#_CPPv413SPI_FLASH_QIO" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>როგორც მისამართი, ასევე მონაცემები გადადის quad I/O-ს გამოყენებით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv423SPI_FLASH_READ_MODE_MAX">
<span id="_CPPv323SPI_FLASH_READ_MODE_MAX"></span><span id="_CPPv223SPI_FLASH_READ_MODE_MAX"></span><span class="target" id="spi__flash__types_8h_1aed5e725de9342f7843c931c3d5119c88ac9b6bffcb1b257f00f0ac5bce2109d58"></span><code class="descname">SPI_FLASH_READ_MODE_MAX</code><a class="headerlink" href="spi_flash.html#_CPPv423SPI_FLASH_READ_MODE_MAX" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მასპინძლის მიერ მხარდაჭერილი ყველაზე სწრაფი io რეჟიმია <code class="docutils literal notranslate"><span class="pre">ESP_FLASH_READ_MODE_MAX-1</span></code>. </p>
</dd></dl>
</dd></dl>
</div>
</div>
<div class="section" id="api-reference-partition-table">
<h2>API მითითება - დანაყოფების ცხრილი<a class="headerlink" href="spi_flash.html#api-reference-partition-table" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>სათაურის ფაილი<a class="headerlink" href="spi_flash.html#id8" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/spi_flash/include/esp_partition.h">spi_ ფლეშ მეხსიერება /include/esp_partition.h</a></li>
</ul>
</div>
<div class="section" id="id9">
<h3>ფუნქციები<a class="headerlink" href="spi_flash.html#id9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv418esp_partition_find20esp_partition_type_t23esp_partition_subtype_tPKc">
<span id="_CPPv318esp_partition_find20esp_partition_type_t23esp_partition_subtype_tPKc"></span><span id="_CPPv218esp_partition_find20esp_partition_type_t23esp_partition_subtype_tPKc"></span><span id="esp_partition_find__esp_partition_type_t.esp_partition_subtype_t.cCP"></span><span class="target" id="esp__partition_8h_1a85dcccff0ad74060831ce3d33b59270c"></span><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="esp_partition_iterator_t">esp_partition_iterator_t</a> <code class="descname">esp_partition_find</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv420esp_partition_type_t" title="esp_partition_type_t">esp_partition_type_t</a> <em>ტიპი</em>, <a class="reference internal" href="spi_flash.html#_CPPv423esp_partition_subtype_t" title="esp_partition_subtype_t">esp_partition_subtype_t</a> <em>ქვეტიპი</em>, <em class="property">კონსტ</em> char *<em>ეტიკეტი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv418esp_partition_find20esp_partition_type_t23esp_partition_subtype_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>იპოვეთ დანაყოფი ერთი ან მეტი პარამეტრის მიხედვით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>iterator which can be used to enumerate all the partitions found, or NULL if no partitions were found. Iterator obtained through this function has to be released using esp_partition_iterator_release when not used any more. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: დანაყოფის ტიპი, esp_partition_type_t მნიშვნელობებიდან ერთ-ერთი </li>
<li><code class="docutils literal notranslate"><span class="pre">subtype</span></code>: დანაყოფის ქვეტიპი, esp_partition_subtype_t მნიშვნელობებიდან ერთ-ერთი. მოცემული ტიპის ყველა დანაყოფის მოსაძებნად გამოიყენეთ ESP_PARTITION_SUBTYPE_ANY. </li>
<li><code class="docutils literal notranslate"><span class="pre">label</span></code>: (არასავალდებულო) დანაყოფის იარლიყი. დააყენეთ ეს მნიშვნელობა, თუ კონკრეტული სახელის მქონე დანაყოფს ეძებთ. სხვა შემთხვევაში, შეიყვანეთ NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424esp_partition_find_first20esp_partition_type_t23esp_partition_subtype_tPKc">
<span id="_CPPv324esp_partition_find_first20esp_partition_type_t23esp_partition_subtype_tPKc"></span><span id="_CPPv224esp_partition_find_first20esp_partition_type_t23esp_partition_subtype_tPKc"></span><span id="esp_partition_find_first__esp_partition_type_t.esp_partition_subtype_t.cCP"></span><span class="target" id="esp__partition_8h_1a7d77af6e5cb9311468e8bdd2a502ac15"></span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<code class="descname">esp_partition_find_first</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv420esp_partition_type_t" title="esp_partition_type_t">esp_partition_type_t</a> <em>ტიპი</em>, <a class="reference internal" href="spi_flash.html#_CPPv423esp_partition_subtype_t" title="esp_partition_subtype_t">esp_partition_subtype_t</a> <em>ქვეტიპი</em>, <em class="property">კონსტ</em> char *<em>ეტიკეტი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv424esp_partition_find_first20esp_partition_type_t23esp_partition_subtype_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პირველი დანაყოფის პოვნა ერთი ან მეტი პარამეტრის მიხედვით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pointer to <a class="reference internal" href="spi_flash.html#structesp__partition__t"><span class="std std-ref">esp_partition_t</span></a> structure, or NULL if no partition is found. This pointer is valid for the lifetime of the application. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: დანაყოფის ტიპი, esp_partition_type_t მნიშვნელობებიდან ერთ-ერთი </li>
<li><code class="docutils literal notranslate"><span class="pre">subtype</span></code>: დანაყოფის ქვეტიპი, esp_partition_subtype_t მნიშვნელობებიდან ერთ-ერთი. მოცემული ტიპის ყველა დანაყოფის მოსაძებნად გამოიყენეთ ESP_PARTITION_SUBTYPE_ANY. </li>
<li><code class="docutils literal notranslate"><span class="pre">label</span></code>: (არასავალდებულო) დანაყოფის იარლიყი. დააყენეთ ეს მნიშვნელობა, თუ კონკრეტული სახელის მქონე დანაყოფს ეძებთ. სხვა შემთხვევაში, შეიყვანეთ NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417esp_partition_get24esp_partition_iterator_t">
<span id="_CPPv317esp_partition_get24esp_partition_iterator_t"></span><span id="_CPPv217esp_partition_get24esp_partition_iterator_t"></span><span id="esp_partition_get__esp_partition_iterator_t"></span><span class="target" id="esp__partition_8h_1a83e78791a597dedefe138c98b5193e94"></span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<code class="descname">esp_partition_get</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="esp_partition_iterator_t">esp_partition_iterator_t</a> <em>იტერატორი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv417esp_partition_get24esp_partition_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიღება <a class="reference internal" href="spi_flash.html#structesp__partition__t"><span class="std std-ref">esp_partition_t</span></a> მოცემული დანაყოფის სტრუქტურა. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pointer to <a class="reference internal" href="spi_flash.html#structesp__partition__t"><span class="std std-ref">esp_partition_t</span></a> structure. This pointer is valid for the lifetime of the application. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>იტერატორი მიღებულია esp_partition_find-ის გამოყენებით. არ უნდა იყოს NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_partition_next24esp_partition_iterator_t">
<span id="_CPPv318esp_partition_next24esp_partition_iterator_t"></span><span id="_CPPv218esp_partition_next24esp_partition_iterator_t"></span><span id="esp_partition_next__esp_partition_iterator_t"></span><span class="target" id="esp__partition_8h_1ad9b6d627b971e7f9ee5d75c42a5ffd55"></span><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="esp_partition_iterator_t">esp_partition_iterator_t</a> <code class="descname">esp_partition_next</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="esp_partition_iterator_t">esp_partition_iterator_t</a> <em>იტერატორი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv418esp_partition_next24esp_partition_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის იტერატორის გადატანა შემდეგ ნაპოვნი დანაყოფზე. </p>
<p>ამ გამოძახების შემდეგ იტერატორის ნებისმიერი ასლი არასწორი იქნება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>NULL if no partition was found, valid esp_partition_iterator_t otherwise. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>იტერატორი მიღებულია esp_partition_find-ის გამოყენებით. არ უნდა იყოს NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430esp_partition_iterator_release24esp_partition_iterator_t">
<span id="_CPPv330esp_partition_iterator_release24esp_partition_iterator_t"></span><span id="_CPPv230esp_partition_iterator_release24esp_partition_iterator_t"></span><span id="esp_partition_iterator_release__esp_partition_iterator_t"></span><span class="target" id="esp__partition_8h_1a2aab4e64009b62333bd848d60d4511c9"></span>void <code class="descname">esp_partition_iterator_release</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="esp_partition_iterator_t">esp_partition_iterator_t</a> <em>იტერატორი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv430esp_partition_iterator_release24esp_partition_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაუშვით დანაყოფის იტერატორი. </p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>იტერატორი მიღებულია esp_partition_find-ის გამოყენებით. არ უნდა იყოს NULL. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420esp_partition_verifyPK15esp_partition_t">
<span id="_CPPv320esp_partition_verifyPK15esp_partition_t"></span><span id="_CPPv220esp_partition_verifyPK15esp_partition_t"></span><span id="esp_partition_verify__esp_partition_tCP"></span><span class="target" id="esp__partition_8h_1ac7aa68544327a90a6961ba77c00ad008"></span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<code class="descname">esp_partition_verify</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv420esp_partition_verifyPK15esp_partition_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის მონაცემების გადამოწმება. </p>
<p>დანაყოფის მონაცემების მითითების გათვალისწინებით, გადაამოწმეთ, რომ ეს დანაყოფი არსებობს დანაყოფების ცხრილი ში (ყველა ველი ემთხვევა).</p>
<p>ეს ფუნქცია ასევე სასარგებლოა RAM ბუფერში არსებული დანაყოფის მონაცემების ასაღებად და ფლეშ მეხსიერება ში შენახული მუდმივი დანაყოფის მონაცემების მაჩვენებლად გადასაყვანად.</p>
<p>ამ ფუნქციიდან დაბრუნებული მაჩვენებლების შედარება შესაძლებელია პირდაპირ ნებისმიერი დაბრუნებული მაჩვენებლის მისამართთან. <a class="reference internal" href="spi_flash.html#esp__partition_8h_1a83e78791a597dedefe138c98b5193e94"><span class="std std-ref">esp_partition_get()</span></a>, როგორც თანასწორობის ტესტი.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>თუ დანაყოფი ვერ მოიძებნა, აბრუნებს NULL-ს.</li>
<li>თუ მოიძებნება, აბრუნებს მაჩვენებელს <a class="reference internal" href="spi_flash.html#structesp__partition__t"><span class="std std-ref">esp_partition_t</span></a> სტრუქტურა ფლეშ მეხსიერება ში. ეს მაჩვენებელი ყოველთვის ვალიდურია აპლიკაციის მთელი სიცოცხლის განმავლობაში. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: დანაყოფის მონაცემების მაჩვენებელი დასადასტურებლად. არ უნდა იყოს NULL. ამ სტრუქტურის ყველა ველი უნდა ემთხვეოდეს ფლეშ მეხსიერება ში დანაყოფების ცხრილი ჩანაწერს, რათა ამ ფუნქციამ წარმატებით დააბრუნოს შესაბამისობა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_partition_readPK15esp_partition_t6size_tPv6size_t">
<span id="_CPPv318esp_partition_readPK15esp_partition_t6size_tPv6size_t"></span><span id="_CPPv218esp_partition_readPK15esp_partition_t6size_tPv6size_t"></span><span id="esp_partition_read__esp_partition_tCP.s.voidP.s"></span><span class="target" id="esp__partition_8h_1a27e1a0de4bbe8d79f4bf243b6d001b2f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_read</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, size_t <em>src_ოფსეტი</em>, void *<em>თარიღი</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv418esp_partition_readPK15esp_partition_t6size_tPv6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ მონაცემები დანაყოფიდან. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK, if data was read successfully; ESP_ERR_INVALID_ARG, if src_offset exceeds partition size; ESP_ERR_INVALID_SIZE, if read would go out of bounds of the partition; or one of error codes from lower-level flash driver. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">dst</span></code>: მაჩვენებელი ბუფერისკენ, სადაც მონაცემები უნდა იყოს შენახული. მაჩვენებელი უნდა იყოს არა-NULL და ბუფერის სიგრძე უნდა იყოს მინიმუმ &amp;#39;ზომა&amp;#39; ბაიტები. </li>
<li><code class="docutils literal notranslate"><span class="pre">src_offset</span></code>წასაკითხი მონაცემების მისამართი, დანაყოფის დასაწყისთან მიმართებაში. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: წასაკითხი მონაცემების ზომა, ბაიტებში.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419esp_partition_writePK15esp_partition_t6size_tPKv6size_t">
<span id="_CPPv319esp_partition_writePK15esp_partition_t6size_tPKv6size_t"></span><span id="_CPPv219esp_partition_writePK15esp_partition_t6size_tPKv6size_t"></span><span id="esp_partition_write__esp_partition_tCP.s.voidCP.s"></span><span class="target" id="esp__partition_8h_1a03828b180e5284655d5356c9fa1e0304"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_write</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, size_t <em>dst_offset</em>, <em class="property">კონსტ</em> void *<em>src</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv419esp_partition_writePK15esp_partition_t6size_tPKv6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემების ჩაწერა დანაყოფში. </p>
<p>ფლეშ მეხსიერება ში მონაცემების ჩაწერამდე, ფლეშ მეხსიერება ის შესაბამისი რეგიონი უნდა წაიშალოს. ეს შეიძლება გაკეთდეს esp_partition_erase_range ფუნქციის გამოყენებით.</p>
<p>დაშიფვრის დროშით მონიშნული დანაყოფები ავტომატურად ჩაიწერება spi_ ფლეშ მეხსიერება _write_encrypted() ფუნქციის მეშვეობით. დაშიფრულ დანაყოფზე ჩაწერის შემთხვევაში, ყველა ჩაწერის ოფსეტი და სიგრძე უნდა იყოს 16 ბაიტის ჯერადი. დამატებითი ინფორმაციისთვის იხილეთ spi_ ფლეშ მეხსიერება _write_encrypted() ფუნქცია. დაუშიფრავ დანაყოფებს ეს შეზღუდვა არ აქვთ.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Prior to writing to flash memory, make sure it has been erased with esp_partition_erase_range call.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK, if data was written successfully; ESP_ERR_INVALID_ARG, if dst_offset exceeds partition size; ESP_ERR_INVALID_SIZE, if write would go out of bounds of the partition; or one of error codes from lower-level flash driver. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">dst_offset</span></code>მისამართი, სადაც მონაცემები უნდა ჩაიწეროს, დანაყოფის დასაწყისთან მიმართებაში. </li>
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: წყაროს ბუფერის მაჩვენებელი. მაჩვენებელი უნდა იყოს არა-NULL და ბუფერის სიგრძე უნდა იყოს მინიმუმ &amp;#39;ზომა&amp;#39; ბაიტები. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: ჩასაწერი მონაცემების ზომა, ბაიტებში.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425esp_partition_erase_rangePK15esp_partition_t6size_t6size_t">
<span id="_CPPv325esp_partition_erase_rangePK15esp_partition_t6size_t6size_t"></span><span id="_CPPv225esp_partition_erase_rangePK15esp_partition_t6size_t6size_t"></span><span id="esp_partition_erase_range__esp_partition_tCP.s.s"></span><span class="target" id="esp__partition_8h_1ae3846ccf50cbf282d31d0919f69fd463"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_erase_range</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, size_t <em>ოფსეტი</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv425esp_partition_erase_rangePK15esp_partition_t6size_t6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ნაწილის წაშლა. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK, if the range was erased successfully; ESP_ERR_INVALID_ARG, if iterator or dst are NULL; ESP_ERR_INVALID_SIZE, if erase would go out of bounds of the partition; or one of error codes from lower-level flash driver. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: გადახრა იმ დანაყოფის დასაწყისიდან, სადაც წაშლის ოპერაცია უნდა დაიწყოს. უნდა იყოს გასწორებული 4 კილობაიტთან. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: წასაშლელი დიაპაზონის ზომა ბაიტებში. უნდა გაიყოს 4 კილობაიტზე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t">
<span id="_CPPv318esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t"></span><span id="_CPPv218esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t"></span><span id="esp_partition_mmap__esp_partition_tCP.s.s.spi_flash_mmap_memory_t.voidCPP.spi_flash_mmap_handle_tP"></span><span class="target" id="esp__partition_8h_1a5b44cc377960664a28259ecc80ac435e"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_mmap</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, size_t <em>ოფსეტი</em>, size_t <em>ზომა</em>, spi_flash_mmap_memory_t <em>მეხსიერება</em>, <em class="property">კონსტ</em> void **<em>გამომავალი_პტრ</em>, spi_flash_mmap_handle_t *<em>გაუმკლავებელი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv418esp_partition_mmapPK15esp_partition_t6size_t6size_t23spi_flash_mmap_memory_tPPKvP23spi_flash_mmap_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააკონფიგურირეთ MMU დანაყოფის მონაცემთა მეხსიერებაში გამოსაყენებლად. </p>
<p>spi_ ფლეშ მეხსიერება _mmap ფუნქციისგან განსხვავებით, რომელიც 64 კბ-იან გასწორებულ საბაზისო მისამართს მოითხოვს, ეს ფუნქცია ასეთ მოთხოვნას არ აწესებს. თუ offset-ის შედეგად ფლეშ მეხსიერება მისამართი 64 კბ-იან საზღვარს არ შეესაბამება, მისამართი დამრგვალდება ქვედა 64 კბ-იან საზღვრამდე, ისე, რომ მიმაგრებული რეგიონი მოიცავდეს მოთხოვნილ დიაპაზონს. Out_ptr არგუმენტით დაბრუნებული მაჩვენებელი მორგებული იქნება მოთხოვნილ offset-ზე (არა აუცილებლად mmap-ით გასწორებული რეგიონის დასაწყისზე).</p>
<p>მიმაგრებული მეხსიერების გასათავისუფლებლად, out_handle არგუმენტით დაბრუნებული სახელური გადაეცით spi_ ფლეშ მეხსიერება _munmap ფუნქციას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK, if successful </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>: გადახრა დანაყოფის დასაწყისიდან, სადაც უნდა დაიწყოს მიმაგრება. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: რუკაზე დასატანი ტერიტორიის ზომა. </li>
<li><code class="docutils literal notranslate"><span class="pre">memory</span></code>მეხსიერების სივრცე, სადაც რეგიონი უნდა იყოს რუკაზე დატანილი </li>
<li><code class="docutils literal notranslate"><span class="pre">out_ptr</span></code>გამომავალი, მაჩვენებელი მეხსიერების შესაბამის რეგიონში </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>გამომავალი, სახელური, რომელიც უნდა იქნას გამოყენებული spi_ ფლეშ მეხსიერება _munmap გამოძახებისთვის.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424esp_partition_get_sha256PK15esp_partition_tP7uint8_t">
<span id="_CPPv324esp_partition_get_sha256PK15esp_partition_tP7uint8_t"></span><span id="_CPPv224esp_partition_get_sha256PK15esp_partition_tP7uint8_t"></span><span id="esp_partition_get_sha256__esp_partition_tCP.uint8_tP"></span><span class="target" id="esp__partition_8h_1a1f5be7f3fd4590e6b8c88e27daaf6ac8"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_get_sha256</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, uint8_t *<em>შა_256</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv424esp_partition_get_sha256PK15esp_partition_tP7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ SHA-256 დაიჯესტი საჭირო დანაყოფისთვის. </p>
<p>იმ აპლიკაციებისთვის, რომლებსაც აპლიკაციის სურათზე დამატებული აქვთ SHA-256, შედეგი არის აპლიკაციის სურათის კონტენტის დამატებული SHA-256 მნიშვნელობა. ჰეშის დადასტურება ხდება დაბრუნებამდე, თუ აპლიკაციის კონტენტი არასწორია, მაშინ ფუნქცია აბრუნებს ESP_ERR_IMAGE_INVALID-ს. იმ აპლიკაციებისთვის, რომლებსაც გამოსახულებაზე SHA-256 არ დამატებული აქვთ, შედეგი არის აპლიკაციის სურათში არსებული ყველა ბაიტის SHA-256. სხვა ტიპის დანაყოფისთვის, შედეგი არის მთელი დანაყოფის SHA-256.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატებული ოპერაციის შემთხვევაში.</li>
<li>ESP_ERR_INVALID_ARG: ზომა იყო 0 ან sha_256 იყო NULL.</li>
<li>ESP_ERR_NO_MEM: sha256 ოპერაციისთვის მეხსიერების გამოყოფა შეუძლებელია.</li>
<li>ESP_ERR_IMAGE_INVALID: აპლიკაციის დანაყოფი არ შეიცავს აპლიკაციის სწორ სურათს.</li>
<li>ESP_FAIL: მოხდა განაწილების შეცდომა. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: აპლიკაციის ან მონაცემების შემცველი დანაყოფის ინფორმაციის მითითება. (ველები: მისამართი, ზომა და ტიპი, სავალდებულოა შევსება). </li>
<li><code class="docutils literal notranslate"><span class="pre">sha_256</span></code>მოცემული დანაყოფისთვის დაბრუნებულია SHA-256 დაიჯესტი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428esp_partition_check_identityPK15esp_partition_tPK15esp_partition_t">
<span id="_CPPv328esp_partition_check_identityPK15esp_partition_tPK15esp_partition_t"></span><span id="_CPPv228esp_partition_check_identityPK15esp_partition_tPK15esp_partition_t"></span><span id="esp_partition_check_identity__esp_partition_tCP.esp_partition_tCP"></span><span class="target" id="esp__partition_8h_1aea8337c8d62a1f82e44285ca184c7b01"></span>bool <code class="descname">esp_partition_check_identity</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი_1</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი_2</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv428esp_partition_check_identityPK15esp_partition_tPK15esp_partition_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ ორი დანაყოფის იდენტურობა SHA-256 დაიჯესტის გამოყენებით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>მართალია: ორის შემთხვევაში, პროგრამული უზრუნველყოფა ტოლია.</li>
<li>მცდარი: წინააღმდეგ შემთხვევაში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_1</span></code>: აპლიკაცია ან მონაცემები 1-ის განყოფილების ინფორმაციის მითითება. (ველები: მისამართი, ზომა და ტიპი, შევსება სავალდებულოა). </li>
<li><code class="docutils literal notranslate"><span class="pre">partition_2</span></code>: მითითება აპლიკაციის ან მონაცემების შემცველი მე-2 განყოფილების ინფორმაციისკენ. (ველები: მისამართი, ზომა და ტიპი, სავალდებულოა შევსება).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv431esp_partition_register_externalP11esp_flash_t6size_t6size_tPKc20esp_partition_type_t23esp_partition_subtype_tPPK15esp_partition_t">
<span id="_CPPv331esp_partition_register_externalP11esp_flash_t6size_t6size_tPKc20esp_partition_type_t23esp_partition_subtype_tPPK15esp_partition_t"></span><span id="_CPPv231esp_partition_register_externalP11esp_flash_t6size_t6size_tPKc20esp_partition_type_t23esp_partition_subtype_tPPK15esp_partition_t"></span><span id="esp_partition_register_external__esp_flash_tP.s.s.cCP.esp_partition_type_t.esp_partition_subtype_t.esp_partition_tCPP"></span><span class="target" id="esp__partition_8h_1a6ee181fa232b371cbf1fd26cd788762b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_register_external</code><span class="sig-paren">(</span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<em>ფლეშ მეხსიერება _ჩიპი</em>, size_t <em>ოფსეტი</em>, size_t <em>ზომა</em>, <em class="property">კონსტ</em> char *<em>ეტიკეტი</em>, <a class="reference internal" href="spi_flash.html#_CPPv420esp_partition_type_t" title="esp_partition_type_t">esp_partition_type_t</a> <em>ტიპი</em>, <a class="reference internal" href="spi_flash.html#_CPPv423esp_partition_subtype_t" title="esp_partition_subtype_t">esp_partition_subtype_t</a> <em>ქვეტიპი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> **<em>გარეთ_დანაყოფი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv431esp_partition_register_externalP11esp_flash_t6size_t6size_tPKc20esp_partition_type_t23esp_partition_subtype_tPPK15esp_partition_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის რეგისტრაცია გარე ფლეშ მეხსიერება ჩიპზე. </p>
<p>ეს API საშუალებას იძლევა გარე ფლეშ მეხსიერება ჩიპების გარკვეული უბნების აღნიშვნისა (რომლებიც იდენტიფიცირებულია <a class="reference internal" href="spi_flash.html#structesp__flash__t"><span class="std std-ref">esp_ ფლეშ მეხსიერება _t</span></a> სტრუქტურა) დანაყოფებად. ეს საშუალებას იძლევა მათი გამოყენების კომპონენტი თან ერთად, რომლებიც SPI ფლეშ მეხსიერება წვდომას esp_partition API მეშვეობით ახდენენ.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_CONFIG_SPI_FLASH_USE_LEGACY_IMPL ჩართულია</li>
<li>ESP_ERR_NO_MEM თუ მეხსიერების გამოყოფა ვერ მოხერხდა</li>
<li>ESP_ERR_INVALID_ARG თუ ახალი დანაყოფი იმავე ფლეშ მეხსიერება ჩიპზე არსებულ სხვა დანაყოფის გადაფარვას ახდენს.</li>
<li>ESP_ERR_INVALID_SIZE თუ დანაყოფი არ ჯდება ფლეშ მეხსიერება ჩიპის ზომაში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">flash_chip</span></code>: ფლეშ მეხსიერება ჩიპის იდენტიფიცირების სტრუქტურის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">offset</span></code>მისამართი ბაიტებში, სადაც იწყება დანაყოფი </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: დანაყოფის ზომა ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">label</span></code>: დანაყოფის სახელი </li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: ერთ-ერთი დანაყოფის ტიპი (ESP_PARTITION_TYPE_*). გაითვალისწინეთ, რომ აპლიკაციების ჩატვირთვა გარე ფლეშ მეხსიერება ჩიპებიდან შეუძლებელია, ამიტომ ESP_PARTITION_TYPE_APP-ის გამოყენება მხარდაჭერილი არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">subtype</span></code>: დანაყოფის ერთ-ერთი ქვეტიპი (ESP_PARTITION_SUBTYPE_*) </li>
<li><code class="docutils literal notranslate"><span class="pre">out_partition</span></code>თუ გამომავალი არ არის NULL, იღებს მაჩვენებელს შედეგად მიღებულზე <a class="reference internal" href="spi_flash.html#structesp__partition__t"><span class="std std-ref">esp_partition_t</span></a> სტრუქტურა </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv433esp_partition_deregister_externalPK15esp_partition_t">
<span id="_CPPv333esp_partition_deregister_externalPK15esp_partition_t"></span><span id="_CPPv233esp_partition_deregister_externalPK15esp_partition_t"></span><span id="esp_partition_deregister_external__esp_partition_tCP"></span><span class="target" id="esp__partition_8h_1a5d451a1424b9aac1e9f3973bc1376db9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_partition_deregister_external</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv433esp_partition_deregister_externalPK15esp_partition_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გააუქმეთ esp_partition_register_external-ის გამოყენებით ადრე რეგისტრირებული დანაყოფის რეგისტრაცია. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_FOUND თუ დანაყოფის მაჩვენებელი ვერ მოიძებნა</li>
<li>ESP_ERR_INVALID_ARG თუ დანაყოფი მოდის დანაყოფების ცხრილი დან</li>
<li>ESP_ERR_INVALID_ARG, თუ დანაყოფი არ იყო რეგისტრირებული esp_partition_register_external ფუნქციის გამოყენებით. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_register_external-დან მიღებული დანაყოფის სტრუქტურის მაჩვენებელი, </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id10">
<h3>სტრუქტურები<a class="headerlink" href="spi_flash.html#id10" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv415esp_partition_t">
<span id="_CPPv315esp_partition_t"></span><span id="_CPPv215esp_partition_t"></span><span id="esp_partition_t"></span><span class="target" id="structesp__partition__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_partition_t</code><a class="headerlink" href="spi_flash.html#_CPPv415esp_partition_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ინფორმაციის სტრუქტურა </p>
<p>ეს არ არის ფლეშ მეხსიერება ის ფორმატი, ეს ფორმატია esp_partition_info_t.</p>
<p>თუმცა, ეს არის ფორმატი, რომელსაც ეს API იყენებს8. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t10flash_chipE">
<span id="_CPPv3N15esp_partition_t10flash_chipE"></span><span id="_CPPv2N15esp_partition_t10flash_chipE"></span><span id="esp_partition_t::flash_chip__esp_flash_tP"></span><span class="target" id="structesp__partition__t_1a9a5a506572448686f36c9a442dbf21eb"></span><a class="reference internal" href="spi_flash.html#_CPPv411esp_flash_t" title="esp_flash_t">esp_ ფლეშ მეხსიერება _t</a> *<code class="descname">flash_chip</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t10flash_chipE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPI ფლეშ მეხსიერება ჩიპი, რომელზეც განთავსებულია დანაყოფი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t4typeE">
<span id="_CPPv3N15esp_partition_t4typeE"></span><span id="_CPPv2N15esp_partition_t4typeE"></span><span id="esp_partition_t::type__esp_partition_type_t"></span><span class="target" id="structesp__partition__t_1a30655be4d00e92774984a057c95f7cac"></span><a class="reference internal" href="spi_flash.html#_CPPv420esp_partition_type_t" title="esp_partition_type_t">esp_partition_type_t</a> <code class="descname">type</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t4typeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ტიპი (აპლიკაცია/მონაცემები) </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t7subtypeE">
<span id="_CPPv3N15esp_partition_t7subtypeE"></span><span id="_CPPv2N15esp_partition_t7subtypeE"></span><span id="esp_partition_t::subtype__esp_partition_subtype_t"></span><span class="target" id="structesp__partition__t_1a6a7857c049c3c5c0bfa401eff76b294a"></span><a class="reference internal" href="spi_flash.html#_CPPv423esp_partition_subtype_t" title="esp_partition_subtype_t">esp_partition_subtype_t</a> <code class="descname">subtype</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t7subtypeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ქვეტიპი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t7addressE">
<span id="_CPPv3N15esp_partition_t7addressE"></span><span id="_CPPv2N15esp_partition_t7addressE"></span><span id="esp_partition_t::address__uint32_t"></span><span class="target" id="structesp__partition__t_1a05237c6335fc8b7fe9a8c4200405f4e2"></span>uint32_t <code class="descname">address</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t7addressE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება -ში დანაყოფის საწყისი მისამართი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t4sizeE">
<span id="_CPPv3N15esp_partition_t4sizeE"></span><span id="_CPPv2N15esp_partition_t4sizeE"></span><span id="esp_partition_t::size__uint32_t"></span><span class="target" id="structesp__partition__t_1a9c3481b9c4f6d6aede019d8719f87937"></span>uint32_t <code class="descname">size</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t4sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ზომა, ბაიტებში </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t5labelE">
<span id="_CPPv3N15esp_partition_t5labelE"></span><span id="_CPPv2N15esp_partition_t5labelE"></span><span id="esp_partition_t::label__cA"></span><span class="target" id="structesp__partition__t_1addb88484aac7fbf7e7f777fbf7d5397d"></span>char <code class="descname">label</code>[17]<a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t5labelE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის იარლიყი, ნულოვანი დაბოლოების მქონე ASCII სტრიქონი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N15esp_partition_t9encryptedE">
<span id="_CPPv3N15esp_partition_t9encryptedE"></span><span id="_CPPv2N15esp_partition_t9encryptedE"></span><span id="esp_partition_t::encrypted__b"></span><span class="target" id="structesp__partition__t_1a5d1eb6c681b4010e7abc70e8ffd89320"></span>bool <code class="descname">encrypted</code><a class="headerlink" href="spi_flash.html#_CPPv4N15esp_partition_t9encryptedE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დროშა დაყენებულია true-ზე, თუ დანაყოფი დაშიფრულია </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id11">
<h3>მაკროები<a class="headerlink" href="spi_flash.html#id11" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.ESP_PARTITION_SUBTYPE_OTA">
<span class="target" id="esp__partition_8h_1aeb6f82719f3e4d4b46af727fcefa0f5b"></span><code class="descname">ESP_PARTITION_SUBTYPE_OTA</code><span class="sig-paren">(</span>i<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#c.ESP_PARTITION_SUBTYPE_OTA" title="Permalink to this definition">¶</a></dt>
<dd><p>მოხერხებული მაკრო i-ური OTA დანაყოფისთვის esp_partition_subtype_t მნიშვნელობის მისაღებად. </p>
</dd></dl>
</div>
<div class="section" id="id12">
<h3>ტიპის განმარტებები<a class="headerlink" href="spi_flash.html#id12" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv424esp_partition_iterator_t">
<span id="_CPPv324esp_partition_iterator_t"></span><span id="_CPPv224esp_partition_iterator_t"></span><span id="esp_partition_iterator_t"></span><span class="target" id="esp__partition_8h_1a598151a683968d1b9051593f83b44798"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> esp_partition_iterator_opaque_ *<code class="descname">esp_partition_iterator_t</code><a class="headerlink" href="spi_flash.html#_CPPv424esp_partition_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაუმჭვირვალე დანაყოფის იტერატორის ტიპი. </p>
</dd></dl>
</div>
<div class="section" id="id13">
<h3>ჩამოთვლები<a class="headerlink" href="spi_flash.html#id13" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv420esp_partition_type_t">
<span id="_CPPv320esp_partition_type_t"></span><span id="_CPPv220esp_partition_type_t"></span><span id="esp_partition_type_t"></span><span class="target" id="esp__partition_8h_1aafc4f41a0b5bab81d1f89163cc950537"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_partition_type_t</code><a class="headerlink" href="spi_flash.html#_CPPv420esp_partition_type_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ტიპი. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Keep this enum in sync with PartitionDefinition class gen_esp32part.py </dd>
</dl>
</p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv422ESP_PARTITION_TYPE_APP">
<span id="_CPPv322ESP_PARTITION_TYPE_APP"></span><span id="_CPPv222ESP_PARTITION_TYPE_APP"></span><span class="target" id="esp__partition_8h_1aafc4f41a0b5bab81d1f89163cc950537a868e0eb3f067099e5ca77715cfbb1de5"></span><code class="descname">ESP_PARTITION_TYPE_APP</code> = 0x00<a class="headerlink" href="spi_flash.html#_CPPv422ESP_PARTITION_TYPE_APP" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აპლიკაციის დანაყოფის ტიპი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv423ESP_PARTITION_TYPE_DATA">
<span id="_CPPv323ESP_PARTITION_TYPE_DATA"></span><span id="_CPPv223ESP_PARTITION_TYPE_DATA"></span><span class="target" id="esp__partition_8h_1aafc4f41a0b5bab81d1f89163cc950537a837281927c13d663ca535936a9fdf62e"></span><code class="descname">ESP_PARTITION_TYPE_DATA</code> = 0x01<a class="headerlink" href="spi_flash.html#_CPPv423ESP_PARTITION_TYPE_DATA" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მონაცემთა დანაყოფის ტიპი. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv423esp_partition_subtype_t">
<span id="_CPPv323esp_partition_subtype_t"></span><span id="_CPPv223esp_partition_subtype_t"></span><span id="esp_partition_subtype_t"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_partition_subtype_t</code><a class="headerlink" href="spi_flash.html#_CPPv423esp_partition_subtype_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დანაყოფის ქვეტიპი. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Keep this enum in sync with PartitionDefinition class gen_esp32part.py </dd>
</dl>
</p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv433ESP_PARTITION_SUBTYPE_APP_FACTORY">
<span id="_CPPv333ESP_PARTITION_SUBTYPE_APP_FACTORY"></span><span id="_CPPv233ESP_PARTITION_SUBTYPE_APP_FACTORY"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a63efb47b43cb77d963900534c063e78b"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_FACTORY</code> = 0x00<a class="headerlink" href="spi_flash.html#_CPPv433ESP_PARTITION_SUBTYPE_APP_FACTORY" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ქარხნული აპლიკაციის დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv433ESP_PARTITION_SUBTYPE_APP_OTA_MIN">
<span id="_CPPv333ESP_PARTITION_SUBTYPE_APP_OTA_MIN"></span><span id="_CPPv233ESP_PARTITION_SUBTYPE_APP_OTA_MIN"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a1ee9813850079c62e4d080e74fa4cf38"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_MIN</code> = 0x10<a class="headerlink" href="spi_flash.html#_CPPv433ESP_PARTITION_SUBTYPE_APP_OTA_MIN" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფების ქვეტიპების ბაზა. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_0">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_0"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_0"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a94acc8e6e9d53ab36edb4ca653d55acc"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_0</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 0<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_0" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 0. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_1">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_1"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_1"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a0b315fba0c30b924f72a0f016b52a9c6"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_1</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 1<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_1" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 1. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_2">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_2"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_2"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8abef5828758d755258c177efb9389f5fa"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_2</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 2<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_2" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 2. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_3">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_3"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_3"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a8668c6c13161c996b0359e4cd5f87811"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_3</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 3<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_3" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 3. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_4">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_4"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_4"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a2d60b4dc860e22e625e0e1cb7a15f289"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_4</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 4<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_4" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 4. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_5">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_5"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_5"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8ab10a50ff0b3baf935161fc20eb8170dd"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_5</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 5<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_5" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 5. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_6">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_6"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_6"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8adc5b9fdd0085e5b1b1432141284ba67e"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_6</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 6<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_6" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 6. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_7">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_7"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_7"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a9c4b872476694f7c5ade75ae81f49293"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_7</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 7<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_7" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 7. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_8">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_8"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_8"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a6d3aaa8561a044e064c400fd569d2b93"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_8</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 8<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_8" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 8. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_9">
<span id="_CPPv331ESP_PARTITION_SUBTYPE_APP_OTA_9"></span><span id="_CPPv231ESP_PARTITION_SUBTYPE_APP_OTA_9"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a29d06b28954a964f67934479d02f6ebd"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_9</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 9<a class="headerlink" href="spi_flash.html#_CPPv431ESP_PARTITION_SUBTYPE_APP_OTA_9" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 9. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_10">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_10"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_10"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a093d566dfbb5dac6f252c5e6d073f779"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_10</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 10<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_10" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 10. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_11">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_11"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_11"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8ad6122b3538eb2e3fb4e6c6b9a6c77509"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_11</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 11<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_11" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 11. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_12">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_12"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_12"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a5131fe73e099b8f56911bada831ac1cb"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_12</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 12<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_12" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 12. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_13">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_13"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_13"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a80fc01aa974a4ecc6c1ad44597a1b16f"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_13</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 13<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_13" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 13. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_14">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_14"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_14"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8aa31b085675c286dd9e78e1e842138d62"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_14</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 14<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_14" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 14. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_15">
<span id="_CPPv332ESP_PARTITION_SUBTYPE_APP_OTA_15"></span><span id="_CPPv232ESP_PARTITION_SUBTYPE_APP_OTA_15"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a57ec8c942e130d9360c650934e5eca45"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_15</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 15<a class="headerlink" href="spi_flash.html#_CPPv432ESP_PARTITION_SUBTYPE_APP_OTA_15" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფი 15. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv433ESP_PARTITION_SUBTYPE_APP_OTA_MAX">
<span id="_CPPv333ESP_PARTITION_SUBTYPE_APP_OTA_MAX"></span><span id="_CPPv233ESP_PARTITION_SUBTYPE_APP_OTA_MAX"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8aeeb072771773144b09fe2b1a282865fc"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_OTA_MAX</code> = ESP_PARTITION_SUBTYPE_APP_OTA_MIN + 16<a class="headerlink" href="spi_flash.html#_CPPv433ESP_PARTITION_SUBTYPE_APP_OTA_MAX" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA დანაყოფის მაქსიმალური ქვეტიპი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_PARTITION_SUBTYPE_APP_TEST">
<span id="_CPPv330ESP_PARTITION_SUBTYPE_APP_TEST"></span><span id="_CPPv230ESP_PARTITION_SUBTYPE_APP_TEST"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a2c773d597e5fcc60d60220604165965a"></span><code class="descname">ESP_PARTITION_SUBTYPE_APP_TEST</code> = 0x20<a class="headerlink" href="spi_flash.html#_CPPv430ESP_PARTITION_SUBTYPE_APP_TEST" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აპლიკაციის დანაყოფის ტესტირება. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_PARTITION_SUBTYPE_DATA_OTA">
<span id="_CPPv330ESP_PARTITION_SUBTYPE_DATA_OTA"></span><span id="_CPPv230ESP_PARTITION_SUBTYPE_DATA_OTA"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8afb1a03b580422306d383e2ce1627a5dd"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_OTA</code> = 0x00<a class="headerlink" href="spi_flash.html#_CPPv430ESP_PARTITION_SUBTYPE_DATA_OTA" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>OTA შერჩევის დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_PARTITION_SUBTYPE_DATA_PHY">
<span id="_CPPv330ESP_PARTITION_SUBTYPE_DATA_PHY"></span><span id="_CPPv230ESP_PARTITION_SUBTYPE_DATA_PHY"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a65de023e705d5c27d2703a14bb17083f"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_PHY</code> = 0x01<a class="headerlink" href="spi_flash.html#_CPPv430ESP_PARTITION_SUBTYPE_DATA_PHY" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>PHY init მონაცემთა დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_PARTITION_SUBTYPE_DATA_NVS">
<span id="_CPPv330ESP_PARTITION_SUBTYPE_DATA_NVS"></span><span id="_CPPv230ESP_PARTITION_SUBTYPE_DATA_NVS"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a0595fd805d8f4edbae3db5304a525da8"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_NVS</code> = 0x02<a class="headerlink" href="spi_flash.html#_CPPv430ESP_PARTITION_SUBTYPE_DATA_NVS" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>NVS დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv435ESP_PARTITION_SUBTYPE_DATA_COREDUMP">
<span id="_CPPv335ESP_PARTITION_SUBTYPE_DATA_COREDUMP"></span><span id="_CPPv235ESP_PARTITION_SUBTYPE_DATA_COREDUMP"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8afa886fbd998f69493d28dd3e332cc20c"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_COREDUMP</code> = 0x03<a class="headerlink" href="spi_flash.html#_CPPv435ESP_PARTITION_SUBTYPE_DATA_COREDUMP" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>COREDUMP დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv435ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS">
<span id="_CPPv335ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS"></span><span id="_CPPv235ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8ae3f214b67b4bc3129905f352dd41de1c"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS</code> = 0x04<a class="headerlink" href="spi_flash.html#_CPPv435ESP_PARTITION_SUBTYPE_DATA_NVS_KEYS" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>NVS გასაღებების დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv435ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM">
<span id="_CPPv335ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM"></span><span id="_CPPv235ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a98a428233a4c3debdce6c7307da5f607"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM</code> = 0x05<a class="headerlink" href="spi_flash.html#_CPPv435ESP_PARTITION_SUBTYPE_DATA_EFUSE_EM" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>eFuse ბიტების ემულაციის დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv435ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD">
<span id="_CPPv335ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD"></span><span id="_CPPv235ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8aae08749a14c93787742fee0c16389cd7"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD</code> = 0x80<a class="headerlink" href="spi_flash.html#_CPPv435ESP_PARTITION_SUBTYPE_DATA_ESPHTTPD" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ESPHTTPD დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_PARTITION_SUBTYPE_DATA_FAT">
<span id="_CPPv330ESP_PARTITION_SUBTYPE_DATA_FAT"></span><span id="_CPPv230ESP_PARTITION_SUBTYPE_DATA_FAT"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8ae552044cc1a2cd41ad4585aeb8ccb4c6"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_FAT</code> = 0x81<a class="headerlink" href="spi_flash.html#_CPPv430ESP_PARTITION_SUBTYPE_DATA_FAT" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>FAT დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv433ESP_PARTITION_SUBTYPE_DATA_SPIFFS">
<span id="_CPPv333ESP_PARTITION_SUBTYPE_DATA_SPIFFS"></span><span id="_CPPv233ESP_PARTITION_SUBTYPE_DATA_SPIFFS"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8aef73e9686eb0a3a611f077105d18e2a4"></span><code class="descname">ESP_PARTITION_SUBTYPE_DATA_SPIFFS</code> = 0x82<a class="headerlink" href="spi_flash.html#_CPPv433ESP_PARTITION_SUBTYPE_DATA_SPIFFS" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>SPIFFS დანაყოფი. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv425ESP_PARTITION_SUBTYPE_ANY">
<span id="_CPPv325ESP_PARTITION_SUBTYPE_ANY"></span><span id="_CPPv225ESP_PARTITION_SUBTYPE_ANY"></span><span class="target" id="esp__partition_8h_1aff78bd7a13309ceefda89b36740da4b8a56d6a46e48c44698474b46d53aa3d1cc"></span><code class="descname">ESP_PARTITION_SUBTYPE_ANY</code> = 0xff<a class="headerlink" href="spi_flash.html#_CPPv425ESP_PARTITION_SUBTYPE_ANY" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება ნებისმიერი ქვეტიპის მქონე დანაყოფების მოსაძებნად. </p>
</dd></dl>
</dd></dl>
</div>
</div>
<div class="section" id="api-reference-flash-encrypt">
<h2>API მითითება - Flash Encrypt<a class="headerlink" href="spi_flash.html#api-reference-flash-encrypt" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id14">
<h3>სათაურის ფაილი<a class="headerlink" href="spi_flash.html#id14" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/bootloader_support/include/esp_flash_encrypt.h">ჩამტვირთავი _support/include/esp_ ფლეშ მეხსიერება _encrypt.h</a></li>
</ul>
</div>
<div class="section" id="id15">
<h3>ფუნქციები<a class="headerlink" href="spi_flash.html#id15" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv428esp_flash_encryption_enabledv">
<span id="_CPPv328esp_flash_encryption_enabledv"></span><span id="_CPPv228esp_flash_encryption_enabledv"></span><span id="esp_flash_encryption_enabled__void"></span><span class="target" id="esp__flash__encrypt_8h_1a45e3a0e0dd177785f6c6cde2b47948e8"></span><em class="property">სტატიკური</em> bool <code class="descname">esp_flash_encryption_enabled</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv428esp_flash_encryption_enabledv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ამჟამად ჩართულია თუ არა ფლეშ მეხსიერება დაშიფვრა აპარატურაში? </p>
<p>ფლეშ დაშიფვრა ჩართულია, თუ FLASH_CRYPT_CNT-ის განმუხტვას ბიტების კენტი რაოდენობა აქვს დაყენებული.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>true if flash encryption is enabled. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv434esp_flash_encrypt_check_and_updatev">
<span id="_CPPv334esp_flash_encrypt_check_and_updatev"></span><span id="_CPPv234esp_flash_encrypt_check_and_updatev"></span><span id="esp_flash_encrypt_check_and_update__void"></span><span class="target" id="esp__flash__encrypt_8h_1a376fec1755c5f2354e9b1a5353124fa7"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_encrypt_check_and_update</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv434esp_flash_encrypt_check_and_updatev" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv424esp_flash_encrypt_region8uint32_t6size_t">
<span id="_CPPv324esp_flash_encrypt_region8uint32_t6size_t"></span><span id="_CPPv224esp_flash_encrypt_region8uint32_t6size_t"></span><span id="esp_flash_encrypt_region__uint32_t.s"></span><span class="target" id="esp__flash__encrypt_8h_1adb91c8abee5d745828b9f7f9b4b08bc8"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_flash_encrypt_region</code><span class="sig-paren">(</span>uint32_t <em>src_addr</em>, size_t <em>მონაცემთა_სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv424esp_flash_encrypt_region8uint32_t6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლეშ მეხსიერება სექტორების ბლოკის ადგილზე დაშიფვრა. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function resets RTC_WDT between operations with sectors. </dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK if all operations succeeded, ESP_ERR_FLASH_OP_FAIL if SPI flash fails, ESP_ERR_FLASH_OP_TIMEOUT if flash times out. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src_addr</span></code>წყაროს ოფსეტი ფლეშ მეხსიერება ში. უნდა იყოს 4096 ბაიტის ჯერადი. </li>
<li><code class="docutils literal notranslate"><span class="pre">data_length</span></code>დაშიფრული მონაცემების სიგრძე ბაიტებში. დამრგვალდება 4096 ბაიტის შემდეგ ჯერადამდე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv433esp_flash_write_protect_crypt_cntv">
<span id="_CPPv333esp_flash_write_protect_crypt_cntv"></span><span id="_CPPv233esp_flash_write_protect_crypt_cntv"></span><span id="esp_flash_write_protect_crypt_cnt__void"></span><span class="target" id="esp__flash__encrypt_8h_1aaba3b45f2534f95c9352cab967042da7"></span>void <code class="descname">esp_flash_write_protect_crypt_cnt</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv433esp_flash_write_protect_crypt_cntv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩაწერის დაცვა FLASH_CRYPT_CNT-ისგან. </p>
<p>განკუთვნილია ჩატვირთვის პროცესის ნაწილად გამოსაძახებლად, თუ ფლეშ მეხსიერება დაშიფვრა ჩართულია, მაგრამ უსაფრთხო ჩატვირთვა არ გამოიყენება. ეს უნდა დაიცვას არაავტორიზებული კოდის სერიული ხელახალი ფლეშ მეხსიერება უსაფრთხო ჩატვირთვის არარსებობის შემთხვევაში. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv429esp_get_flash_encryption_modev">
<span id="_CPPv329esp_get_flash_encryption_modev"></span><span id="_CPPv229esp_get_flash_encryption_modev"></span><span id="esp_get_flash_encryption_mode__void"></span><span class="target" id="esp__flash__encrypt_8h_1a91f3de7fbb44d88e845ceea3fbf5df4c"></span><a class="reference internal" href="spi_flash.html#_CPPv420esp_flash_enc_mode_t" title="esp_flash_enc_mode_t">esp_ ფლეშ მეხსიერება _enc_mode_t</a> <code class="descname">esp_get_flash_encryption_mode</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv429esp_get_flash_encryption_modev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ ფლეშ მეხსიერება დაშიფვრის რეჟიმი. </p>
<p>API გამოიძახება ჩატვირთვის პროცესის დროს, მაგრამ ასევე შეიძლება გამოიძახოს აპლიკაციამ ESP32-ის მიმდინარე ფლეშ მეხსიერება დაშიფვრის რეჟიმის შესამოწმებლად.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd></dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv432esp_flash_encryption_init_checksv">
<span id="_CPPv332esp_flash_encryption_init_checksv"></span><span id="_CPPv232esp_flash_encryption_init_checksv"></span><span id="esp_flash_encryption_init_checks__void"></span><span class="target" id="esp__flash__encrypt_8h_1af9fe12110f4a1f9ab1016be2d56fa1da"></span>void <code class="descname">esp_flash_encryption_init_checks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="spi_flash.html#_CPPv432esp_flash_encryption_init_checksv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაშვებისას შეამოწმეთ ფლეშ მეხსიერება დაშიფვრის რეჟიმი. </p>
<p><p>გაშვებისას ამოწმებს ფლეშ მეხსიერება დაშიფვრის კონფიგურაციას:</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function is called automatically during app startup, it doesn’t need to be called from the app.</dd>
</dl>
</p>
<p><ul class="simple">
<li>თუ აპარატურულად ჩართულია უსაფრთხო ჩატვირთვა, შეასწორეთ ფლეშ მეხსიერება ნებისმიერი დაუცველი დაშიფვრის პარამეტრი.</li>
<li>გაფრთხილებების ჟურნალირება, თუ efuse კონფიგურაცია არანაირად არ ემთხვევა პროექტის კონფიგურაციას </li>
</ul>
</p>
</dd></dl>
</div>
<div class="section" id="id16">
<h3>ჩამოთვლები<a class="headerlink" href="spi_flash.html#id16" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv420esp_flash_enc_mode_t">
<span id="_CPPv320esp_flash_enc_mode_t"></span><span id="_CPPv220esp_flash_enc_mode_t"></span><span id="esp_flash_enc_mode_t"></span><span class="target" id="esp__flash__encrypt_8h_1af81f69b7147dfc2991374845dc61dc39"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_flash_enc_mode_t</code><a class="headerlink" href="spi_flash.html#_CPPv420esp_flash_enc_mode_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv427ESP_FLASH_ENC_MODE_DISABLED">
<span id="_CPPv327ESP_FLASH_ENC_MODE_DISABLED"></span><span id="_CPPv227ESP_FLASH_ENC_MODE_DISABLED"></span><span class="target" id="esp__flash__encrypt_8h_1af81f69b7147dfc2991374845dc61dc39a92d1bf4ad3ddd1b9f96b732fe5a16be6"></span><code class="descname">ESP_FLASH_ENC_MODE_DISABLED</code><a class="headerlink" href="spi_flash.html#_CPPv427ESP_FLASH_ENC_MODE_DISABLED" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv430ESP_FLASH_ENC_MODE_DEVELOPMENT">
<span id="_CPPv330ESP_FLASH_ENC_MODE_DEVELOPMENT"></span><span id="_CPPv230ESP_FLASH_ENC_MODE_DEVELOPMENT"></span><span class="target" id="esp__flash__encrypt_8h_1af81f69b7147dfc2991374845dc61dc39a1ce94d84ba5a74d12b2c9b93cb04cce1"></span><code class="descname">ESP_FLASH_ENC_MODE_DEVELOPMENT</code><a class="headerlink" href="spi_flash.html#_CPPv430ESP_FLASH_ENC_MODE_DEVELOPMENT" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="enumerator">
<dt id="_CPPv426ESP_FLASH_ENC_MODE_RELEASE">
<span id="_CPPv326ESP_FLASH_ENC_MODE_RELEASE"></span><span id="_CPPv226ESP_FLASH_ENC_MODE_RELEASE"></span><span class="target" id="esp__flash__encrypt_8h_1af81f69b7147dfc2991374845dc61dc39a49ab7353633dcf61ad8ec88106085bd8"></span><code class="descname">ESP_FLASH_ENC_MODE_RELEASE</code><a class="headerlink" href="spi_flash.html#_CPPv426ESP_FLASH_ENC_MODE_RELEASE" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="spiffs.html" rel="next" title="SPIFFS Filesystem">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="sdmmc.html" rel="prev" title="SD/SDIO/MMC Driver"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>