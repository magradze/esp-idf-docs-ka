
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>არასტაბილური შენახვის ბიბლიოთეკა — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="nvs_partition_gen.html" rel="next" title="NVS Partition Generator Utility"/>
<link href="mass_mfg.html" rel="prev" title="Manufacturing Utility"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/storage/nvs_flash.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/storage/nvs_flash"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/storage/nvs_flash.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">შენახვა</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="fatfs.html">FAT ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="mass_mfg.html">მასობრივი წარმოების კომუნალური მომსახურება</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="nvs_flash.html#">არასტაბილური საცავი</a><ul>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#introduction">შესავალი</a></li>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#internals">შინაგანი ორგანოები</a></li>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#nvs-encryption">NVS დაშიფვრა</a></li>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#nvs-partition-generator-utility">NVS დანაყოფების გენერატორის პროგრამა</a></li>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#application-example">განაცხადის მაგალითი</a></li>
<li class="toctree-l4"><a class="reference internal" href="nvs_flash.html#api-reference">API მითითება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="nvs_partition_gen.html">NVS დანაყოფების გენერირების პროგრამა</a></li>
<li class="toctree-l3"><a class="reference internal" href="sdmmc.html">SD/SDIO/MMC დრაივერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="spi_flash.html">SPI Flash და Partition API s</a></li>
<li class="toctree-l3"><a class="reference internal" href="spiffs.html">SPIFFS ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="vfs.html">ვირტუალური ფაილური სისტემა</a></li>
<li class="toctree-l3"><a class="reference internal" href="wear-levelling.html">ცვეთის გასწორება</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">შენახვის API</a> »</li>
<li>არასტაბილური შენახვის ბიბლიოთეკა</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/storage/nvs_flash.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="non-volatile-storage-library">
<h1>არასტაბილური შენახვის ბიბლიოთეკა<a class="headerlink" href="nvs_flash.html#non-volatile-storage-library" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/api-reference/storage/nvs_flash.html">[中文]</a></p>
<div class="section" id="introduction">
<h2>შესავალი<a class="headerlink" href="nvs_flash.html#introduction" title="Permalink to this headline">¶</a></h2>
<p>არასტაბილური შენახვის (NVS) ბიბლიოთეკა შექმნილია ფლეშ მეხსიერება ში გასაღები-მნიშვნელობის წყვილების შესანახად. ეს განყოფილება წარმოგიდგენთ NVS-ის მიერ გამოყენებულ ზოგიერთ კონცეფციას.</p>
<div class="section" id="underlying-storage">
<h3>ძირითადი საცავი<a class="headerlink" href="nvs_flash.html#underlying-storage" title="Permalink to this headline">¶</a></h3>
<p>ამჟამად, NVS იყენებს ფლეშ მეხსიერება ძირითადი მეხსიერების ნაწილს <code class="docutils literal notranslate"><span class="pre">spi_flash_{read|write|erase}</span></code> API s. ბიბლიოთეკა იყენებს ყველა დანაყოფს <code class="docutils literal notranslate"><span class="pre">data</span></code> ტიპი და <code class="docutils literal notranslate"><span class="pre">nvs</span></code> ქვეტიპი. აპლიკაციას შეუძლია აირჩიოს დანაყოფის გამოყენება ეტიკეტით <code class="docutils literal notranslate"><span class="pre">nvs</span></code> მეშვეობით <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> API ფუნქციის ან ნებისმიერი სხვა დანაყოფის მითითებით მისი სახელის გამოყენებით <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> API ფუნქცია.</p>
<p>ამ ბიბლიოთეკის მომავალ ვერსიებს შეიძლება ჰქონდეთ სხვა საცავის ბექენდები მონაცემების სხვა ფლეშ მეხსიერება ჩიპში (SPI ან I2C), RTC, FRAM და ა.შ. შესანახად.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">თუ NVS დანაყოფი შემოკლებულია (მაგალითად, როდესაც დანაყოფების ცხრილი განლაგება იცვლება), მისი შინაარსი უნდა წაიშალოს. ESP-IDF აწყობის სისტემა უზრუნველყოფს <code class="docutils literal notranslate"><span class="pre">idf.py</span> <span class="pre">erase_flash</span></code> მიზანია ფლეშ მეხსიერება ჩიპის მთელი შინაარსის წაშლა.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">NVS საუკეთესოდ მუშაობს მრავალი მცირე მნიშვნელობის შესანახად, „string“ და „blob“ ტიპის რამდენიმე დიდი მნიშვნელობის ნაცვლად. თუ დიდი blob-ების ან სტრიქონების შენახვა გჭირდებათ, განიხილეთ FAT ფაილური სისტემის მიერ ცვეთის გასწორების ბიბლიოთეკის ზემოთ მოცემული შესაძლებლობების გამოყენება.</p>
</div>
</div>
<div class="section" id="keys-and-values">
<h3>გასაღებები და მნიშვნელობები<a class="headerlink" href="nvs_flash.html#keys-and-values" title="Permalink to this headline">¶</a></h3>
<p>NVS მუშაობს გასაღები-მნიშვნელობის წყვილებზე. გასაღებები ASCII სტრიქონებია; გასაღების მაქსიმალური სიგრძე ამჟამად 15 სიმბოლოა. მნიშვნელობებს შეიძლება ჰქონდეთ შემდეგი ტიპებიდან ერთ-ერთი:</p>
<ul class="simple">
<li>მთელი რიცხვების ტიპები: <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int8_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int64_t</span></code></li>
<li>ნულოვანი დაბოლოების სტრიქონი</li>
<li>ცვლადი სიგრძის ორობითი მონაცემები (blob)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">სტრიქონის მნიშვნელობები ამჟამად შემოიფარგლება 4000 ბაიტით. ეს მოიცავს null ტერმინატორსაც. Blob მნიშვნელობები შემოიფარგლება 508000 ბაიტით ან დანაყოფის ზომის 97.6%-ით - 4000 ბაიტით, რომელიც უფრო ნაკლებია.</p>
</div>
<p>დამატებითი ტიპები, როგორიცაა <code class="docutils literal notranslate"><span class="pre">float</span></code> და <code class="docutils literal notranslate"><span class="pre">double</span></code> შეიძლება მოგვიანებით დაემატოს.</p>
<p>გასაღებები უნიკალური უნდა იყოს. არსებული გასაღებისთვის ახალი მნიშვნელობის მინიჭება შემდეგნაირად მუშაობს:</p>
<ul class="simple">
<li>თუ ახალი მნიშვნელობა იგივე ტიპისაა, რაც ძველი, მნიშვნელობა განახლდება</li>
<li>თუ ახალ მნიშვნელობას განსხვავებული მონაცემთა ტიპი აქვს, ბრუნდება შეცდომა</li>
</ul>
<p>მონაცემთა ტიპის შემოწმება ასევე ხორციელდება მნიშვნელობის წაკითხვისას. შეცდომა ბრუნდება, თუ წაკითხვის ოპერაციის მონაცემთა ტიპი არ ემთხვევა მნიშვნელობის მონაცემთა ტიპს.</p>
</div>
<div class="section" id="namespaces">
<h3>სახელთა სივრცეები<a class="headerlink" href="nvs_flash.html#namespaces" title="Permalink to this headline">¶</a></h3>
<p>სხვადასხვა კომპონენტი შორის გასაღებების სახელწოდებებში პოტენციური კონფლიქტების შესამცირებლად, NVS თითოეულ გასაღებ-მნიშვნელობის წყვილს ანიჭებს ერთ-ერთ სახელთა სივრცეს. სახელთა სივრცეების სახელები იმავე წესებს მიჰყვება, რასაც გასაღებების სახელები, ანუ მაქსიმალური სიგრძე 15 სიმბოლოა. სახელთა სივრცის სახელი მითითებულია <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> ზარი. ეს ზარი აბრუნებს გაუმჭვირვალე სახელურს, რომელიც გამოიყენება შემდგომ ზარებში <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code>, <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code>და <code class="docutils literal notranslate"><span class="pre">nvs_commit</span></code> ფუნქციები. ამ გზით, სახელური ასოცირდება სახელთა სივრცესთან და გასაღების სახელები არ შეეჯახება სხვა სახელთა სივრცეებში არსებულ იმავე სახელებს. გაითვალისწინეთ, რომ სხვადასხვა NVS დანაყოფებში ერთი და იგივე სახელის მქონე სახელთა სივრცეები ცალკე სახელთა სივრცეებად ითვლება.</p>
</div>
<div class="section" id="security-tampering-and-robustness">
<h3>უსაფრთხოება, ხელყოფა და სიმტკიცე<a class="headerlink" href="nvs_flash.html#security-tampering-and-robustness" title="Permalink to this headline">¶</a></h3>
<p>NVS პირდაპირ თავსებადი არ არის ESP32 ფლეშ მეხსიერება დაშიფვრის სისტემასთან. თუმცა, მონაცემების შენახვა დაშიფრული ფორმით მაინც შესაძლებელია, თუ NVS დაშიფვრა გამოიყენება ESP32 ფლეშ მეხსიერება დაშიფვრასთან ერთად. გთხოვთ, იხილოთ <a class="reference internal" href="nvs_flash.html#nvs-encryption"><span class="std std-ref">NVS დაშიფვრა</span></a> დამატებითი დეტალებისთვის.</p>
<p>თუ NVS დაშიფვრა არ გამოიყენება, ფლეშ მეხსიერება ჩიპზე ფიზიკური წვდომის მქონე ნებისმიერ პირს შეუძლია შეცვალოს, წაშალოს ან დაამატოს გასაღები-მნიშვნელობის წყვილი. NVS დაშიფვრის ჩართვის შემთხვევაში, შეუძლებელია გასაღები-მნიშვნელობის წყვილის შეცვლა ან დამატება და ვალიდურ წყვილად ამოცნობა შესაბამისი NVS დაშიფვრის გასაღებების ცოდნის გარეშე. თუმცა, წაშლის ოპერაციის წინააღმდეგ არანაირი დაცვა არ არსებობს.</p>
<p>ბიბლიოთეკა ცდილობს აღდგეს იმ მდგომარეობიდან, როდესაც ფლეშ მეხსიერება მეხსიერება არათანმიმდევრულ მდგომარეობაშია. კერძოდ, უნდა იყოს შესაძლებელი მოწყობილობის გამორთვა ნებისმიერ დროს და შემდეგ ხელახლა ჩართვა. ამან არ უნდა გამოიწვიოს მონაცემების დაკარგვა, გარდა ახალი გასაღები-მნიშვნელობის წყვილისა, თუ ის იწერებოდა გამორთვის მომენტში. ბიბლიოთეკას ასევე უნდა შეეძლოს ფლეშ მეხსიერება მეხსიერებაში არსებული ნებისმიერი შემთხვევითი მონაცემის სწორად ინიციალიზაცია.</p>
</div>
</div>
<div class="section" id="internals">
<h2>შინაგანი ორგანოები<a class="headerlink" href="nvs_flash.html#internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="log-of-key-value-pairs">
<h3>გასაღები-მნიშვნელობის წყვილების ჟურნალი<a class="headerlink" href="nvs_flash.html#log-of-key-value-pairs" title="Permalink to this headline">¶</a></h3>
<p>NVS თანმიმდევრულად ინახავს გასაღებ-მნიშვნელობის წყვილებს, ბოლოს კი ახალი გასაღებ-მნიშვნელობის წყვილები ემატება. როდესაც ნებისმიერი მოცემული გასაღების მნიშვნელობა უნდა განახლდეს, ჟურნალის ბოლოს ემატება ახალი გასაღებ-მნიშვნელობის წყვილი და ძველი გასაღებ-მნიშვნელობის წყვილი წაშლილად აღინიშნება.</p>
</div>
<div class="section" id="pages-and-entries">
<h3>გვერდები და ჩანაწერები<a class="headerlink" href="nvs_flash.html#pages-and-entries" title="Permalink to this headline">¶</a></h3>
<p>NVS ბიბლიოთეკა თავის ფუნქციონირებაში ორ ძირითად ერთეულს იყენებს: გვერდებს და ჩანაწერებს. გვერდი არის ლოგიკური სტრუქტურა, რომელიც ინახავს საერთო ჟურნალის ნაწილს. ლოგიკური გვერდი შეესაბამება ფლეშ მეხსიერება მეხსიერების ერთ ფიზიკურ სექტორს. გამოყენებული გვერდები შეიცავს... <em>თანმიმდევრობის ნომერი</em> მათთან დაკავშირებული. თანმიმდევრობის ნომრები გვერდებს თანმიმდევრობას აწესებს. უფრო მაღალი თანმიმდევრობის ნომრები შეესაბამება გვერდებს, რომლებიც მოგვიანებით შეიქმნა. თითოეული გვერდი შეიძლება იყოს შემდეგ მდგომარეობებში:</p>
<dl class="docutils">
<dt>Empty/uninitialized</dt>
<dd>Flash storage for the page is empty (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>). Page is not used to store any data at this point and does not have a sequence number.</dd>
<dt>Active</dt>
<dd>Flash storage is initialized, page header has been written to flash, page has a valid sequence number. Page has some empty entries and data can be written there. No more than one page can be in this state at any given moment.</dd>
<dt>Full</dt>
<dd>Flash storage is in a consistent state and is filled with key-value pairs.
Writing new key-value pairs into this page is not possible. It is still possible to mark some key-value pairs as erased.</dd>
<dt>Erasing</dt>
<dd>Non-erased key-value pairs are being moved into another page so that the current page can be erased. This is a transient state, i.e., page should never stay in this state at the time when any API call returns. In case of a sudden power off, the move-and-erase process will be completed upon the next power-on.</dd>
<dt>Corrupted</dt>
<dd>Page header contains invalid data, and further parsing of page data was canceled. Any items previously written into this page will not be accessible. The corresponding flash sector will not be erased immediately and will be kept along with sectors in <em>არაინიციალიზებული</em> state for later use. This may be useful for debugging.</dd>
</dl>
<p>ფლეშ მეხსიერება სექტორებიდან ლოგიკურ გვერდებზე მიბმას კონკრეტული თანმიმდევრობა არ აქვს. ბიბლიოთეკა შეამოწმებს თითოეულ ფლეშ მეხსიერება სექტორში ნაპოვნი გვერდების თანმიმდევრობით ნომრებს და ამ რიცხვების მიხედვით დაალაგებს გვერდებს სიაში.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>     <span class="o">+--------+</span>
<span class="o">|</span> <span class="n">Page</span> <span class="mi">1</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">2</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">3</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Page</span> <span class="mi">4</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Full</span>   <span class="o">+---&gt;</span> <span class="o">|</span> <span class="n">Active</span> <span class="o">|</span>     <span class="o">|</span> <span class="n">Empty</span>  <span class="o">|</span>   <span class="o">&lt;-</span> <span class="n">states</span>
<span class="o">|</span> <span class="c1">#11    |     | #12    |     | #14    |     |        |   &lt;- sequence numbers</span>
<span class="o">+---+----+</span>     <span class="o">+----+---+</span>     <span class="o">+----+---+</span>     <span class="o">+---+----+</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
    <span class="o">|</span>               <span class="o">|</span>              <span class="o">|</span>             <span class="o">|</span>
<span class="o">+---</span><span class="n">v</span><span class="o">------+</span>  <span class="o">+-----</span><span class="n">v</span><span class="o">----+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>  <span class="o">+------</span><span class="n">v</span><span class="o">---+</span>
<span class="o">|</span> <span class="n">Sector</span> <span class="mi">3</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">0</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">2</span> <span class="o">|</span>  <span class="o">|</span> <span class="n">Sector</span> <span class="mi">1</span> <span class="o">|</span>    <span class="o">&lt;-</span> <span class="n">physical</span> <span class="n">sectors</span>
<span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>  <span class="o">+----------+</span>
</pre></div>
</div>
</div>
<div class="section" id="structure-of-a-page">
<h3>გვერდის სტრუქტურა<a class="headerlink" href="nvs_flash.html#structure-of-a-page" title="Permalink to this headline">¶</a></h3>
<p>ამ ეტაპზე, ჩვენ ვვარაუდობთ, რომ ფლეშ მეხსიერება სექტორის ზომაა 4096 ბაიტი და რომ ESP32 ფლეშ მეხსიერება დაშიფვრის აპარატურა მუშაობს 32 ბაიტიან ბლოკებზე. შესაძლებელია გარკვეული პარამეტრების დანერგვა, რომლებიც კონფიგურირებადია კომპილაცია დროს (მაგ., menuconfig საშუალებით), რათა მოთავსდეს ფლეშ მეხსიერება ჩიპები სხვადასხვა სექტორის ზომით (თუმცა გაურკვეველია, შეუძლიათ თუ არა სისტემაში სხვა კომპონენტი ჩიპებს, მაგ., SPI ფლეშ მეხსიერება დრაივერს და SPI ფლეშ მეხსიერება ქეშს ამ სხვა ზომების მხარდაჭერა).</p>
<p>გვერდი სამი ნაწილისგან შედგება: სათაური, ჩანაწერის მდგომარეობის ბიტმაპი და თავად ჩანაწერები. ESP32 ფლეშ მეხსიერება დაშიფვრასთან თავსებადობისთვის, ჩანაწერის ზომა 32 ბაიტია. მთელი რიცხვების ტიპებისთვის, ჩანაწერი შეიცავს ერთ გასაღებ-მნიშვნელობის წყვილს. სტრიქონებისა და ბლობებისთვის, ჩანაწერი შეიცავს გასაღებ-მნიშვნელობის წყვილის ნაწილს (ამის შესახებ მეტი ინფორმაციისთვის იხილეთ ჩანაწერის სტრუქტურის აღწერა).</p>
<p>შემდეგი დიაგრამა ასახავს გვერდის სტრუქტურას. ფრჩხილებში მოცემული რიცხვები მიუთითებს თითოეული ნაწილის ზომას ბაიტებში.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span> <span class="n">State</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">Seq</span><span class="o">.</span> <span class="n">no</span><span class="o">.</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">version</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Unused</span> <span class="p">(</span><span class="mi">19</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>   <span class="n">Header</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="o">+-----------+--------------+-------------+-------------------------+</span>
<span class="o">|</span>                <span class="n">Entry</span> <span class="n">state</span> <span class="n">bitmap</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                           <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">0</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                               <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">/</span>                                                                  <span class="o">/</span>
<span class="o">+------------------------------------------------------------------+</span>
<span class="o">|</span>                       <span class="n">Entry</span> <span class="mi">125</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>                             <span class="o">|</span>
<span class="o">+------------------------------------------------------------------+</span>
</pre></div>
</div>
<p>გვერდის სათაური და ჩანაწერის მდგომარეობის ბიტმაპი ყოველთვის დაუშიფრავად იწერება ფლეშ მეხსიერება ში. ჩანაწერები დაშიფრულია, თუ გამოიყენება ESP32-ის ფლეშ მეხსიერება დაშიფვრის ფუნქცია.</p>
<p>გვერდის მდგომარეობის მნიშვნელობები განისაზღვრება ისე, რომ მდგომარეობის შეცვლა შესაძლებელია ზოგიერთ ბიტში 0-ის ჩაწერით. ამიტომ, გვერდის წაშლა მისი მდგომარეობის შესაცვლელად საჭირო არ არის, თუ ეს არ არის გვერდის ცვლილება. <em>წაშლილი</em> სახელმწიფო.</p>
<p>სათაურში მოცემული ვერსიის ველი ასახავს გამოყენებულ NVS ფორმატის ვერსიას. უკუთავსებადობის მიზნით, ის მცირდება ყოველი ვერსიის განახლებისას, დაწყებული 0xff-დან (ანუ, 0xff ვერსია-1-ისთვის, 0xfe ვერსია-2-ისთვის და ა.შ.).</p>
<p>სათაურში CRC32 მნიშვნელობა გამოითვლება იმ ნაწილზე, რომელიც არ შეიცავს მდგომარეობის მნიშვნელობას (ბაიტები 4-დან 28-მდე). გამოუყენებელი ნაწილი ამჟამად შევსებულია <code class="docutils literal notranslate"><span class="pre">0xff</span></code> ბაიტები.</p>
<p>შემდეგ ნაწილებში აღწერილია შესვლის მდგომარეობის ბიტმაპის სტრუქტურა და თავად ჩანაწერი.</p>
</div>
<div class="section" id="entry-and-entry-state-bitmap">
<h3>შესვლისა და შესვლის მდგომარეობის ბიტმაპი<a class="headerlink" href="nvs_flash.html#entry-and-entry-state-bitmap" title="Permalink to this headline">¶</a></h3>
<p>თითოეული ჩანაწერი შეიძლება იყოს შემდეგი სამი მდგომარეობიდან ერთ-ერთში, რომელიც წარმოდგენილია ჩანაწერის მდგომარეობის ბიტმაპში ორი ბიტით. ბიტმაპში ბოლო ოთხი ბიტი (256 - 2 * 126) არ გამოიყენება.</p>
<dl class="docutils">
<dt>Empty (2’b11)</dt>
<dd>Nothing is written into the specific entry yet. It is in an uninitialized state (all bytes are <code class="docutils literal notranslate"><span class="pre">0xff</span></code>).</dd>
<dt>Written (2’b10)</dt>
<dd>A key-value pair (or part of key-value pair which spans multiple entries) has been written into the entry.</dd>
<dt>Erased (2’b00)</dt>
<dd>A key-value pair in this entry has been discarded. Contents of this entry will not be parsed anymore.</dd>
</dl>
</div>
<div class="section" id="structure-of-entry">
<span id="id1"></span><h3>შესვლის სტრუქტურა<a class="headerlink" href="nvs_flash.html#structure-of-entry" title="Permalink to this headline">¶</a></h3>
<p>პრიმიტიული ტიპების მნიშვნელობებისთვის (ამჟამად მთელი რიცხვები 1-დან 8 ბაიტამდე სიგრძის), ჩანაწერი ინარჩუნებს ერთ გასაღებ-მნიშვნელობის წყვილს. სტრიქონისა და ბლომ-მონაცემების ტიპებისთვის, ჩანაწერი ინარჩუნებს მთელი გასაღებ-მნიშვნელობის წყვილის ნაწილს. სტრიქონების შემთხვევაში, იმ შემთხვევაში, თუ გასაღებ-მნიშვნელობის წყვილი მოიცავს რამდენიმე ჩანაწერს, ყველა ჩანაწერი ინახება ერთ გვერდზე. ბლომ-მონაცემებს შეუძლიათ გადაფარონ რამდენიმე გვერდი მათი უფრო მცირე ნაწილებად დაყოფით. ამ ნაწილებზე თვალყურის დევნებისთვის, ინახება დამატებითი ფიქსირებული სიგრძის მეტამონაცემების ჩანაწერი, სახელწოდებით „ბლომონაცემების ინდექსი“. ბლომ-მონაცემების ადრინდელი ფორმატები კვლავ მხარდაჭერილია (შესაძლებელია მათი წაკითხვა და შეცვლა). თუმცა, ბლომ-მონაცემების შეცვლის შემდეგ, ისინი ინახება ახალი ფორმატის გამოყენებით.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>
<span class="o">|</span> <span class="n">NS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Type</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Span</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkIndex</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>    <span class="n">Key</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span>   <span class="o">|</span> <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
<span class="o">+--------+----------+----------+----------------+-----------+---------------+----------+</span>

                                         <span class="n">Primitive</span>  <span class="o">+--------------------------------+</span>
                                        <span class="o">+--------&gt;</span>  <span class="o">|</span>     <span class="n">Data</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span>                   <span class="o">|</span>
                                        <span class="o">|</span> <span class="n">Types</span>     <span class="o">+--------------------------------+</span>
                   <span class="o">+-&gt;</span> <span class="n">Fixed</span> <span class="n">length</span> <span class="o">--</span>
                   <span class="o">|</span>                    <span class="o">|</span>           <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>                    <span class="o">+--------&gt;</span>  <span class="o">|</span> <span class="n">Size</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">ChunkCount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span> <span class="n">ChunkStart</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">|</span>
    <span class="n">Data</span> <span class="nb">format</span> <span class="o">---+</span>                    <span class="n">Blob</span> <span class="n">Index</span>  <span class="o">+---------+--------------+---------------+-------+</span>
                   <span class="o">|</span>
                   <span class="o">|</span>                             <span class="o">+----------+---------+-----------+</span>
                   <span class="o">+-&gt;</span>   <span class="n">Variable</span> <span class="n">length</span>   <span class="o">--&gt;</span>   <span class="o">|</span> <span class="n">Size</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Rsv</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="n">CRC32</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">Strings</span><span class="p">,</span> <span class="n">Blob</span> <span class="n">Data</span><span class="p">)</span>     <span class="o">+----------+---------+-----------+</span>
</pre></div>
</div>
<p>შეყვანის სტრუქტურაში ცალკეულ ველებს შემდეგი მნიშვნელობა აქვთ:</p>
<dl class="docutils">
<dt>NS</dt>
<dd>Namespace index for this entry. For more information on this value, see the section on namespaces implementation.</dd>
<dt>Type</dt>
<dd>One byte indicating the value data type. See the <code class="docutils literal notranslate"><span class="pre">ItemType</span></code> enumeration in <code class="docutils literal notranslate"><span class="pre">nvs_types.h</span></code> for possible values.</dd>
<dt>Span</dt>
<dd>Number of entries used by this key-value pair. For integer types, this is equal to 1. For strings and blobs, this depends on value length.</dd>
<dt>ChunkIndex</dt>
<dd>Used to store the index of a blob-data chunk for blob types. For other types, this should be <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</dd>
<dt>CRC32</dt>
<dd>Checksum calculated over all the bytes in this entry, except for the CRC32 field itself.</dd>
<dt>Key</dt>
<dd>Zero-terminated ASCII string containing a key name. Maximum string length is 15 bytes, excluding a zero terminator.</dd>
<dt>Data</dt>
<dd><p class="first">მთელი რიცხვების ტიპებისთვის, ეს ველი შეიცავს თავად მნიშვნელობას. თუ თავად მნიშვნელობა 8 ბაიტზე ნაკლებია, ის მარჯვნივ ივსება, გამოუყენებელი ბაიტებით კი ივსება <code class="docutils literal notranslate"><span class="pre">0xff</span></code>.</p>
<p>„blob ინდექსის“ ჩანაწერისთვის, ეს 8 ბაიტი შეიცავს შემდეგ ინფორმაციას მონაცემთა ბლოკების შესახებ:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Size</dt>
<dd>(Only for blob index.) Size, in bytes, of complete blob data.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ChunkCount</dt>
<dd>(Only for blob index.) Total number of blob-data chunks into which the blob was divided during storage.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ChunkStart</dt>
<dd>(Only for blob index.) ChunkIndex of the first blob-data chunk of this blob. Subsequent chunks have chunkIndex incrementally allocated (step of 1).</dd>
</dl>
</li>
</ul>
<p>სტრიქონული და blob მონაცემთა ნაწილებისთვის, ეს 8 ბაიტი შეიცავს დამატებით მონაცემებს მნიშვნელობის შესახებ, რომლებიც აღწერილია ქვემოთ:</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>Size</dt>
<dd>(Only for strings and blobs.) Size, in bytes, of actual data. For strings, this includes zero terminators.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CRC32</dt>
<dd>(Only for strings and blobs.) Checksum calculated over all bytes of data.</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>ცვლადი სიგრძის მნიშვნელობები (სტრიქონები და ბლობები) იწერება შემდგომ ჩანაწერებში, თითო ჩანაწერში 32 ბაიტი. <cite>Span</cite> პირველი ჩანაწერის ველი მიუთითებს გამოყენებული ჩანაწერების რაოდენობას.</p>
</div>
<div class="section" id="id2">
<h3>სახელთა სივრცეები<a class="headerlink" href="nvs_flash.html#id2" title="Permalink to this headline">¶</a></h3>
<p>როგორც ზემოთ აღინიშნა, თითოეული გასაღები-მნიშვნელობის წყვილი ეკუთვნის ერთ-ერთ სახელთა სივრცეს. სახელთა სივრცის იდენტიფიკატორები (სტრიქონები) ინახება, როგორც გასაღები-მნიშვნელობის წყვილების გასაღებები 0 ინდექსის მქონე სახელთა სივრცეში. ამ გასაღებების შესაბამისი მნიშვნელობები წარმოადგენს ამ სახელთა სივრცეების ინდექსებს.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">"wifi"</span> <span class="n">Value</span><span class="o">=</span><span class="mi">1</span>      <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">"wifi"</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">1</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint32_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">"channel"</span> <span class="n">Value</span><span class="o">=</span><span class="mi">6</span>  <span class="o">|</span>   <span class="n">Key</span> <span class="s2">"channel"</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">"wifi"</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">0</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint8_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">"pwm"</span> <span class="n">Value</span><span class="o">=</span><span class="mi">2</span>       <span class="o">|</span>   <span class="n">Entry</span> <span class="n">describing</span> <span class="n">namespace</span> <span class="s2">"pwm"</span>
<span class="o">+-------------------------------------------+</span>
<span class="o">|</span> <span class="n">NS</span><span class="o">=</span><span class="mi">2</span> <span class="n">Type</span><span class="o">=</span><span class="n">uint16_t</span> <span class="n">Key</span><span class="o">=</span><span class="s2">"channel"</span> <span class="n">Value</span><span class="o">=</span><span class="mi">20</span> <span class="o">|</span>   <span class="n">Key</span> <span class="s2">"channel"</span> <span class="ow">in</span> <span class="n">namespace</span> <span class="s2">"pwm"</span>
<span class="o">+-------------------------------------------+</span>
</pre></div>
</div>
</div>
<div class="section" id="item-hash-list">
<h3>ელემენტის ჰეშ სია<a class="headerlink" href="nvs_flash.html#item-hash-list" title="Permalink to this headline">¶</a></h3>
<p>ფლეშ მეხსიერება მეხსიერებიდან წაკითხვის რაოდენობის შესამცირებლად, Page კლასის თითოეული წევრი ინახავს წყვილების სიას: item index; item hash. ეს სია ძიებას ბევრად უფრო სწრაფს ხდის. ყველა ჩანაწერის იტერაციის ნაცვლად, ფლეშ მეხსიერება დან მათი ერთდროულად წაკითხვა, <code class="docutils literal notranslate"><span class="pre">Page::findItem</span></code> თავდაპირველად, ჰეშ სიაში ელემენტის ჰეშს ეძებს. თუ ასეთი ელემენტი არსებობს, ეს გვერდზე ელემენტის ინდექსს იძლევა. ჰეშ-კოლიზიის გამო, შესაძლებელია სხვა ელემენტის პოვნა. ეს ხდება ფლეშ მეხსიერება ში ელემენტების იტერაციაზე დაბრუნებით.</p>
<p>ჰეშ-სიის თითოეული კვანძი შეიცავს 24-ბიტიან ჰეშს და 8-ბიტიან ელემენტის ინდექსს. ჰეში გამოითვლება ელემენტის სახელთა სივრცის, გასაღების სახელის და ChunkIndex-ის საფუძველზე. გამოთვლისთვის გამოიყენება CRC32; შედეგი შემოკლებულია 24 ბიტამდე. დაკავშირებულ სიაში 32-ბიტიანი ჩანაწერების შენახვის ხარჯების შესამცირებლად, სია იმპლემენტირებულია მასივების ორმაგად დაკავშირებული სიის სახით. თითოეული მასივი შეიცავს 29 ჩანაწერს, საერთო ზომით 128 ბაიტი, დაკავშირებული სიის მაჩვენებლებთან და 32-ბიტიან დათვლის ველთან ერთად. შესაბამისად, გვერდზე დამატებითი ოპერატიული მეხსიერების მინიმალური რაოდენობაა 128 ბაიტი; მაქსიმუმი - 640 ბაიტი.</p>
</div>
</div>
<div class="section" id="nvs-encryption">
<span id="id3"></span><h2>NVS დაშიფვრა<a class="headerlink" href="nvs_flash.html#nvs-encryption" title="Permalink to this headline">¶</a></h2>
<p>NVS დანაყოფებში შენახული მონაცემების დაშიფვრა შესაძლებელია AES-XTS-ის გამოყენებით, დისკის დაშიფვრის სტანდარტში IEEE P1619 მითითებული მეთოდის მსგავსად. დაშიფვრის მიზნით, თითოეული ჩანაწერი განიხილება, როგორც ერთი. <cite>sector</cite> და ჩანაწერის ფარდობითი მისამართი (wrt დანაყოფი-დაწყება) მიეწოდება დაშიფვრის ალგორითმს, როგორც <cite>sector-number</cite>NVS დაშიფვრისთვის საჭირო გასაღებები ინახება კიდევ ერთ დანაყოფში, რომელიც დაცულია <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">ფლეშ დაშიფვრა</span></a>. ამიტომ, ჩართვა <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">ფლეშ დაშიფვრა</span></a> NVS დაშიფვრის წინაპირობაა.</p>
<div class="section" id="nvs-key-partition">
<span id="id4"></span><h3>NVS გასაღების დანაყოფი<a class="headerlink" href="nvs_flash.html#nvs-key-partition" title="Permalink to this headline">¶</a></h3>
<p>NVS დაშიფვრის მხარდაჭერის საჭიროების მქონე აპლიკაციას უნდა ჰქონდეს კომპილაცია d ტიპის გასაღების დანაყოფი. <cite>data</cite> და ქვეტიპი <cite>key</cite>ეს დანაყოფი უნდა იყოს მონიშნული, როგორც <cite>encrypted</cite>იხილეთ <a class="reference internal" href="../../api-guides/partition-tables.html"><span class="doc">დანაყოფის ცხრილები</span></a> დამატებითი დეტალებისთვის იხილეთ. დანაყოფის ზომა უნდა იყოს 4096 ბაიტი (დანაყოფის მინიმალური ზომა). ამ დანაყოფის სტრუქტურა ქვემოთ არის გამოსახული.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+-----------+--------------+-------------+----+</span>
<span class="o">|</span>              <span class="n">XTS</span> <span class="n">encryption</span> <span class="n">key</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>         <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
<span class="o">|</span>              <span class="n">XTS</span> <span class="n">tweak</span> <span class="n">key</span> <span class="p">(</span><span class="mi">32</span><span class="p">)</span>             <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
<span class="o">|</span>                  <span class="n">CRC32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                   <span class="o">|</span>
<span class="o">+---------------------------------------------+</span>
</pre></div>
</div>
<p>ეს დანაყოფი შეიძლება შეიქმნას გამოყენებით <cite>nvs partition generator</cite> უტილიტა და ფლეშ მეხსიერება მოწყობილობაზეა დატანილი. რადგან დანაყოფი მონიშნულია <cite>encrypted</cite> და <a class="reference internal" href="../../security/flash-encryption.html"><span class="doc">ფლეშ დაშიფვრა</span></a> ჩართულია, ჩამტვირთავი დაშიფვრავს ამ დანაყოფს ფლეშ მეხსიერება დაშიფვრის გასაღების გამოყენებით პირველი ჩატვირთვისას. ალტერნატიულად, გასაღებების გენერირება შესაძლებელია გაშვების შემდეგ, <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> API ფუნქცია მოწოდებულია <code class="docutils literal notranslate"><span class="pre">nvs_flash.h</span></code>, რომელიც შემდეგ ამ გასაღებებს დაშიფრული სახით ჩაწერს გასაღების დანაყოფზე.</p>
<p>შესაძლებელია, აპლიკაციამ გამოიყენოს სხვადასხვა გასაღებები სხვადასხვა NVS დანაყოფებისთვის და შესაბამისად, ჰქონდეს რამდენიმე გასაღების დანაყოფი. თუმცა, დაშიფვრის/გაშიფვრის მიზნით სწორი გასაღების დანაყოფის/გასაღებების მიწოდება აპლიკაციის პასუხისმგებლობაა.</p>
</div>
<div class="section" id="encrypted-read-write">
<h3>დაშიფრული წაკითხვა/ჩაწერა<a class="headerlink" href="nvs_flash.html#encrypted-read-write" title="Permalink to this headline">¶</a></h3>
<p>იგივე NVS API ფუნქციები <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code> ასევე შეიძლება გამოყენებულ იქნას დაშიფრული nvs დანაყოფების წასაკითხად და ჩასაწერად. თუმცა, NVS დანაყოფების ინიციალიზაციისთვის API ფუნქციები განსხვავებულია: <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init</span></code> და <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init_partition</span></code> ნაცვლად <code class="docutils literal notranslate"><span class="pre">nvs_flash_init</span></code> და <code class="docutils literal notranslate"><span class="pre">nvs_flash_init_partition</span></code> შესაბამისად. <code class="docutils literal notranslate"><span class="pre">nvs_sec_cfg_t</span></code> ამ API ფუნქციებისთვის საჭირო სტრუქტურის შევსება შესაძლებელია გამოყენებით <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_flash_read_security_cfg</span></code>.</p>
<p>აპლიკაციებმა უნდა დაიცვან ქვემოთ მოცემული ნაბიჯები, რათა შეასრულონ NVS წაკითხვის/ჩაწერის ოპერაციები ჩართული დაშიფვრის შემთხვევაში.</p>
<blockquote>
<div><ol class="arabic simple">
<li>ძირითადი დანაყოფის და NVS მონაცემთა დანაყოფის პოვნა <code class="docutils literal notranslate"><span class="pre">esp_partition_find*</span></code> API ფუნქციები.</li>
<li>შეავსეთ <code class="docutils literal notranslate"><span class="pre">nvs_sec_cfg_t</span></code> სტრუქტურა, რომელიც იყენებს <code class="docutils literal notranslate"><span class="pre">nvs_flash_read_security_cfg</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_flash_generate_keys</span></code> API ფუნქციები.</li>
<li>NVS ფლეშ მეხსიერება დანაყოფის ინიციალიზაცია შემდეგი მეთოდის გამოყენებით: <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_flash_secure_init_partition</span></code> API ფუნქციები.</li>
<li>გახსენით სახელთა სივრცე შემდეგი ფუნქციის გამოყენებით: <code class="docutils literal notranslate"><span class="pre">nvs_open</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_open_from_part</span></code> API ფუნქციები.</li>
<li>NVS წაკითხვის/ჩაწერის ოპერაციების შესრულება <code class="docutils literal notranslate"><span class="pre">nvs_get_*</span></code> ან <code class="docutils literal notranslate"><span class="pre">nvs_set_*</span></code>.</li>
<li>NVS დანაყოფის დეინიციალიზაცია <code class="docutils literal notranslate"><span class="pre">nvs_flash_deinit</span></code>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="nvs-iterators">
<h3>NVS იტერატორები<a class="headerlink" href="nvs_flash.html#nvs-iterators" title="Permalink to this headline">¶</a></h3>
<p>იტერატორები საშუალებას იძლევიან ჩამოთვალონ NVS-ში შენახული გასაღები-მნიშვნელობის წყვილები, მითითებული დანაყოფის სახელის, სახელთა სივრცისა და მონაცემთა ტიპის მიხედვით.</p>
<p>ხელმისაწვდომია შემდეგი ფუნქციები:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_find</span></code> აბრუნებს გაუმჭვირვალე სახელურს, რომელიც გამოიყენება შემდგომ გამოძახებებში <code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> და <code class="docutils literal notranslate"><span class="pre">nvs_entry_info</span></code> ფუნქციები.</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> აბრუნებს იტერატორს შემდეგ გასაღებ-მნიშვნელობის წყვილზე.</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_entry_info</span></code> აბრუნებს ინფორმაციას თითოეული გასაღები-მნიშვნელობის წყვილის შესახებ</li>
</ul>
<p>თუ მოცემული კრიტერიუმებისთვის არცერთი ან სხვა გასაღები-მნიშვნელობის წყვილი არ მოიძებნა, <code class="docutils literal notranslate"><span class="pre">nvs_entry_find</span></code> და <code class="docutils literal notranslate"><span class="pre">nvs_entry_next</span></code> აბრუნებს NULL-ს. ამ შემთხვევაში, იტერატორის გაშვება საჭირო არ არის. თუ იტერატორი აღარ არის საჭირო, მისი გაშვება შეგიძლიათ ფუნქციის გამოყენებით. <code class="docutils literal notranslate"><span class="pre">nvs_release_iterator</span></code>.</p>
</div>
</div>
<div class="section" id="nvs-partition-generator-utility">
<h2>NVS დანაყოფების გენერატორის პროგრამა<a class="headerlink" href="nvs_flash.html#nvs-partition-generator-utility" title="Permalink to this headline">¶</a></h2>
<p>ეს პროგრამა ხელს უწყობს NVS დანაყოფების ორობითი ფაილების გენერირებას, რომელთა ფლეშ მეხსიერება რედაქტირება შესაძლებელია ცალკე, სპეციალურ დანაყოფზე, ფლეშ მეხსიერება რედაქტირების პროგრამის მეშვეობით. დანაყოფზე ფლეშ მეხსიერება რედაქტირების მიზნით გასაღები-მნიშვნელობის წყვილების მოწოდება შესაძლებელია CSV ფაილის საშუალებით. დამატებითი ინფორმაციისთვის იხილეთ <a class="reference internal" href="nvs_partition_gen.html"><span class="doc">NVS დანაყოფების გენერატორის პროგრამა</span></a>.</p>
</div>
<div class="section" id="application-example">
<h2>განაცხადის მაგალითი<a class="headerlink" href="nvs_flash.html#application-example" title="Permalink to this headline">¶</a></h2>
<p>კოდის ორი მაგალითის პოვნა შეგიძლიათ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage">საცავი</a> ESP-IDF მაგალითების დირექტორია:</p>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage/nvs_rw_value">საცავი/nvs_rw_value</a></p>
<blockquote>
<div><p>აჩვენებს, თუ როგორ წაიკითხოთ ერთი მთელი რიცხვი და ჩაწეროთ NVS-ში.</p>
<p>ამ მაგალითში შემოწმებული მნიშვნელობა შეიცავს ESP32 მოდულის გადატვირთვის რაოდენობას. მნიშვნელობის მრიცხველის ფუნქცია შესაძლებელია მხოლოდ NVS-ში მისი შენახვის წყალობით.</p>
<p>მაგალითი ასევე გვიჩვენებს, თუ როგორ შევამოწმოთ, წარმატებული იყო თუ არა წაკითხვის/ჩაწერის ოპერაცია, ან თუ NVS-ში გარკვეული მნიშვნელობა არ იყო ინიციალიზებული. დიაგნოსტიკური პროცედურა მოცემულია უბრალო ტექსტში, რათა დაგეხმაროთ პროგრამის ნაკადის თვალყურის დევნებასა და გზაში წარმოქმნილი ნებისმიერი პრობლემის დაფიქსირებაში.</p>
</div></blockquote>
<p><a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/storage/nvs_rw_blob">საცავი/nvs_rw_blob</a></p>
<blockquote>
<div><p>აჩვენებს, თუ როგორ წაიკითხოთ ერთი მთელი რიცხვი და blob (ორობითი დიდი ობიექტი) და ჩაწეროთ ისინი NVS-ში, რათა შეინახოთ ეს მნიშვნელობა ESP32 მოდულის გადატვირთვებს შორის.</p>
<blockquote>
<div><ul class="simple">
<li>მნიშვნელობა - აკონტროლებს ESP32 მოდულის რბილი და მყარი გადატვირთვის რაოდენობას.</li>
<li>blob - შეიცავს ცხრილს მოდულის გაშვების დროებით. ცხრილი იკითხება NVS-დან დინამიურად გამოყოფილ ოპერატიულ მეხსიერებაში. ყოველი ხელით გააქტიურებული რბილი გადატვირთვისას ცხრილს ემატება ახალი გაშვების დრო და შემდეგ დამატებული გაშვების დრო იწერება NVS-ში. ტრიგერირება ხდება GPIO 0-ის ჩამოწევით.</li>
</ul>
</div></blockquote>
<p>მაგალითი ასევე გვიჩვენებს, თუ როგორ უნდა განხორციელდეს დიაგნოსტიკური პროცედურა იმის შესამოწმებლად, წარმატებული იყო თუ არა წაკითხვის/ჩაწერის ოპერაცია.</p>
</div></blockquote>
</div>
<div class="section" id="api-reference">
<h2>API მითითება<a class="headerlink" href="nvs_flash.html#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="nvs_flash.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/nvs_flash/include/nvs_flash.h">nvs_ ფლეშ მეხსიერება /include/nvs_ ფლეშ მეხსიერება .h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="nvs_flash.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv414nvs_flash_initv">
<span id="_CPPv314nvs_flash_initv"></span><span id="_CPPv214nvs_flash_initv"></span><span id="nvs_flash_init__void"></span><span class="target" id="nvs__flash_8h_1a0c37702eca98ffe39ff4d8a47a0e093f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv414nvs_flash_initv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ნაგულისხმევი NVS დანაყოფის ინიციალიზაცია. </p>
<p>ეს API ახდენს NVS-ის ნაგულისხმევი დანაყოფის ინიციალიზაციას. ნაგულისხმევი NVS დანაყოფი არის ის, რომელიც დანაყოფების ცხრილი ში მონიშნულია, როგორც „nvs“.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მეხსიერება წარმატებით ინიციალიზებულია.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES თუ NVS საცავი არ შეიცავს ცარიელ გვერდებს (რაც შეიძლება მოხდეს, თუ NVS დანაყოფი შეკვეცილია)</li>
<li>ESP_ERR_NOT_FOUND თუ დანაყოფების ცხრილი ში არ მოიძებნება დანაყოფი „nvs“ ეტიკეტით.</li>
<li>ძირითადი ფლეშ მეხსიერება შენახვის დრაივერის შეცდომის კოდიდან ერთ-ერთი </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424nvs_flash_init_partitionPKc">
<span id="_CPPv324nvs_flash_init_partitionPKc"></span><span id="_CPPv224nvs_flash_init_partitionPKc"></span><span id="nvs_flash_init_partition__cCP"></span><span class="target" id="nvs__flash_8h_1ae744286f362cca501e9f3cf753d538ea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_init_partition</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>დანაყოფის_ეტიკეტი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv424nvs_flash_init_partitionPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მითითებული დანაყოფისთვის NVS ფლეშ მეხსიერება საცავის ინიციალიზაცია. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მეხსიერება წარმატებით ინიციალიზებულია.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES თუ NVS საცავი არ შეიცავს ცარიელ გვერდებს (რაც შეიძლება მოხდეს, თუ NVS დანაყოფი შეკვეცილია)</li>
<li>ESP_ERR_NOT_FOUND თუ მითითებული დანაყოფი არ არის ნაპოვნი დანაყოფების ცხრილი ში</li>
<li>ძირითადი ფლეშ მეხსიერება შენახვის დრაივერის შეცდომის კოდიდან ერთ-ერთი </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: დანაყოფის იარლიყი. არ უნდა აღემატებოდეს 16 სიმბოლოს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416nvs_flash_deinitv">
<span id="_CPPv316nvs_flash_deinitv"></span><span id="_CPPv216nvs_flash_deinitv"></span><span id="nvs_flash_deinit__void"></span><span class="target" id="nvs__flash_8h_1ab0743d413ccfb038ea2cc78a151bbfb6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_deinit</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv416nvs_flash_deinitv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>NVS საცავის დეინიციალიზაცია ნაგულისხმევი NVS დანაყოფისთვის. </p>
<p>ნაგულისხმევი NVS დანაყოფი არის დანაყოფი, რომლის დანაყოფების ცხრილი შიც არის „nvs“ ლეიბლი.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატებით დასრულდა (მეხსიერება დეინიციალიზებული იყო)</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED, თუ საცავი ამ ზარამდე არ იყო ინიციალიზებული. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426nvs_flash_deinit_partitionPKc">
<span id="_CPPv326nvs_flash_deinit_partitionPKc"></span><span id="_CPPv226nvs_flash_deinit_partitionPKc"></span><span id="nvs_flash_deinit_partition__cCP"></span><span class="target" id="nvs__flash_8h_1a16c7e9782bc34910db1e2811034a113c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_deinit_partition</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>დანაყოფის_ეტიკეტი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv426nvs_flash_deinit_partitionPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული NVS დანაყოფისთვის NVS საცავის დეინიციალიზაცია. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED, თუ მოცემული დანაყოფის მეხსიერება არ იყო ინიციალიზებული ამ ზარამდე. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: დანაყოფის ეტიკეტი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415nvs_flash_erasev">
<span id="_CPPv315nvs_flash_erasev"></span><span id="_CPPv215nvs_flash_erasev"></span><span id="nvs_flash_erase__void"></span><span class="target" id="nvs__flash_8h_1ac9e4c719ccdb0d92ba974012868435cf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_erase</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv415nvs_flash_erasev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაშალეთ ნაგულისხმევი NVS დანაყოფი. </p>
<p>ეს ფუნქცია შლის ნაგულისხმევი NVS დანაყოფის მთელ შინაარსს (ის, რომელსაც აქვს „nvs“ ეტიკეტი).</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_FOUND თუ დანაყოფების ცხრილი ში არ არის NVS დანაყოფი, რომელიც მონიშნულია როგორც „nvs“. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425nvs_flash_erase_partitionPKc">
<span id="_CPPv325nvs_flash_erase_partitionPKc"></span><span id="_CPPv225nvs_flash_erase_partitionPKc"></span><span id="nvs_flash_erase_partition__cCP"></span><span class="target" id="nvs__flash_8h_1aac0d1a70e1e4fb943c7a201bc27025b4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_erase_partition</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>ნაწილის_სახელი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv425nvs_flash_erase_partitionPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მითითებული NVS დანაყოფის წაშლა. </p>
<p>ეს ფუნქცია შლის მითითებული NVS დანაყოფის მთელ შინაარსს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_FOUND თუ დანაყოფების ცხრილი ში მითითებული სახელით არ არსებობს NVS დანაყოფი. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>წასაშლელი დანაყოფის სახელი (ეტიკეტი)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t">
<span id="_CPPv321nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="_CPPv221nvs_flash_secure_initP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init__nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a0ab41aa24c30907de227cfb31535071c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_secure_init</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv421nvs_flash_secure_initP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ნაგულისხმევი NVS დანაყოფის ინიციალიზაცია. </p>
<p>ეს API ახდენს NVS-ის ნაგულისხმევი დანაყოფის ინიციალიზაციას. ნაგულისხმევი NVS დანაყოფი არის ის, რომელიც დანაყოფების ცხრილი ში მონიშნულია, როგორც „nvs“.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მეხსიერება წარმატებით ინიციალიზებულია.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES თუ NVS საცავი არ შეიცავს ცარიელ გვერდებს (რაც შეიძლება მოხდეს, თუ NVS დანაყოფი შეკვეცილია)</li>
<li>ESP_ERR_NOT_FOUND თუ დანაყოფების ცხრილი ში არ მოიძებნება დანაყოფი „nvs“ ეტიკეტით.</li>
<li>ძირითადი ფლეშ მეხსიერება შენახვის დრაივერის შეცდომის კოდიდან ერთ-ერთი </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>NVS დაშიფვრისთვის/გაშიფვრისთვის გამოსაყენებელი უსაფრთხოების კონფიგურაცია (გასაღებები). თუ cfg არის NULL, დაშიფვრა არ გამოიყენება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t">
<span id="_CPPv331nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="_CPPv231nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t"></span><span id="nvs_flash_secure_init_partition__cCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1af14231de1efc20d250b0f953698350a5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_secure_init_partition</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>დანაყოფის_ეტიკეტი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv431nvs_flash_secure_init_partitionPKcP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მითითებული დანაყოფისთვის NVS ფლეშ მეხსიერება საცავის ინიციალიზაცია. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მეხსიერება წარმატებით ინიციალიზებულია.</li>
<li>ESP_ERR_NVS_NO_FREE_PAGES თუ NVS საცავი არ შეიცავს ცარიელ გვერდებს (რაც შეიძლება მოხდეს, თუ NVS დანაყოფი შეკვეცილია)</li>
<li>ESP_ERR_NOT_FOUND თუ მითითებული დანაყოფი არ არის ნაპოვნი დანაყოფების ცხრილი ში</li>
<li>ძირითადი ფლეშ მეხსიერება შენახვის დრაივერის შეცდომის კოდიდან ერთ-ერთი </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition_label</span></code>: დანაყოფის იარლიყი. გაითვალისწინეთ, რომ შიდა წყაროში ინახება გადაცემული მნიშვნელობის მითითება და ის ხელმისაწვდომი უნდა იყოს მომავალი ოპერაციებისთვის.</li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>NVS დაშიფვრისთვის/გაშიფვრისთვის გამოსაყენებელი უსაფრთხოების კონფიგურაცია (გასაღებები). თუ cfg არის null, დაშიფვრა/გაშიფვრა არ გამოიყენება. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv323nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv223nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_generate_keys__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1a1eb890121d0e1f76d9ba873783d53e51"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_generate_keys</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv423nvs_flash_generate_keysPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>NVS გასაღებების გენერირება და შენახვა მოცემულ esp დანაყოფში. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>-ESP_OK, if cfg was read successfully; -or error codes from esp_partition_write/erase APIs. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: nvs უსაფრთხოების კონფიგურაციის სტრუქტურის მაჩვენებელი. მაჩვენებელი არ უნდა იყოს NULL. გენერირებული გასაღებები ამ სტრუქტურაში შეივსება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t">
<span id="_CPPv327nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="_CPPv227nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t"></span><span id="nvs_flash_read_security_cfg__esp_partition_tCP.nvs_sec_cfg_tP"></span><span class="target" id="nvs__flash_8h_1ad2b9fc8e49a07eee8c83410686efad67"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_flash_read_security_cfg</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="spi_flash.html#_CPPv415esp_partition_t" title="esp_partition_t">esp_partition_t</a> *<em>დანაყოფი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv413nvs_sec_cfg_t" title="nvs_sec_cfg_t">nvs_sec_cfg_t</a> *<em>cfg</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv427nvs_flash_read_security_cfgPK15esp_partition_tP13nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაიკითხეთ NVS უსაფრთხოების კონფიგურაცია დანაყოფიდან. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Provided parition is assumed to be marked ‘encrypted’.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>-ESP_OK, if cfg was read successfully; -ESP_ERR_NVS_KEYS_NOT_INITIALIZED, if the partition is not yet written with keys. -ESP_ERR_NVS_CORRUPT_KEY_PART, if the partition containing keys is found to be corrupt -or error codes from esp_partition_read API. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">partition</span></code>: esp_partition_find_first-ის ან esp_partition_get-ის გამოყენებით მიღებული დანაყოფის სტრუქტურის მაჩვენებელი. არ უნდა იყოს NULL. </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: nvs უსაფრთხოების კონფიგურაციის სტრუქტურის მაჩვენებელი. მაჩვენებელი უნდა იყოს არა-NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="nvs_flash.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv413nvs_sec_cfg_t">
<span id="_CPPv313nvs_sec_cfg_t"></span><span id="_CPPv213nvs_sec_cfg_t"></span><span id="nvs_sec_cfg_t"></span><span class="target" id="structnvs__sec__cfg__t"></span><em class="property">სტრუქტურა </em><code class="descname">nvs_sec_cfg_t</code><a class="headerlink" href="nvs_flash.html#_CPPv413nvs_sec_cfg_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაშიფვრისა და გაშიფვრის გასაღები. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N13nvs_sec_cfg_t3ekyE">
<span id="_CPPv3N13nvs_sec_cfg_t3ekyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3ekyE"></span><span id="nvs_sec_cfg_t::eky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1aca7c1ea3cb7735702e159dbbd7059c0f"></span>uint8_t <code class="descname">eky</code>[<code class="descname">NVS_KEY_SIZE</code>]<a class="headerlink" href="nvs_flash.html#_CPPv4N13nvs_sec_cfg_t3ekyE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>XTS დაშიფვრისა და გაშიფვრის გასაღები </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N13nvs_sec_cfg_t3tkyE">
<span id="_CPPv3N13nvs_sec_cfg_t3tkyE"></span><span id="_CPPv2N13nvs_sec_cfg_t3tkyE"></span><span id="nvs_sec_cfg_t::tky__uint8_tA"></span><span class="target" id="structnvs__sec__cfg__t_1a2bcd305f3bdc0b10ea93c6c983073774"></span>uint8_t <code class="descname">tky</code>[<code class="descname">NVS_KEY_SIZE</code>]<a class="headerlink" href="nvs_flash.html#_CPPv4N13nvs_sec_cfg_t3tkyE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>XTS-ის რეგულირების გასაღები </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="nvs_flash.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.NVS_KEY_SIZE">
<span class="target" id="nvs__flash_8h_1a3c4e07a22cf5967ebf64fe7db4cec3bc"></span><code class="descname">NVS_KEY_SIZE</code><a class="headerlink" href="nvs_flash.html#c.NVS_KEY_SIZE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</div>
<div class="section" id="id5">
<h3>სათაურის ფაილი<a class="headerlink" href="nvs_flash.html#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/nvs_flash/include/nvs.h">nvs_ ფლეშ მეხსიერება /include/nvs.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>ფუნქციები<a class="headerlink" href="nvs_flash.html#id6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t">
<span id="_CPPv310nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="_CPPv210nvs_set_i812nvs_handle_tPKc6int8_t"></span><span id="nvs_set_i8__nvs_handle_t.cCP.int8_t"></span><span class="target" id="nvs_8h_1a6a88f61dcb7d0dc2b76e0cbb019d1eca"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i8</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int8_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_set_i812nvs_handle_tPKc6int8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული გასაღებისთვის მნიშვნელობის დაყენება </p>
<p>ფუნქციების ეს ოჯახი გასაღებისთვის მნიშვნელობას ადგენს მისი სახელის მიხედვით. გაითვალისწინეთ, რომ ფაქტობრივი მეხსიერება არ განახლდება nvs_commit ფუნქციის გამოძახებამდე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK თუ მნიშვნელობა წარმატებით დაყენდა</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_READ_ONLY, თუ შენახვის სახელური გახსნილი იყო მხოლოდ წასაკითხად</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ გასაღების სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>ESP_ERR_NVS_NOT_ENOUGH_SPACE, თუ ძირითად საცავში მნიშვნელობის შესანახად საკმარისი ადგილი არ არის.</li>
<li>ESP_ERR_NVS_REMOVE_FAILED, თუ მნიშვნელობა არ განახლდა, რადგან ფლეშ მეხსიერება ჩაწერის ოპერაცია ვერ შესრულდა. თუმცა, მნიშვნელობა ჩაიწერა და განახლება დასრულდება nvs-ის ხელახალი ინიციალიზაციის შემდეგ, იმ პირობით, რომ ფლეშ მეხსიერება ოპერაცია ხელახლა არ შესრულდება.</li>
<li>ESP_ERR_NVS_VALUE_TOO_LONG თუ სტრიქონის მნიშვნელობა ძალიან გრძელია </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: nvs_open ფუნქციიდან მიღებული სახელური. მხოლოდ წასაკითხად გახსნილი სახელურების გამოყენება შეუძლებელია. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>გასაღების სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: დასაყენებელი მნიშვნელობა. სტრიქონებისთვის მაქსიმალური სიგრძე (null სიმბოლოს ჩათვლით) 4000 ბაიტია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t">
<span id="_CPPv310nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="_CPPv210nvs_set_u812nvs_handle_tPKc7uint8_t"></span><span id="nvs_set_u8__nvs_handle_t.cCP.uint8_t"></span><span class="target" id="nvs_8h_1a0305af52aebc7d263ca2403d22de69a9"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u8</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint8_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_set_u812nvs_handle_tPKc7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t">
<span id="_CPPv311nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="_CPPv211nvs_set_i1612nvs_handle_tPKc7int16_t"></span><span id="nvs_set_i16__nvs_handle_t.cCP.int16_t"></span><span class="target" id="nvs_8h_1ae2bb6637981f4d32bc29cdd200330aaf"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i16</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int16_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_i1612nvs_handle_tPKc7int16_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t">
<span id="_CPPv311nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="_CPPv211nvs_set_u1612nvs_handle_tPKc8uint16_t"></span><span id="nvs_set_u16__nvs_handle_t.cCP.uint16_t"></span><span class="target" id="nvs_8h_1ae429cc09c14acb611a9f385480999de6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u16</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint16_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_u1612nvs_handle_tPKc8uint16_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t">
<span id="_CPPv311nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="_CPPv211nvs_set_i3212nvs_handle_tPKc7int32_t"></span><span id="nvs_set_i32__nvs_handle_t.cCP.int32_t"></span><span class="target" id="nvs_8h_1a3dae5d19be95ef744036ccd6684a0eea"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i32</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int32_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_i3212nvs_handle_tPKc7int32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t">
<span id="_CPPv311nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="_CPPv211nvs_set_u3212nvs_handle_tPKc8uint32_t"></span><span id="nvs_set_u32__nvs_handle_t.cCP.uint32_t"></span><span class="target" id="nvs_8h_1a7e447c2369a1c2823ae01f653bef0bab"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u32</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint32_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_u3212nvs_handle_tPKc8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t">
<span id="_CPPv311nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="_CPPv211nvs_set_i6412nvs_handle_tPKc7int64_t"></span><span id="nvs_set_i64__nvs_handle_t.cCP.int64_t"></span><span class="target" id="nvs_8h_1a4f12f2d4d68a095278020b8c116a0f2d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_i64</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int64_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_i6412nvs_handle_tPKc7int64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t">
<span id="_CPPv311nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="_CPPv211nvs_set_u6412nvs_handle_tPKc8uint64_t"></span><span id="nvs_set_u64__nvs_handle_t.cCP.uint64_t"></span><span class="target" id="nvs_8h_1ab45a7dd95b3b2ada70cd1bba809f20a4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_u64</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint64_t <em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_u6412nvs_handle_tPKc8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_set_str12nvs_handle_tPKcPKc">
<span id="_CPPv311nvs_set_str12nvs_handle_tPKcPKc"></span><span id="_CPPv211nvs_set_str12nvs_handle_tPKcPKc"></span><span id="nvs_set_str__nvs_handle_t.cCP.cCP"></span><span class="target" id="nvs_8h_1a66c6390e31cce9c4d59dc874d242ddac"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_str</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, <em class="property">კონსტ</em> char *<em>ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_set_str12nvs_handle_tPKcPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t">
<span id="_CPPv310nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="_CPPv210nvs_get_i812nvs_handle_tPKcP6int8_t"></span><span id="nvs_get_i8__nvs_handle_t.cCP.int8_tP"></span><span class="target" id="nvs_8h_1a6ecc74483c38916ea9f66fc07d086333"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i8</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int8_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_get_i812nvs_handle_tPKcP6int8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული გასაღების მნიშვნელობა </p>
<p>ეს ფუნქციები გასაღების მნიშვნელობას მისი სახელის მიხედვით იღებენ. თუ გასაღები არ არსებობს, ან მოთხოვნილი ცვლადის ტიპი არ ემთხვევა მნიშვნელობის დაყენებისას გამოყენებულ ტიპს, ბრუნდება შეცდომა.</p>
<p>ნებისმიერი შეცდომის შემთხვევაში, out_value არ შეიცვლება.</p>
<p>ყველა ფუნქცია მოელის, რომ out_value იქნება მოცემული ტიპის უკვე გამოყოფილი ცვლადის მაჩვენებელი.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_i32</span><span class="p">:</span>
<span class="n">int32_t</span> <span class="n">max_buffer_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span> <span class="o">//</span> <span class="n">default</span> <span class="n">value</span>
<span class="n">esp_err_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nvs_get_i32</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">"max_buffer_size"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_buffer_size</span><span class="p">);</span>
<span class="k">assert</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">ESP_OK</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="n">ESP_ERR_NVS_NOT_FOUND</span><span class="p">);</span>
<span class="o">//</span> <span class="k">if</span> <span class="n">ESP_ERR_NVS_NOT_FOUND</span> <span class="n">was</span> <span class="n">returned</span><span class="p">,</span> <span class="n">max_buffer_size</span> <span class="n">will</span> <span class="n">still</span>
<span class="o">//</span> <span class="n">have</span> <span class="n">its</span> <span class="n">default</span> <span class="n">value</span><span class="o">.</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მნიშვნელობა წარმატებით იქნა აღებული</li>
<li>ESP_ERR_NVS_NOT_FOUND თუ მოთხოვნილი გასაღები არ არსებობს</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ გასაღების სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>ESP_ERR_NVS_INVALID_LENGTH თუ სიგრძე არ არის საკმარისი მონაცემების შესანახად </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: nvs_open ფუნქციიდან მიღებული სახელური. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>გასაღების სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_value</span></code>: გამომავალი მნიშვნელობის მაჩვენებელი. შეიძლება იყოს NULL nvs_get_str-ისა და nvs_get_blob-ისთვის, ამ შემთხვევაში საჭირო სიგრძე დაბრუნდება სიგრძის არგუმენტში.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t">
<span id="_CPPv310nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="_CPPv210nvs_get_u812nvs_handle_tPKcP7uint8_t"></span><span id="nvs_get_u8__nvs_handle_t.cCP.uint8_tP"></span><span class="target" id="nvs_8h_1aee87db8410ac85302127351c817d6bae"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u8</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint8_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_get_u812nvs_handle_tPKcP7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t">
<span id="_CPPv311nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="_CPPv211nvs_get_i1612nvs_handle_tPKcP7int16_t"></span><span id="nvs_get_i16__nvs_handle_t.cCP.int16_tP"></span><span class="target" id="nvs_8h_1a6394a84e240d897d184ad5fc539e2aed"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i16</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int16_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_i1612nvs_handle_tPKcP7int16_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t">
<span id="_CPPv311nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="_CPPv211nvs_get_u1612nvs_handle_tPKcP8uint16_t"></span><span id="nvs_get_u16__nvs_handle_t.cCP.uint16_tP"></span><span class="target" id="nvs_8h_1a4b44fa374e23455a31cdc17a7fbc8207"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u16</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint16_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_u1612nvs_handle_tPKcP8uint16_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t">
<span id="_CPPv311nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="_CPPv211nvs_get_i3212nvs_handle_tPKcP7int32_t"></span><span id="nvs_get_i32__nvs_handle_t.cCP.int32_tP"></span><span class="target" id="nvs_8h_1a911777e4654ca5bf1c46b1c20a8e7299"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i32</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int32_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_i3212nvs_handle_tPKcP7int32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t">
<span id="_CPPv311nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="_CPPv211nvs_get_u3212nvs_handle_tPKcP8uint32_t"></span><span id="nvs_get_u32__nvs_handle_t.cCP.uint32_tP"></span><span class="target" id="nvs_8h_1a85f3f2811ad0495884fb032406e557a6"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u32</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint32_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_u3212nvs_handle_tPKcP8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t">
<span id="_CPPv311nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="_CPPv211nvs_get_i6412nvs_handle_tPKcP7int64_t"></span><span id="nvs_get_i64__nvs_handle_t.cCP.int64_tP"></span><span class="target" id="nvs_8h_1a92650d8ea9025da2c00e0f6ac4d11c85"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_i64</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, int64_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_i6412nvs_handle_tPKcP7int64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t">
<span id="_CPPv311nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="_CPPv211nvs_get_u6412nvs_handle_tPKcP8uint64_t"></span><span id="nvs_get_u64__nvs_handle_t.cCP.uint64_tP"></span><span class="target" id="nvs_8h_1ab9af4ab56ac2f338f3c076d35513bbd5"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_u64</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, uint64_t *<em>გადაჭარბებული_ღირებულება</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_u6412nvs_handle_tPKcP8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t">
<span id="_CPPv311nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="_CPPv211nvs_get_str12nvs_handle_tPKcPcP6size_t"></span><span id="nvs_get_str__nvs_handle_t.cCP.cP.sP"></span><span class="target" id="nvs_8h_1a9e6cf0362aba1ed1601ea2d4af427d3d"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_str</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, char *<em>გადაჭარბებული_ღირებულება</em>, size_t *<em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_get_str12nvs_handle_tPKcPcP6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული გასაღების მნიშვნელობა </p>
<p>ეს ფუნქციები ჩანაწერის მონაცემებს იღებენ მისი გასაღების მიხედვით. თუ გასაღები არ არსებობს, ან მოთხოვნილი ცვლადის ტიპი არ ემთხვევა მნიშვნელობის დაყენებისას გამოყენებულ ტიპს, ბრუნდება შეცდომა.</p>
<p>ნებისმიერი შეცდომის შემთხვევაში, out_value არ შეიცვლება.</p>
<p>ყველა ფუნქცია მოელის, რომ out_value იქნება მოცემული ტიპის უკვე გამოყოფილი ცვლადის მაჩვენებელი.</p>
<p>nvs_get_str და nvs_get_blob ფუნქციები მხარს უჭერენ Win API სტილის სიგრძის შეკითხვებს. მნიშვნელობის შესანახად საჭირო ზომის მისაღებად, გამოიძახეთ nvs_get_str ან nvs_get_blob ნულოვანი out_value-ით და სიგრძისკენ არანულოვანი მაჩვენებლით. სიგრძის არგუმენტით მითითებულ ცვლადს მიენიჭება საჭირო სიგრძე. nvs_get_str-ისთვის, ეს სიგრძე მოიცავს ნულოვანი ტერმინატორს. nvs_get_str-ის და nvs_get_blob-ის არანულოვანი out_value-ით გამოძახებისას, სიგრძე უნდა იყოს არანულოვანი და უნდა მიუთითებდეს out_value-ში ხელმისაწვდომ სიგრძეზე. რეკომენდებულია, რომ nvs_get/set_str გამოყენებული იქნას ნულოვანი დაბოლოებით C სტრიქონებისთვის, ხოლო nvs_get/set_blob - ნებისმიერი მონაცემთა სტრუქტურებისთვის.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="p">(</span><span class="n">without</span> <span class="n">error</span> <span class="n">checking</span><span class="p">)</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_str</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">string</span> <span class="n">into</span> <span class="n">dynamic</span> <span class="n">array</span><span class="p">:</span>
<span class="n">size_t</span> <span class="n">required_size</span><span class="p">;</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">"server_name"</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>
<span class="n">char</span><span class="o">*</span> <span class="n">server_name</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">required_size</span><span class="p">);</span>
<span class="n">nvs_get_str</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">"server_name"</span><span class="p">,</span> <span class="n">server_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">required_size</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Example</span> <span class="p">(</span><span class="n">without</span> <span class="n">error</span> <span class="n">checking</span><span class="p">)</span> <span class="n">of</span> <span class="n">using</span> <span class="n">nvs_get_blob</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">binary</span> <span class="n">data</span>
<span class="n">into</span> <span class="n">a</span> <span class="n">static</span> <span class="n">array</span><span class="p">:</span>
<span class="n">uint8_t</span> <span class="n">mac_addr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="n">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">mac_addr</span><span class="p">);</span>
<span class="n">nvs_get_blob</span><span class="p">(</span><span class="n">my_handle</span><span class="p">,</span> <span class="s2">"dst_mac_addr"</span><span class="p">,</span> <span class="n">mac_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ მნიშვნელობა წარმატებით იქნა აღებული</li>
<li>ESP_ERR_NVS_NOT_FOUND თუ მოთხოვნილი გასაღები არ არსებობს</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ გასაღების სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>ESP_ERR_NVS_INVALID_LENGTH თუ სიგრძე არ არის საკმარისი მონაცემების შესანახად </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: nvs_open ფუნქციიდან მიღებული სახელური. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>გასაღების სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_value</span></code>: გამომავალი მნიშვნელობის მაჩვენებელი. შეიძლება იყოს NULL nvs_get_str-ისა და nvs_get_blob-ისთვის, ამ შემთხვევაში საჭირო სიგრძე დაბრუნდება სიგრძის არგუმენტში. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: არანულოვანი მაჩვენებელი ცვლადზე, რომელიც შეიცავს out_value-ს სიგრძეს. იმ შემთხვევაში, თუ out_value ნულის ტოლია, დაყენდება მნიშვნელობის შესანახად საჭირო სიგრძე. იმ შემთხვევაში, თუ out_value ნულის ტოლია, დაყენდება ჩაწერილი მნიშვნელობის ფაქტობრივი სიგრძე. nvs_get_str-ისთვის ეს მოიცავს ნულის ტერმინატორს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t">
<span id="_CPPv312nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="_CPPv212nvs_get_blob12nvs_handle_tPKcPvP6size_t"></span><span id="nvs_get_blob__nvs_handle_t.cCP.voidP.sP"></span><span class="target" id="nvs_8h_1a407a597cf06407140d91f7898bf541f4"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_blob</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, void *<em>გადაჭარბებული_ღირებულება</em>, size_t *<em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv412nvs_get_blob12nvs_handle_tPKcPvP6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv38nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv28nvs_openPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open__cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1ab6677099a61deabc00d05b2c92f6b0dc"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_open</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>სახელი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <em>გახსნის_რეჟიმი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> *<em>გაუმკლავებელი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv48nvs_openPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გახსენით არასტაბილური საცავი მოცემული სახელთა სივრცით ნაგულისხმევი NVS დანაყოფიდან. </p>
<p>რამდენიმე შიდა ESP-IDF და მესამე მხარის აპლიკაციის მოდულს შეუძლია შეინახოს თავისი გასაღები-მნიშვნელობის წყვილები NVS მოდულში. გასაღების სახელებთან დაკავშირებული შესაძლო კონფლიქტების შესამცირებლად, თითოეულ მოდულს შეუძლია გამოიყენოს საკუთარი სახელთა სივრცე. ნაგულისხმევი NVS დანაყოფი არის ის, რომელიც დანაყოფების ცხრილი ში მონიშნულია როგორც „nvs“.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ შენახვის სახელური წარმატებით გაიხსნა</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED თუ შენახვის დრაივერი არ არის ინიციალიზებული</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND თუ დანაყოფი „nvs“ ეტიკეტით ვერ მოიძებნა</li>
<li>ESP_ERR_NVS_NOT_FOUND id სახელთა სივრცე ჯერ არ არსებობს და რეჟიმი არის NVS_READONLY.</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ სახელთა სივრცის სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>სხვა შეცდომის კოდები ძირითადი შენახვის დრაივერიდან </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: სახელთა სივრცის სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">open_mode</span></code>: NVS_READWRITE ან NVS_READONLY. თუ NVS_READONLY, გახსნის მხოლოდ წასაკითხ სახელურს. ამ სახელურისთვის ყველა ჩაწერის მოთხოვნა უარყოფილი იქნება. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>წარმატების შემთხვევაში (დაბრუნების კოდი ნულია), ამ არგუმენტში დაბრუნდება სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t">
<span id="_CPPv323nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="_CPPv223nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t"></span><span id="nvs_open_from_partition__cCP.cCP.nvs_open_mode_t.nvs_handle_tP"></span><span class="target" id="nvs_8h_1a2e144fcac4b67d4e587a947f099db16b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_open_from_partition</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>ნაწილის_სახელი</em>, <em class="property">კონსტ</em> char *<em>სახელი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <em>გახსნის_რეჟიმი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> *<em>გაუმკლავებელი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv423nvs_open_from_partitionPKcPKc15nvs_open_mode_tP12nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გახსენით არასტაბილური საცავი მოცემული სახელთა სივრცით მითითებული დანაყოფიდან. </p>
<p>ქცევა იგივეა, რაც nvs_open() API . თუმცა, ამ API შეუძლია იმუშაოს მითითებულ NVS დანაყოფზე ნაგულისხმევი NVS დანაყოფის ნაცვლად. გაითვალისწინეთ, რომ მითითებული დანაყოფი უნდა იყოს რეგისტრირებული NVS-ში nvs_ ფლეშ მეხსიერება _init_partition() API გამოყენებით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ შენახვის სახელური წარმატებით გაიხსნა</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED თუ შენახვის დრაივერი არ არის ინიციალიზებული</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND თუ მითითებული სახელის მქონე დანაყოფი ვერ მოიძებნა</li>
<li>ESP_ERR_NVS_NOT_FOUND id სახელთა სივრცე ჯერ არ არსებობს და რეჟიმი არის NVS_READONLY.</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ სახელთა სივრცის სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>სხვა შეცდომის კოდები ძირითადი შენახვის დრაივერიდან </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: ობიექტის წაკითხვის/ჩაწერის/წაშლისთვის საინტერესო დანაყოფის იარლიყი (სახელი) </li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: სახელთა სივრცის სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">open_mode</span></code>: NVS_READWRITE ან NVS_READONLY. თუ NVS_READONLY, გახსნის მხოლოდ წასაკითხ სახელურს. ამ სახელურისთვის ყველა ჩაწერის მოთხოვნა უარყოფილი იქნება. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>წარმატების შემთხვევაში (დაბრუნების კოდი ნულია), ამ არგუმენტში დაბრუნდება სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t">
<span id="_CPPv312nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="_CPPv212nvs_set_blob12nvs_handle_tPKcPKv6size_t"></span><span id="nvs_set_blob__nvs_handle_t.cCP.voidCP.s"></span><span class="target" id="nvs_8h_1a2a2a8a79c0df9a1682d0a1bc31f351c3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_set_blob</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em>, <em class="property">კონსტ</em> void *<em>ღირებულება</em>, size_t <em>სიგრძე</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv412nvs_set_blob12nvs_handle_tPKcPKv6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული გასაღებისთვის ცვლადი სიგრძის ორობითი მნიშვნელობის დაყენება </p>
<p>ფუნქციების ეს ოჯახი გასაღებისთვის მნიშვნელობას ადგენს მისი სახელის მიხედვით. გაითვალისწინეთ, რომ ფაქტობრივი მეხსიერება არ განახლდება nvs_commit ფუნქციის გამოძახებამდე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK თუ მნიშვნელობა წარმატებით დაყენდა</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_READ_ONLY, თუ შენახვის სახელური გახსნილი იყო მხოლოდ წასაკითხად</li>
<li>ESP_ERR_NVS_INVALID_NAME თუ გასაღების სახელი არ აკმაყოფილებს შეზღუდვებს</li>
<li>ESP_ERR_NVS_NOT_ENOUGH_SPACE, თუ ძირითად საცავში მნიშვნელობის შესანახად საკმარისი ადგილი არ არის.</li>
<li>ESP_ERR_NVS_REMOVE_FAILED, თუ მნიშვნელობა არ განახლდა, რადგან ფლეშ მეხსიერება ჩაწერის ოპერაცია ვერ შესრულდა. თუმცა, მნიშვნელობა ჩაიწერა და განახლება დასრულდება nvs-ის ხელახალი ინიციალიზაციის შემდეგ, იმ პირობით, რომ ფლეშ მეხსიერება ოპერაცია ხელახლა არ შესრულდება.</li>
<li>ESP_ERR_NVS_VALUE_TOO_LONG თუ მნიშვნელობა ძალიან გრძელია </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: nvs_open ფუნქციიდან მიღებული სახელური. მხოლოდ წასაკითხად გახსნილი სახელურების გამოყენება შეუძლებელია. </li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>: გასაღების სახელი. მაქსიმალური სიგრძე 15 სიმბოლოა. არ უნდა იყოს ცარიელი. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: დასაყენებელი მნიშვნელობა. </li>
<li><code class="docutils literal notranslate"><span class="pre">length</span></code>: დასაყენებელი ორობითი მნიშვნელობის სიგრძე, ბაიტებში; მაქსიმალური სიგრძეა 508000 ბაიტი ან (დანიჯის ზომის 97.6% - 4000) ბაიტი, რომელიც უფრო ნაკლებია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv413nvs_erase_key12nvs_handle_tPKc">
<span id="_CPPv313nvs_erase_key12nvs_handle_tPKc"></span><span id="_CPPv213nvs_erase_key12nvs_handle_tPKc"></span><span id="nvs_erase_key__nvs_handle_t.cCP"></span><span class="target" id="nvs_8h_1a0ba2174523872e14ef96b3add427e4dd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_erase_key</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, <em class="property">კონსტ</em> char *<em>გასაღები</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv413nvs_erase_key12nvs_handle_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული გასაღების სახელით გასაღები-მნიშვნელობის წყვილის წაშლა. </p>
<p>გაითვალისწინეთ, რომ ფაქტობრივი მეხსიერება შეიძლება არ განახლდეს nvs_commit ფუნქციის გამოძახებამდე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ წაშლის ოპერაცია წარმატებული იყო</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_READ_ONLY თუ სახელური გახსნილი იყო მხოლოდ წასაკითხად</li>
<li>ESP_ERR_NVS_NOT_FOUND თუ მოთხოვნილი გასაღები არ არსებობს</li>
<li>სხვა შეცდომის კოდები ძირითადი შენახვის დრაივერიდან </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: შენახვის სახელური მიღებულია nvs_open-ით. მხოლოდ წასაკითხად გახსნილი სახელურების გამოყენება შეუძლებელია.</li>
<li><code class="docutils literal notranslate"><span class="pre">key</span></code>გასაღების სახელი. მაქსიმალური სიგრძე განისაზღვრება ძირითადი იმპლემენტაციით, მაგრამ გარანტირებულია, რომ ის მინიმუმ 15 სიმბოლო იქნება. არ უნდა იყოს ცარიელი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv413nvs_erase_all12nvs_handle_t">
<span id="_CPPv313nvs_erase_all12nvs_handle_t"></span><span id="_CPPv213nvs_erase_all12nvs_handle_t"></span><span id="nvs_erase_all__nvs_handle_t"></span><span class="target" id="nvs_8h_1a8c72514b8e1a7c464ad0356e4927158b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_erase_all</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv413nvs_erase_all12nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სახელთა სივრცეში ყველა გასაღები-მნიშვნელობის წყვილის წაშლა. </p>
<p>გაითვალისწინეთ, რომ ფაქტობრივი მეხსიერება შეიძლება არ განახლდეს nvs_commit ფუნქციის გამოძახებამდე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ წაშლის ოპერაცია წარმატებული იყო</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>ESP_ERR_NVS_READ_ONLY თუ სახელური გახსნილი იყო მხოლოდ წასაკითხად</li>
<li>სხვა შეცდომის კოდები ძირითადი შენახვის დრაივერიდან </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: შენახვის სახელური მიღებულია nvs_open-ით. მხოლოდ წასაკითხად გახსნილი სახელურების გამოყენება შეუძლებელია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv410nvs_commit12nvs_handle_t">
<span id="_CPPv310nvs_commit12nvs_handle_t"></span><span id="_CPPv210nvs_commit12nvs_handle_t"></span><span id="nvs_commit__nvs_handle_t"></span><span class="target" id="nvs_8h_1a88e2da69bd240354fdc0be908a933ca1"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_commit</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_commit12nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩაწერეთ არასტაბილურ მეხსიერებაში შეტანილი ნებისმიერი ცვლილება. </p>
<p>ნებისმიერი მნიშვნელობის დაყენების შემდეგ, ცვლილებების არამდგრად მეხსიერებაში ჩაწერის უზრუნველსაყოფად, უნდა გამოიძახოს nvs_commit(). ცალკეული იმპლემენტაციები შეიძლება სხვა დროსაც ჩაწერონ მეხსიერებაში, მაგრამ ეს გარანტირებული არ არის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ ცვლილებები წარმატებით ჩაიწერა</li>
<li>ESP_ERR_NVS_INVALID_HANDLE თუ სახელური დახურულია ან NULL-ია</li>
<li>სხვა შეცდომის კოდები ძირითადი შენახვის დრაივერიდან </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: შენახვის სახელური მიღებულია nvs_open-ით. მხოლოდ წასაკითხად გახსნილი სახელურების გამოყენება შეუძლებელია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv49nvs_close12nvs_handle_t">
<span id="_CPPv39nvs_close12nvs_handle_t"></span><span id="_CPPv29nvs_close12nvs_handle_t"></span><span id="nvs_close__nvs_handle_t"></span><span class="target" id="nvs_8h_1a67e6e6b8ba9a43fc08ca9a9609905c8d"></span>void <code class="descname">nvs_close</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv49nvs_close12nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დახურეთ საცავის სახელური და გაათავისუფლეთ ნებისმიერი გამოყოფილი რესურსი. </p>
<p>ეს ფუნქცია უნდა გამოიძახოს nvs_open-ით გახსნილი თითოეული სახელურისთვის, მას შემდეგ, რაც სახელური აღარ იქნება გამოყენებული. სახელურის დახურვამ შესაძლოა ავტომატურად არ ჩაიწეროს ცვლილებები არამდგრად მეხსიერებაში. ეს უნდა გაკეთდეს nvs_commit ფუნქციის გამოყენებით. როგორც კი ეს ფუნქცია გამოიძახება სახელურზე, სახელური აღარ უნდა იქნას გამოყენებული.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: შესანახი სახელური დასახურად </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv413nvs_get_statsPKcP11nvs_stats_t">
<span id="_CPPv313nvs_get_statsPKcP11nvs_stats_t"></span><span id="_CPPv213nvs_get_statsPKcP11nvs_stats_t"></span><span id="nvs_get_stats__cCP.nvs_stats_tP"></span><span class="target" id="nvs_8h_1a8fed09d46b77aa6dd0e8840959fe1933"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_stats</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>ნაწილის_სახელი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv411nvs_stats_t" title="nvs_stats_t">nvs_stats_t</a> *<em>nvs_stats</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv413nvs_get_statsPKcP11nvs_stats_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შევსების სტრუქტურა <a class="reference internal" href="nvs_flash.html#structnvs__stats__t"><span class="std std-ref">nvs_stats_t</span></a>ის გვაწვდის ინფორმაციას დანაყოფის მიერ გამოყენებული მეხსიერების შესახებ. </p>
<p>ეს ფუნქცია შესრულების დროს ითვლის გამოყენებული ჩანაწერების რაოდენობას, თავისუფალ ჩანაწერებს, ჩანაწერების საერთო რაოდენობას და დანაყოფში სახელთა სივრცის რაოდენობას.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">nvs_get_stats</span><span class="p">()</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">used</span> <span class="n">entries</span> <span class="ow">and</span> <span class="n">free</span> <span class="n">entries</span><span class="p">:</span>
<span class="n">nvs_stats_t</span> <span class="n">nvs_stats</span><span class="p">;</span>
<span class="n">nvs_get_stats</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvs_stats</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s2">"Count: UsedEntries = (</span><span class="si">%d</span><span class="s2">), FreeEntries = (</span><span class="si">%d</span><span class="s2">), AllEntries = (</span><span class="si">%d</span><span class="s2">)</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span>
       <span class="n">nvs_stats</span><span class="o">.</span><span class="n">used_entries</span><span class="p">,</span> <span class="n">nvs_stats</span><span class="o">.</span><span class="n">free_entries</span><span class="p">,</span> <span class="n">nvs_stats</span><span class="o">.</span><span class="n">total_entries</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>თუ ცვლილებები წარმატებით ჩაიწერა, დააჭირეთ ESP_OK. დაბრუნებული პარამეტრი nvs_stats შეივსება.</li>
<li>ESP_ERR_NVS_PART_NOT_FOUND, თუ დანაყოფი „სახელით“ ვერ მოიძებნა. დაბრუნებული პარამეტრი nvs_stats შეივსება 0-ით.</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED, თუ მეხსიერების დრაივერი არ არის ინიციალიზებული. დაბრუნებული პარამეტრი nvs_stats შეივსება 0-ით.</li>
<li>ESP_ERR_INVALID_ARG, თუ nvs_stats უდრის NULL-ს.</li>
<li>ESP_ERR_INVALID_STATE, თუ არსებობს გვერდი INVALID სტატუსით. დაბრუნებული პარამეტრი nvs_stats შეივსება არასწორი მნიშვნელობებით, რადგან ყველა გვერდი არ დაითვლება. დათვლა შეწყდება პირველივე INVALID გვერდზე. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: დანაყოფის სახელი NVS დანაყოფების ცხრილი ში. თუ NULL მნიშვნელობას გადაეცემა, მაშინ გამოყენებული იქნება NVS_DEFAULT_PART_NAME („nvs“).</li>
<li><code class="docutils literal notranslate"><span class="pre">nvs_stats</span></code>: აბრუნებს შევსებულ სტრუქტურას nvs_states_t. ის გვაწვდის ინფორმაციას დანაყოფში გამოყენებული მეხსიერების შესახებ.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t">
<span id="_CPPv324nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="_CPPv224nvs_get_used_entry_count12nvs_handle_tP6size_t"></span><span id="nvs_get_used_entry_count__nvs_handle_t.sP"></span><span class="target" id="nvs_8h_1ae6b52d96c1dcfc9d4b2ef987503955f0"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">nvs_get_used_entry_count</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <em>სახელური</em>, size_t *<em>გამოყენებული_ჩანაწერები</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv424nvs_get_used_entry_count12nvs_handle_tP6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოთვალეთ სახელთა სივრცეში არსებული ყველა ჩანაწერი. </p>
<p>გაითვალისწინეთ, რომ სახელთა სივრცის მიერ დაკავებული ჩანაწერების საერთო რაოდენობის გასარკვევად, დაბრუნებულ მნიშვნელობას used_entries დაუმატეთ ერთი (თუ err უდრის ESP_OK-ს). რადგან სახელთა სივრცის ჩანაწერი ერთ ჩანაწერს იღებს.</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">nvs_get_used_entry_count</span><span class="p">()</span> <span class="n">to</span> <span class="n">get</span> <span class="n">amount</span> <span class="n">of</span> <span class="nb">all</span> <span class="n">key</span><span class="o">-</span><span class="n">value</span> <span class="n">pairs</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">namespace</span><span class="p">:</span>
<span class="n">nvs_handle_t</span> <span class="n">handle</span><span class="p">;</span>
<span class="n">nvs_open</span><span class="p">(</span><span class="s2">"namespace1"</span><span class="p">,</span> <span class="n">NVS_READWRITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
<span class="o">...</span>
<span class="n">size_t</span> <span class="n">used_entries</span><span class="p">;</span>
<span class="n">size_t</span> <span class="n">total_entries_namespace</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">nvs_get_used_entry_count</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">used_entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">ESP_OK</span><span class="p">){</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">records</span> <span class="n">occupied</span> <span class="n">by</span> <span class="n">the</span> <span class="n">namespace</span>
    <span class="n">total_entries_namespace</span> <span class="o">=</span> <span class="n">used_entries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK, თუ ცვლილებები წარმატებით ჩაიწერა. დაბრუნებული პარამეტრი used_entries შეივსება ვალიდური მნიშვნელობით.</li>
<li>ESP_ERR_NVS_NOT_INITIALIZED, თუ მეხსიერების დრაივერი არ არის ინიციალიზებული. დაბრუნებული პარამეტრი used_entries შეივსება 0-ით.</li>
<li>ESP_ERR_NVS_INVALID_HANDLE, თუ სახელური დახურულია ან არის NULL. დაბრუნებული პარამეტრი used_entries შეივსება 0-ით.</li>
<li>ESP_ERR_INVALID_ARG, თუ used_entries უდრის NULL-ს.</li>
<li>სხვა შეცდომის კოდები ძირითადი მეხსიერების დრაივერიდან. დაბრუნებული პარამეტრი used_entries შეივსება 0-ით. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: nvs_open ფუნქციიდან მიღებული სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">used_entries</span></code>: აბრუნებს სახელთა სივრციდან გამოყენებული ჩანაწერების რაოდენობას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414nvs_entry_findPKcPKc10nvs_type_t">
<span id="_CPPv314nvs_entry_findPKcPKc10nvs_type_t"></span><span id="_CPPv214nvs_entry_findPKcPKc10nvs_type_t"></span><span id="nvs_entry_find__cCP.cCP.nvs_type_t"></span><span class="target" id="nvs_8h_1a0cf723ae4ccbe18d6a5d0e7b7b132990"></span><a class="reference internal" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <code class="descname">nvs_entry_find</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em>ნაწილის_სახელი</em>, <em class="property">კონსტ</em> char *<em>სახელთა სივრცის_სახელი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv410nvs_type_t" title="nvs_type_t">nvs_type_t</a> <em>ტიპი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv414nvs_entry_findPKcPKc10nvs_type_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით იტერატორი NVS ჩანაწერების ერთი ან მეტი პარამეტრის მიხედვით ჩამოსათვლელად. </p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Example</span> <span class="n">of</span> <span class="n">listing</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">key</span><span class="o">-</span><span class="n">value</span> <span class="n">pairs</span> <span class="n">of</span> <span class="nb">any</span> <span class="nb">type</span> <span class="n">under</span> <span class="n">specified</span> <span class="n">partition</span> <span class="ow">and</span> <span class="n">namespace</span>
<span class="n">nvs_iterator_t</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nvs_entry_find</span><span class="p">(</span><span class="n">partition</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">NVS_TYPE_ANY</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nvs_entry_info_t</span> <span class="n">info</span><span class="p">;</span>
        <span class="n">nvs_entry_info</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">nvs_entry_next</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">"key '</span><span class="si">%s</span><span class="s2">', type '</span><span class="si">%d</span><span class="s2">' </span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">info</span><span class="o">.</span><span class="n">type</span><span class="p">);</span>
<span class="p">};</span>
<span class="o">//</span> <span class="n">Note</span><span class="p">:</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">release</span> <span class="n">iterator</span> <span class="n">obtained</span> <span class="kn">from</span> <span class="nn">nvs_entry_find</span> <span class="n">function</span> <span class="n">when</span>
<span class="o">//</span>       <span class="n">nvs_entry_find</span> <span class="ow">or</span> <span class="n">nvs_entry_next</span> <span class="n">function</span> <span class="k">return</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">indicating</span> <span class="n">no</span> <span class="n">other</span>
<span class="o">//</span>       <span class="n">element</span> <span class="k">for</span> <span class="n">specified</span> <span class="n">criteria</span> <span class="n">was</span> <span class="n">found</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Iterator used to enumerate all the entries found, or NULL if no entry satisfying criteria was found. Iterator obtained through this function has to be released using nvs_release_iterator when not used any more. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">part_name</span></code>: დანაყოფის სახელი</li>
<li><code class="docutils literal notranslate"><span class="pre">namespace_name</span></code>დააყენეთ ეს მნიშვნელობა, თუ ეძებთ ჩანაწერებს კონკრეტული სახელთა სივრცით. სხვა შემთხვევაში გამოიყენეთ NULL.</li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: nvs_type_t მნიშვნელობებიდან ერთ-ერთი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414nvs_entry_next14nvs_iterator_t">
<span id="_CPPv314nvs_entry_next14nvs_iterator_t"></span><span id="_CPPv214nvs_entry_next14nvs_iterator_t"></span><span id="nvs_entry_next__nvs_iterator_t"></span><span class="target" id="nvs_8h_1a2862fd9de99c7e5b6947d2e5706a194b"></span><a class="reference internal" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <code class="descname">nvs_entry_next</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>იტერატორი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv414nvs_entry_next14nvs_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს შემდეგ ელემენტს, რომელიც შეესაბამება იტერატორის კრიტერიუმებს, NULL-ს, თუ ასეთი ელემენტი არ არსებობს. </p>
<p>გაითვალისწინეთ, რომ ამ გამოძახების შემდეგ იტერატორის ნებისმიერი ასლი არასწორი იქნება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>NULL if no entry was found, valid nvs_iterator_t otherwise. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: იტერატორი მიღებულია nvs_entry_find ფუნქციიდან. არ უნდა იყოს NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t">
<span id="_CPPv314nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t"></span><span id="_CPPv214nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t"></span><span id="nvs_entry_info__nvs_iterator_t.nvs_entry_info_tP"></span><span class="target" id="nvs_8h_1ae2c17aa8c05f476c47bf3c4b9ebba6b0"></span>void <code class="descname">nvs_entry_info</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>იტერატორი</em>, <a class="reference internal" href="nvs_flash.html#_CPPv416nvs_entry_info_t" title="nvs_entry_info_t">nvs_entry_info_t</a> *<em>out_info</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv414nvs_entry_info14nvs_iterator_tP16nvs_entry_info_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ავსებს <a class="reference internal" href="nvs_flash.html#structnvs__entry__info__t"><span class="std std-ref">nvs_entry_info_t</span></a> სტრუქტურა, რომელიც შეიცავს ინფორმაციას იტერატორის მიერ მითითებული შესვლის შესახებ. </p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: იტერატორი მიღებულია nvs_entry_find ან nvs_entry_next ფუნქციიდან. არ უნდა იყოს NULL.</li>
<li><code class="docutils literal notranslate"><span class="pre">out_info</span></code>სტრუქტურა, რომელშიც კოპირდება ჩანაწერის ინფორმაცია. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420nvs_release_iterator14nvs_iterator_t">
<span id="_CPPv320nvs_release_iterator14nvs_iterator_t"></span><span id="_CPPv220nvs_release_iterator14nvs_iterator_t"></span><span id="nvs_release_iterator__nvs_iterator_t"></span><span class="target" id="nvs_8h_1a33eceb70a1cc57c2fe2bae30a76f819a"></span>void <code class="descname">nvs_release_iterator</code><span class="sig-paren">(</span><a class="reference internal" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="nvs_iterator_t">nvs_iterator_t</a> <em>იტერატორი</em><span class="sig-paren">)</span><a class="headerlink" href="nvs_flash.html#_CPPv420nvs_release_iterator14nvs_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოშვების იტერატორი. </p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">iterator</span></code>: გამოშვების იტერატორი მიღებულია nvs_entry_find ფუნქციიდან. დაშვებულია NULL არგუმენტი. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id7">
<h3>სტრუქტურები<a class="headerlink" href="nvs_flash.html#id7" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv416nvs_entry_info_t">
<span id="_CPPv316nvs_entry_info_t"></span><span id="_CPPv216nvs_entry_info_t"></span><span id="nvs_entry_info_t"></span><span class="target" id="structnvs__entry__info__t"></span><em class="property">სტრუქტურა </em><code class="descname">nvs_entry_info_t</code><a class="headerlink" href="nvs_flash.html#_CPPv416nvs_entry_info_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ინფორმაცია ჩანაწერის შესახებ, მიღებული nvs_entry_info ფუნქციიდან </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t14namespace_nameE">
<span id="_CPPv3N16nvs_entry_info_t14namespace_nameE"></span><span id="_CPPv2N16nvs_entry_info_t14namespace_nameE"></span><span id="nvs_entry_info_t::namespace_name__cA"></span><span class="target" id="structnvs__entry__info__t_1a03a06d6db4f237eee102381a0b8a3003"></span>char <code class="descname">namespace_name</code>[16]<a class="headerlink" href="nvs_flash.html#_CPPv4N16nvs_entry_info_t14namespace_nameE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სახელთა სივრცე, რომელსაც ეკუთვნის გასაღები-მნიშვნელობა </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t3keyE">
<span id="_CPPv3N16nvs_entry_info_t3keyE"></span><span id="_CPPv2N16nvs_entry_info_t3keyE"></span><span id="nvs_entry_info_t::key__cA"></span><span class="target" id="structnvs__entry__info__t_1a6b4bfc6c2fd04f1507a3a1428e8019e3"></span>char <code class="descname">key</code>[16]<a class="headerlink" href="nvs_flash.html#_CPPv4N16nvs_entry_info_t3keyE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შენახული გასაღები-მნიშვნელობის წყვილის გასაღები </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N16nvs_entry_info_t4typeE">
<span id="_CPPv3N16nvs_entry_info_t4typeE"></span><span id="_CPPv2N16nvs_entry_info_t4typeE"></span><span id="nvs_entry_info_t::type__nvs_type_t"></span><span class="target" id="structnvs__entry__info__t_1ad9cd8f3eb0f354e9f1074586bc7580dd"></span><a class="reference internal" href="nvs_flash.html#_CPPv410nvs_type_t" title="nvs_type_t">nvs_type_t</a> <code class="descname">type</code><a class="headerlink" href="nvs_flash.html#_CPPv4N16nvs_entry_info_t4typeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შენახული გასაღები-მნიშვნელობის წყვილის ტიპი </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv411nvs_stats_t">
<span id="_CPPv311nvs_stats_t"></span><span id="_CPPv211nvs_stats_t"></span><span id="nvs_stats_t"></span><span class="target" id="structnvs__stats__t"></span><em class="property">სტრუქტურა </em><code class="descname">nvs_stats_t</code><a class="headerlink" href="nvs_flash.html#_CPPv411nvs_stats_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Info about storage space NVS. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N11nvs_stats_t12used_entriesE">
<span id="_CPPv3N11nvs_stats_t12used_entriesE"></span><span id="_CPPv2N11nvs_stats_t12used_entriesE"></span><span id="nvs_stats_t::used_entries__s"></span><span class="target" id="structnvs__stats__t_1a984ca538c8d5ed3657e79a61ae32290d"></span>size_t <code class="descname">used_entries</code><a class="headerlink" href="nvs_flash.html#_CPPv4N11nvs_stats_t12used_entriesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყენებული ჩანაწერების რაოდენობა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11nvs_stats_t12free_entriesE">
<span id="_CPPv3N11nvs_stats_t12free_entriesE"></span><span id="_CPPv2N11nvs_stats_t12free_entriesE"></span><span id="nvs_stats_t::free_entries__s"></span><span class="target" id="structnvs__stats__t_1aabe96c61ba4d7e45986ade7662dd2976"></span>size_t <code class="descname">free_entries</code><a class="headerlink" href="nvs_flash.html#_CPPv4N11nvs_stats_t12free_entriesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უფასო ჩანაწერების რაოდენობა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11nvs_stats_t13total_entriesE">
<span id="_CPPv3N11nvs_stats_t13total_entriesE"></span><span id="_CPPv2N11nvs_stats_t13total_entriesE"></span><span id="nvs_stats_t::total_entries__s"></span><span class="target" id="structnvs__stats__t_1aefc55846fa9a1c4b66002dc2064cb6f8"></span>size_t <code class="descname">total_entries</code><a class="headerlink" href="nvs_flash.html#_CPPv4N11nvs_stats_t13total_entriesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ყველა ხელმისაწვდომი ჩანაწერის რაოდენობა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N11nvs_stats_t15namespace_countE">
<span id="_CPPv3N11nvs_stats_t15namespace_countE"></span><span id="_CPPv2N11nvs_stats_t15namespace_countE"></span><span id="nvs_stats_t::namespace_count__s"></span><span class="target" id="structnvs__stats__t_1ada57627fb643fd0ca4bda5110f47faa6"></span>size_t <code class="descname">namespace_count</code><a class="headerlink" href="nvs_flash.html#_CPPv4N11nvs_stats_t15namespace_countE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>თანხის სახელწოდების სივრცე. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id8">
<h3>მაკროები<a class="headerlink" href="nvs_flash.html#id8" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_BASE">
<span class="target" id="nvs_8h_1a6ebf3d06cf50a876d6702b293e909d8b"></span><code class="descname">ESP_ERR_NVS_BASE</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_BASE" title="Permalink to this definition">¶</a></dt>
<dd><p>შეცდომის კოდების საწყისი რაოდენობა </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1ad943a82bd363a027c66c0a96be0d18c1"></span><code class="descname">ESP_ERR_NVS_NOT_INITIALIZED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_NOT_INITIALIZED" title="Permalink to this definition">¶</a></dt>
<dd><p>შენახვის დრაივერი არ არის ინიციალიზებული </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_FOUND">
<span class="target" id="nvs_8h_1a082e1ba076150e1c74f78bedf51f33d3"></span><code class="descname">ESP_ERR_NVS_NOT_FOUND</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>ID სახელთა სივრცე ჯერ არ არსებობს და რეჟიმი არის NVS_READONLY </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_TYPE_MISMATCH">
<span class="target" id="nvs_8h_1a879189233ef6af91693744b61315b8b0"></span><code class="descname">ESP_ERR_NVS_TYPE_MISMATCH</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_TYPE_MISMATCH" title="Permalink to this definition">¶</a></dt>
<dd><p>set ან get ოპერაციის ტიპი არ ემთხვევა NVS-ში შენახული მნიშვნელობის ტიპს. </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_READ_ONLY">
<span class="target" id="nvs_8h_1a0375ec3f706dae978eec4e5ea4b63595"></span><code class="descname">ESP_ERR_NVS_READ_ONLY</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_READ_ONLY" title="Permalink to this definition">¶</a></dt>
<dd><p>შენახვის სახელური გაიხსნა მხოლოდ წასაკითხად </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_NOT_ENOUGH_SPACE">
<span class="target" id="nvs_8h_1a749dd12cecf7a713767e02d82a691438"></span><code class="descname">ESP_ERR_NVS_NOT_ENOUGH_SPACE</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_NOT_ENOUGH_SPACE" title="Permalink to this definition">¶</a></dt>
<dd><p>ძირითად საცავში მნიშვნელობის შესანახად საკმარისი ადგილი არ არის </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_NAME">
<span class="target" id="nvs_8h_1a1bd03eb2ed14371d21bad10191296603"></span><code class="descname">ESP_ERR_NVS_INVALID_NAME</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_INVALID_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>სახელთა სივრცის სახელი არ აკმაყოფილებს შეზღუდვებს </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_HANDLE">
<span class="target" id="nvs_8h_1a5f8311ac86b9c5148a5a462ed807bb9c"></span><code class="descname">ESP_ERR_NVS_INVALID_HANDLE</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_INVALID_HANDLE" title="Permalink to this definition">¶</a></dt>
<dd><p>სახელური დახურულია ან NULL-ია </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_REMOVE_FAILED">
<span class="target" id="nvs_8h_1a6e2dd398a871449dacf60f7291f23033"></span><code class="descname">ESP_ERR_NVS_REMOVE_FAILED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_REMOVE_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>მნიშვნელობა არ განახლდა, რადგან ფლეშ მეხსიერება ჩაწერის ოპერაცია ვერ შესრულდა. თუმცა, მნიშვნელობა ჩაიწერა და განახლება დასრულდება nvs-ის ხელახალი ინიციალიზაციის შემდეგ, იმ პირობით, რომ ფლეშ მეხსიერება ოპერაცია ხელახლა არ შესრულდება. </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_KEY_TOO_LONG">
<span class="target" id="nvs_8h_1a43e34b6c49c7aa954db4f04fc41e3296"></span><code class="descname">ESP_ERR_NVS_KEY_TOO_LONG</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_KEY_TOO_LONG" title="Permalink to this definition">¶</a></dt>
<dd><p>გასაღების სახელი ძალიან გრძელია </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_PAGE_FULL">
<span class="target" id="nvs_8h_1a48b4105cbb5e8ddde83619b4ab88daa5"></span><code class="descname">ESP_ERR_NVS_PAGE_FULL</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_PAGE_FULL" title="Permalink to this definition">¶</a></dt>
<dd><p>შიდა შეცდომა; nvs API ფუნქციები არასდროს აბრუნებენ </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_STATE">
<span class="target" id="nvs_8h_1a0a66474f77e59dd4e9d0f92402c71a08"></span><code class="descname">ESP_ERR_NVS_INVALID_STATE</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_INVALID_STATE" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS წინა შეცდომის გამო არათანმიმდევრულ მდგომარეობაშია. ხელახლა გამოიძახეთ nvs_ ფლეშ მეხსიერება _init და nvs_open, შემდეგ სცადეთ ხელახლა. </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_INVALID_LENGTH">
<span class="target" id="nvs_8h_1a8fe5478e998fcb6ba2504fad13563695"></span><code class="descname">ESP_ERR_NVS_INVALID_LENGTH</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_INVALID_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd><p>სტრიქონის ან blob-ის სიგრძე მონაცემების შესანახად საკმარისი არ არის </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_NO_FREE_PAGES">
<span class="target" id="nvs_8h_1a0db9bc5030273dc8443de06de2bdf166"></span><code class="descname">ESP_ERR_NVS_NO_FREE_PAGES</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_NO_FREE_PAGES" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS დანაყოფი არ შეიცავს ცარიელ გვერდებს. ეს შეიძლება მოხდეს, თუ NVS დანაყოფი შემოკლებულია. წაშალეთ მთელი დანაყოფი და ხელახლა გამოიძახეთ nvs_ ფლეშ მეხსიერება _init. </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_VALUE_TOO_LONG">
<span class="target" id="nvs_8h_1a069270375766125d42cd881d17e0caac"></span><code class="descname">ESP_ERR_NVS_VALUE_TOO_LONG</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_VALUE_TOO_LONG" title="Permalink to this definition">¶</a></dt>
<dd><p>სტრიქონის ან blob-ის სიგრძე იმპლემენტაციის მიერ მხარდაჭერილზე მეტია </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_PART_NOT_FOUND">
<span class="target" id="nvs_8h_1ab5c583c77736f31153212fc24e9ad428"></span><code class="descname">ESP_ERR_NVS_PART_NOT_FOUND</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_PART_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>მითითებული სახელის მქონე დანაყოფი დანაყოფების ცხრილი ში არ არის ნაპოვნი </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_NEW_VERSION_FOUND">
<span class="target" id="nvs_8h_1a719036fc53adfba75a722bc3b2c8088d"></span><code class="descname">ESP_ERR_NVS_NEW_VERSION_FOUND</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_NEW_VERSION_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS დანაყოფი შეიცავს მონაცემებს ახალი ფორმატით და კოდის ამ ვერსიით მისი ამოცნობა შეუძლებელია. </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_ENCR_FAILED">
<span class="target" id="nvs_8h_1a8d6a9ee18ef709bfb31b5b0876fdb4e2"></span><code class="descname">ESP_ERR_NVS_XTS_ENCR_FAILED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_XTS_ENCR_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS ჩანაწერის ჩაწერისას XTS დაშიფვრა ვერ მოხერხდა </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_DECR_FAILED">
<span class="target" id="nvs_8h_1a3b7991e1ece6f0a068188ff0e6446646"></span><code class="descname">ESP_ERR_NVS_XTS_DECR_FAILED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_XTS_DECR_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS გაშიფვრა ვერ მოხერხდა NVS ჩანაწერის წაკითხვისას </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_CFG_FAILED">
<span class="target" id="nvs_8h_1a4304c1cc1a58723ba7e8cd52a3240fad"></span><code class="descname">ESP_ERR_NVS_XTS_CFG_FAILED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_XTS_CFG_FAILED" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS კონფიგურაციის დაყენება ვერ მოხერხდა </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND">
<span class="target" id="nvs_8h_1a5ed7fdfd6c8d769f7148d7553b97f004"></span><code class="descname">ESP_ERR_NVS_XTS_CFG_NOT_FOUND</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_XTS_CFG_NOT_FOUND" title="Permalink to this definition">¶</a></dt>
<dd><p>XTS კონფიგურაცია ვერ მოიძებნა </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED">
<span class="target" id="nvs_8h_1a680919934f73044eef6d5a7d235d6bc5"></span><code class="descname">ESP_ERR_NVS_ENCR_NOT_SUPPORTED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_ENCR_NOT_SUPPORTED" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS დაშიფვრა ამ ვერსიაში არ არის მხარდაჭერილი </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED">
<span class="target" id="nvs_8h_1a222febdb2697ebcd48f673582de503f7"></span><code class="descname">ESP_ERR_NVS_KEYS_NOT_INITIALIZED</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_KEYS_NOT_INITIALIZED" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS გასაღების დანაყოფი არ არის ინიციალიზებული </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_CORRUPT_KEY_PART">
<span class="target" id="nvs_8h_1ae0a1f13593d08f82d3e36f34838cb003"></span><code class="descname">ESP_ERR_NVS_CORRUPT_KEY_PART</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_CORRUPT_KEY_PART" title="Permalink to this definition">¶</a></dt>
<dd><p>NVS გასაღების დანაყოფი დაზიანებულია </p>
</dd></dl>
<dl class="macro">
<dt id="c.ESP_ERR_NVS_CONTENT_DIFFERS">
<span class="target" id="nvs_8h_1ada3575eb4ea5831fbb35ac564f0d49e6"></span><code class="descname">ESP_ERR_NVS_CONTENT_DIFFERS</code><a class="headerlink" href="nvs_flash.html#c.ESP_ERR_NVS_CONTENT_DIFFERS" title="Permalink to this definition">¶</a></dt>
<dd><p>შიდა შეცდომა; nvs API ფუნქციები არასდროს აბრუნებენ. NVS გასაღები განსხვავებულია შედარებით. </p>
</dd></dl>
<dl class="macro">
<dt id="c.NVS_DEFAULT_PART_NAME">
<span class="target" id="nvs_8h_1a4e567a079a04ef71a18d21de58bd9b5a"></span><code class="descname">NVS_DEFAULT_PART_NAME</code><a class="headerlink" href="nvs_flash.html#c.NVS_DEFAULT_PART_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>დანაყოფების ცხრილი ში NVS დანაყოფის ნაგულისხმევი დანაყოფის სახელი </p>
</dd></dl>
<dl class="macro">
<dt id="c.NVS_PART_NAME_MAX_SIZE">
<span class="target" id="nvs_8h_1a1db8c93ce4ae61d2900cd70ebb021e1d"></span><code class="descname">NVS_PART_NAME_MAX_SIZE</code><a class="headerlink" href="nvs_flash.html#c.NVS_PART_NAME_MAX_SIZE" title="Permalink to this definition">¶</a></dt>
<dd><p>დანაყოფის სახელის მაქსიმალური სიგრძე (ნულოვანი ტერმინატორის გარდა) </p>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="nvs_flash.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv412nvs_handle_t">
<span id="_CPPv312nvs_handle_t"></span><span id="_CPPv212nvs_handle_t"></span><span id="nvs_handle_t"></span><span class="target" id="nvs_8h_1a1d7beddf57b3313de191f91ba639f9aa"></span><em class="property">typedef </em>uint32_t <code class="descname">nvs_handle_t</code><a class="headerlink" href="nvs_flash.html#_CPPv412nvs_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაუმჭვირვალე მაჩვენებლის ტიპი, რომელიც წარმოადგენს არასტაბილური შენახვის სახელურს </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv410nvs_handle">
<span id="_CPPv310nvs_handle"></span><span id="_CPPv210nvs_handle"></span><span id="nvs_handle"></span><span class="target" id="nvs_8h_1a2f2c716f08f30da049ffd5f8e10c40ea"></span><em class="property">typedef </em><a class="reference internal" href="nvs_flash.html#_CPPv412nvs_handle_t" title="nvs_handle_t">nvs_handle_t</a> <code class="descname">nvs_handle</code><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_handle" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="type">
<dt id="_CPPv413nvs_open_mode">
<span id="_CPPv313nvs_open_mode"></span><span id="_CPPv213nvs_open_mode"></span><span id="nvs_open_mode"></span><span class="target" id="nvs_8h_1a58b11f9db94a9699f095102b1361e53f"></span><em class="property">typedef </em><a class="reference internal" href="nvs_flash.html#_CPPv415nvs_open_mode_t" title="nvs_open_mode_t">nvs_open_mode_t</a> <code class="descname">nvs_open_mode</code><a class="headerlink" href="nvs_flash.html#_CPPv413nvs_open_mode" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="type">
<dt id="_CPPv414nvs_iterator_t">
<span id="_CPPv314nvs_iterator_t"></span><span id="_CPPv214nvs_iterator_t"></span><span id="nvs_iterator_t"></span><span class="target" id="nvs_8h_1addeca2dd4bededba2c1c5aac2dfd5cbf"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> nvs_opaque_iterator_t *<code class="descname">nvs_iterator_t</code><a class="headerlink" href="nvs_flash.html#_CPPv414nvs_iterator_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაუმჭვირვალე მაჩვენებლის ტიპი, რომელიც წარმოადგენს იტერატორს nvs ჩანაწერებში </p>
</dd></dl>
</div>
<div class="section" id="enumerations">
<h3>ჩამოთვლები<a class="headerlink" href="nvs_flash.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv415nvs_open_mode_t">
<span id="_CPPv315nvs_open_mode_t"></span><span id="_CPPv215nvs_open_mode_t"></span><span id="nvs_open_mode_t"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793"></span><em class="property">ჩამოთვლა </em><code class="descname">nvs_open_mode_t</code><a class="headerlink" href="nvs_flash.html#_CPPv415nvs_open_mode_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>არასტაბილური საცავის გახსნის რეჟიმი. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv412NVS_READONLY">
<span id="_CPPv312NVS_READONLY"></span><span id="_CPPv212NVS_READONLY"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793adcb7dd95b10700e8855315dd2a88c02d"></span><code class="descname">NVS_READONLY</code><a class="headerlink" href="nvs_flash.html#_CPPv412NVS_READONLY" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მხოლოდ წაკითხვა </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv413NVS_READWRITE">
<span id="_CPPv313NVS_READWRITE"></span><span id="_CPPv213NVS_READWRITE"></span><span class="target" id="nvs_8h_1a017e1932838b044b88f875edf56e3793afd73ea5fe0b78c36af2a47b3bb788d7b"></span><code class="descname">NVS_READWRITE</code><a class="headerlink" href="nvs_flash.html#_CPPv413NVS_READWRITE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაკითხვა და წერა </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv410nvs_type_t">
<span id="_CPPv310nvs_type_t"></span><span id="_CPPv210nvs_type_t"></span><span id="nvs_type_t"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19"></span><em class="property">ჩამოთვლა </em><code class="descname">nvs_type_t</code><a class="headerlink" href="nvs_flash.html#_CPPv410nvs_type_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ცვლადების ტიპები. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv411NVS_TYPE_U8">
<span id="_CPPv311NVS_TYPE_U8"></span><span id="_CPPv211NVS_TYPE_U8"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0bf45d256ba3969cfa47d938da79a610"></span><code class="descname">NVS_TYPE_U8</code> = 0x01<a class="headerlink" href="nvs_flash.html#_CPPv411NVS_TYPE_U8" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტიპი uint8_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv411NVS_TYPE_I8">
<span id="_CPPv311NVS_TYPE_I8"></span><span id="_CPPv211NVS_TYPE_I8"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a5b774222e037fe8762a52c10165b0cf7"></span><code class="descname">NVS_TYPE_I8</code> = 0x11<a class="headerlink" href="nvs_flash.html#_CPPv411NVS_TYPE_I8" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აკრიფეთ int8_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U16">
<span id="_CPPv312NVS_TYPE_U16"></span><span id="_CPPv212NVS_TYPE_U16"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19af57a753522c97be5ca3dbfd4d90ee0a2"></span><code class="descname">NVS_TYPE_U16</code> = 0x02<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_U16" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტიპი uint16_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I16">
<span id="_CPPv312NVS_TYPE_I16"></span><span id="_CPPv212NVS_TYPE_I16"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19acbb42175aac1f46510597c52f7eadf67"></span><code class="descname">NVS_TYPE_I16</code> = 0x12<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_I16" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აკრიფეთ int16_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U32">
<span id="_CPPv312NVS_TYPE_U32"></span><span id="_CPPv212NVS_TYPE_U32"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ae3f5df4fc9c206ab0a4311c40bcb07fd"></span><code class="descname">NVS_TYPE_U32</code> = 0x04<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_U32" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტიპი uint32_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I32">
<span id="_CPPv312NVS_TYPE_I32"></span><span id="_CPPv212NVS_TYPE_I32"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a03285d076b980e0a1d125ea9150ed552"></span><code class="descname">NVS_TYPE_I32</code> = 0x14<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_I32" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აკრიფეთ int32_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_U64">
<span id="_CPPv312NVS_TYPE_U64"></span><span id="_CPPv212NVS_TYPE_U64"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a0b95e503d55dbf29342ac491d7e66956"></span><code class="descname">NVS_TYPE_U64</code> = 0x08<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_U64" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტიპი uint64_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_I64">
<span id="_CPPv312NVS_TYPE_I64"></span><span id="_CPPv212NVS_TYPE_I64"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ad2a38ac131962fdb89d8407795ee44aa"></span><code class="descname">NVS_TYPE_I64</code> = 0x18<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_I64" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აკრიფეთ int64_t </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_STR">
<span id="_CPPv312NVS_TYPE_STR"></span><span id="_CPPv212NVS_TYPE_STR"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a2d4edb61489d985af5b358634e81dacc"></span><code class="descname">NVS_TYPE_STR</code> = 0x21<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_STR" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აკრიფეთ სტრიქონი </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv413NVS_TYPE_BLOB">
<span id="_CPPv313NVS_TYPE_BLOB"></span><span id="_CPPv213NVS_TYPE_BLOB"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19ada2916eec53ebf6fd7b00de6b9037c16"></span><code class="descname">NVS_TYPE_BLOB</code> = 0x42<a class="headerlink" href="nvs_flash.html#_CPPv413NVS_TYPE_BLOB" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტიპის ბლობი </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv412NVS_TYPE_ANY">
<span id="_CPPv312NVS_TYPE_ANY"></span><span id="_CPPv212NVS_TYPE_ANY"></span><span class="target" id="nvs_8h_1a7c9aab15285454ca16459ce4e3ebed19a3cec9452563a30fb500a17e77c3dc257"></span><code class="descname">NVS_TYPE_ANY</code> = 0xff<a class="headerlink" href="nvs_flash.html#_CPPv412NVS_TYPE_ANY" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ბოლო უნდა იყოს </p>
</dd></dl>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="nvs_partition_gen.html" rel="next" title="NVS Partition Generator Utility">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="mass_mfg.html" rel="prev" title="Manufacturing Utility"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>