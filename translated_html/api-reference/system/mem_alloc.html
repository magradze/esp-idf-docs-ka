
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>გროვის მეხსიერების განაწილება — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="heap_debug.html" rel="next" title="Heap Memory Debugging"/>
<link href="freertos_additions.html" rel="prev" title="FreeRTOS Additions"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/mem_alloc.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/system/mem_alloc"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/system/mem_alloc.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">შენახვა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">სისტემა</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">აპლიკაციის სურათის ფორმატი</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse მენეჯერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">შეცდომის კოდები და დამხმარე ფუნქციები</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_pthread.html">ESP pthread</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">მოვლენების ციკლის ბიბლიოთეკა</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">უფასო RTOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">უფასო RTOS დამატებები</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="mem_alloc.html#">გროვის მეხსიერების განაწილება</a><ul>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#stack-and-heap">დასტა და გროვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#memory-capabilities">მეხსიერების შესაძლებლობები</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#available-heap">ხელმისაწვდომი გროვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#special-capabilities">სპეციალური შესაძლებლობები</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#api-reference-heap-allocation">API მითითება - გროვის განაწილება</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#heap-tracing-debugging">გროვის ტრასირება და გამართვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#api-reference-initialisation">API მითითება - ინიციალიზაცია</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#implementation-notes">განხორციელების შენიშვნები</a></li>
<li class="toctree-l4"><a class="reference internal" href="mem_alloc.html#api-reference-multi-heap-api">API მითითება - მრავალჯერადი გროვა API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">გროვის მეხსიერების გამართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">მაღალი გარჩევადობის ტაიმერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem (დიდი გარე SPI ოპერატიული მეხსიერება) API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">პროცესორებს შორის ზარი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_expression_with_stack.html">ფუნქციის გამოძახება გარე სტეკით</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">შეწყვეტის განაწილება</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">ლოგირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="system.html">სხვადასხვა სისტემა, API წმ</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">უსადენო განახლებები (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">შესრულების მონიტორი</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">ენერგიის მართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">ძილის რეჟიმები</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">მეთვალყურე ძაღლები</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">სისტემის დრო</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">სისტემის API</a> »</li>
<li>გროვის მეხსიერების განაწილება</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/system/mem_alloc.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="heap-memory-allocation">
<h1>გროვის მეხსიერების განაწილება<a class="headerlink" href="mem_alloc.html#heap-memory-allocation" title="Permalink to this headline">¶</a></h1>
<div class="section" id="stack-and-heap">
<h2>დასტა და გროვა<a class="headerlink" href="mem_alloc.html#stack-and-heap" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF აპლიკაციები იყენებენ კომპიუტერული არქიტექტურის საერთო შაბლონებს <em>დასტა</em> (პროგრამის მართვის ნაკადის მიერ გამოყოფილი დინამიური მეხსიერება) და <em>გროვა</em> (ფუნქციური გამოძახებებით გამოყოფილი დინამიური მეხსიერება), ასევე სტატიკურად გამოყოფილი მეხსიერება (გამოყოფილი კომპილაცია დროს).</p>
<p>რადგან ESP-IDF მრავალძაფიანი RTOS გარემოა, თითოეულ RTOS დავალებას აქვს საკუთარი სტეკი. ნაგულისხმევად, ამ დასტებიდან თითოეული გამოიყოფა გროვიდან დავალების შექმნისას. (იხ. <a class="reference internal" href="freertos.html#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="xTaskCreateStatic"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">xTaskCreateStatic()</span></code></a> ალტერნატივისთვის, სადაც დასტები სტატიკურად არის განაწილებული.)</p>
<p>რადგან ESP32 იყენებს ოპერატიული მეხსიერების რამდენიმე ტიპს, ის ასევე შეიცავს სხვადასხვა შესაძლებლობების მქონე მრავალ გროვას. შესაძლებლობებზე დაფუძნებული მეხსიერების გამანაწილებელი აპლიკაციებს საშუალებას აძლევს, განახორციელონ გროვის განაწილება სხვადასხვა მიზნებისთვის.</p>
<p>უმეტესი მიზნებისთვის, სტანდარტული libc <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> და <code class="docutils literal notranslate"><span class="pre">free()</span></code> ფუნქციების გამოყენება გროვის განაწილებისთვის შესაძლებელია განსაკუთრებული განხილვის გარეშე.</p>
<p>თუმცა, მეხსიერების ყველა ტიპისა და მათი მახასიათებლების სრულად გამოსაყენებლად, ESP-IDF ასევე აქვს შესაძლებლობებზე დაფუძნებული გროვის მეხსიერების განაწილების ფუნქცია. თუ გსურთ გქონდეთ მეხსიერება გარკვეული თვისებებით (მაგალითად, <a class="reference internal" href="mem_alloc.html#dma-capable-memory"><span class="std std-ref">DMA-თავსებადი მეხსიერება</span></a> ან შესრულებადი მეხსიერება), შეგიძლიათ შექმნათ საჭირო შესაძლებლობების OR ნიღაბი და გადასცეთ ის <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a>.</p>
</div>
<div class="section" id="memory-capabilities">
<h2>მეხსიერების შესაძლებლობები<a class="headerlink" href="mem_alloc.html#memory-capabilities" title="Permalink to this headline">¶</a></h2>
<p>ESP32 შეიცავს ოპერატიული მეხსიერების რამდენიმე ტიპს:</p>
<ul class="simple">
<li>DRAM (მონაცემთა ოპერატიული მეხსიერება) არის მეხსიერება, რომელიც გამოიყენება მონაცემების შესანახად. ეს არის მეხსიერების ყველაზე გავრცელებული სახეობა, რომელსაც წვდომა აქვს გროვის სახით.</li>
<li>IRAM (ინსტრუქციის ოპერატიული მეხსიერება) ჩვეულებრივ მხოლოდ შესრულებად მონაცემებს ინახავს. თუ მასზე წვდომა ზოგადი მეხსიერების სახითაა, ყველა წვდომა უნდა იყოს <a class="reference internal" href="mem_alloc.html#bit-accessible-memory"><span class="std std-ref">32-ბიტიანი გასწორება</span></a>.</li>
<li>D/IRAM არის ოპერატიული მეხსიერება, რომლის გამოყენება შესაძლებელია როგორც ინსტრუქციის, ასევე მონაცემთა ოპერატიული მეხსიერების სახით.</li>
</ul>
<p>შიდა მეხსიერების ამ ტიპების შესახებ დამატებითი ინფორმაციისთვის იხილეთ <a class="reference internal" href="../../api-guides/general-notes.html#memory-layout"><span class="std std-ref">აპლიკაციის მეხსიერების განლაგება</span></a>.</p>
<p>ასევე შესაძლებელია გარე SPI ოპერატიული მეხსიერების ESP32-თან დაკავშირება - <a class="reference internal" href="../../api-guides/external-ram.html"><span class="doc">გარე ოპერატიული მეხსიერება</span></a> შესაძლებელია ESP32-ის მეხსიერების რუკაში ინტეგრირება ფლეშ მეხსიერება ქეშის გამოყენებით და მასზე წვდომა DRAM-ის მსგავსად.</p>
<p>DRAM იყენებს შესაძლებლობას <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_8BIT</span></code> (ხელმისაწვდომია ერთბაიტიანი წაკითხვისა და ჩაწერის რეჟიმში). გამოძახებისას <code class="docutils literal notranslate"><span class="pre">malloc()</span></code>, ESP-IDF <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> განხორციელების შიდა ზარები <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(size,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code> ბაიტ-მისამართირებადი DRAM-ის გამოსაყოფად. გაშვების დროს თავისუფალი DRAM-ის გროვის ზომის შესამოწმებლად, გამოიძახეთ cpp:func:<cite>heap_caps_get_free_size(MALLOC_CAP_8BIT)</cite>.</p>
<p>რადგან malloc იყენებს შესაძლებლობებზე დაფუძნებულ განაწილების სისტემას, მეხსიერება გამოყოფილია გამოყენებით <a class="reference internal" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="heap_caps_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">heap_caps_malloc()</span></code></a> შესაძლებელია გათავისუფლდეს სტანდარტის გამოძახებით <code class="docutils literal notranslate"><span class="pre">free()</span></code> ფუნქცია.</p>
</div>
<div class="section" id="available-heap">
<h2>ხელმისაწვდომი გროვა<a class="headerlink" href="mem_alloc.html#available-heap" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dram">
<h3>DRAM<a class="headerlink" href="mem_alloc.html#dram" title="Permalink to this headline">¶</a></h3>
<p>გაშვებისას, DRAM გროვა შეიცავს მთელ მონაცემთა მეხსიერებას, რომელიც აპლიკაციის მიერ სტატიკურად არ არის გამოყოფილი. სტატიკურად გამოყოფილი ბუფერების შემცირება გაზრდის თავისუფალი გროვის რაოდენობას.</p>
<p>სტატიკურად გამოყოფილი მეხსიერების რაოდენობის გასარკვევად, გამოიყენეთ <a class="reference internal" href="../../api-guides/build-system.html#idf-py-size"><span class="std std-ref">idf.py ზომა</span></a> ბრძანება.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ტექნიკური შეზღუდვის გამო, სტატიკურად გამოყოფილი DRAM-ის მაქსიმალური გამოყენება 160 კბ-ია. დარჩენილი 160 კბ (სულ 320 კბ DRAM) მხოლოდ გაშვების დროს შეიძლება გამოიყოს გროვის სახით.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">გაშვების დროს, ხელმისაწვდომი heap DRAM შეიძლება კომპილაცია დროს გამოთვლილზე ნაკლები იყოს, რადგან გაშვებისას Free RTOS დამგეგმავის გაშვებამდე გროვიდან გარკვეული მეხსიერება გამოიყოფა (მათ შორის საწყისი Free RTOS დავალებების დასტების მეხსიერება).</p>
</div>
</div>
<div class="section" id="iram">
<h3>ირამი<a class="headerlink" href="mem_alloc.html#iram" title="Permalink to this headline">¶</a></h3>
<p>გაშვებისას, IRAM გროვა შეიცავს ყველა ინსტრუქციის მეხსიერებას, რომელსაც არ იყენებს აპლიკაციის შესრულებადი კოდი.</p>
<p>ის <a class="reference internal" href="../../api-guides/build-system.html#idf-py-size"><span class="std std-ref">idf.py ზომა</span></a> ბრძანების გამოყენება შესაძლებელია აპლიკაციის მიერ გამოყენებული IRAM-ის რაოდენობის მოსაძებნად.</p>
</div>
<div class="section" id="d-iram">
<h3>D/IRAM<a class="headerlink" href="mem_alloc.html#d-iram" title="Permalink to this headline">¶</a></h3>
<p>ESP32-ში მეხსიერების გარკვეული ნაწილი ხელმისაწვდომია DRAM-ის ან IRAM-ის სახით. თუ მეხსიერება გამოყოფილია D/IRAM რეგიონიდან, ორივე ტიპის მეხსიერებისთვის თავისუფალი გროვის ზომა შემცირდება.</p>
</div>
<div class="section" id="heap-sizes">
<h3>გროვის ზომები<a class="headerlink" href="mem_alloc.html#heap-sizes" title="Permalink to this headline">¶</a></h3>
<p>გაშვებისას, ყველა ESP-IDF აპლიკაცია აღრიცხავს ყველა heap მისამართის (და ზომის) შეჯამებას Info დონეზე:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>I (252) heap_init: Initializing. RAM available for dynamic allocation:
I (259) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM
I (265) heap_init: At 3FFB2EC8 len 0002D138 (180 KiB): DRAM
I (272) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D/IRAM
I (278) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D/IRAM
I (284) heap_init: At 4008944C len 00016BB4 (90 KiB): IRAM
</pre></div>
</div>
</div>
<div class="section" id="finding-available-heap">
<h3>ხელმისაწვდომი გროვის პოვნა<a class="headerlink" href="mem_alloc.html#finding-available-heap" title="Permalink to this headline">¶</a></h3>
<p>იხილეთ <a class="reference internal" href="heap_debug.html#heap-information"><span class="std std-ref">გროვის ინფორმაცია</span></a>.</p>
</div>
</div>
<div class="section" id="special-capabilities">
<h2>სპეციალური შესაძლებლობები<a class="headerlink" href="mem_alloc.html#special-capabilities" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dma-capable-memory">
<span id="id1"></span><h3>DMA-თავსებადი მეხსიერება<a class="headerlink" href="mem_alloc.html#dma-capable-memory" title="Permalink to this headline">¶</a></h3>
<p>გამოიყენეთ <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_DMA</span></code> დროშა მეხსიერების გამოსაყოფად, რომელიც შესაფერისია აპარატურული DMA ძრავებისთვის (მაგალითად, SPI და I2S). ეს შესაძლებლობა გამორიცხავს ნებისმიერ გარე PSRAM-ს.</p>
</div>
<div class="section" id="bit-accessible-memory">
<span id="id2"></span><h3>32-ბიტიანი ხელმისაწვდომი მეხსიერება<a class="headerlink" href="mem_alloc.html#bit-accessible-memory" title="Permalink to this headline">¶</a></h3>
<p>თუ მეხსიერების გარკვეული სტრუქტურა მიმართულია მხოლოდ 32-ბიტიან ერთეულებში, მაგალითად, რიცხვების ან მაჩვენებლების მასივში, შეიძლება სასარგებლო იყოს მისი გამოყოფა შემდეგით: <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_32BIT</span></code> flag. ეს ასევე საშუალებას აძლევს ალოკატორს გასცეს IRAM მეხსიერება; რასაც მას არ შეუძლია ჩვეულებრივი malloc() გამოძახებისთვის. ეს შეიძლება დაეხმაროს ESP32-ში არსებული მთელი მეხსიერების გამოყენებას.</p>
<p>მეხსიერება გამოყოფილია <code class="docutils literal notranslate"><span class="pre">MALLOC_CAP_32BIT</span></code> ქილა <em>მხოლოდ</em> თუ წვდომა 32-ბიტიანი წაკითხვისა და ჩაწერის საშუალებით იქნება შესაძლებელი, ნებისმიერი სხვა ტიპის წვდომა გამოიწვევს LoadStoreError-ის ფატალურ გამონაკლისს.</p>
</div>
<div class="section" id="external-spi-memory">
<h3>გარე SPI მეხსიერება<a class="headerlink" href="mem_alloc.html#external-spi-memory" title="Permalink to this headline">¶</a></h3>
<p>როდესაც <a class="reference internal" href="../../api-guides/external-ram.html"><span class="doc">გარე ოპერატიული მეხსიერება</span></a> ჩართულია, 4 მბ-ზე ნაკლები ზომის გარე SPI ოპერატიული მეხსიერება შეიძლება გამოყოს სტანდარტული <code class="docutils literal notranslate"><span class="pre">malloc</span></code> ზარები, ან მეშვეობით <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(MALLOC_CAP_SPIRAM)</span></code>კონფიგურაციის მიხედვით. იხილეთ <a class="reference internal" href="../../api-guides/external-ram.html#external-ram-config"><span class="std std-ref">გარე ოპერატიული მეხსიერების კონფიგურაცია</span></a> დამატებითი დეტალებისთვის.</p>
<p>4 მბ ლიმიტის ზემოთ მდებარე რეგიონის გამოსაყენებლად, შეგიძლიათ გამოიყენოთ <a class="reference internal" href="himem.html"><span class="doc">ჰიემ API</span></a>.</p>
</div>
</div>
<div class="section" id="api-reference-heap-allocation">
<h2>API მითითება - გროვის განაწილება<a class="headerlink" href="mem_alloc.html#api-reference-heap-allocation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="mem_alloc.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/esp_heap_caps.h">heap/include/esp_heap_caps.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="mem_alloc.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv416heap_caps_malloc6size_t8uint32_t">
<span id="_CPPv316heap_caps_malloc6size_t8uint32_t"></span><span id="_CPPv216heap_caps_malloc6size_t8uint32_t"></span><span id="heap_caps_malloc__s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ab423ad98296288ff760c238e599b2669"></span>void *<code class="descname">heap_caps_malloc</code><span class="sig-paren">(</span>size_t <em>ზომა</em>, uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv416heap_caps_malloc6size_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყავით მეხსიერების ის ნაწილი, რომელსაც აქვს მოცემული შესაძლებლობები. </p>
<p>libc malloc()-ის ეკვივალენტური სემანტიკა, შესაძლებლობების გათვალისწინებით შექმნილი მეხსიერებისთვის.</p>
<p>IDF-ში, <code class="docutils literal notranslate"><span class="pre">malloc(p)</span></code> უდრის <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(p,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: გამოსაყოფი მეხსიერების ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* ფლაგების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ დასაბრუნებელი მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414heap_caps_freePv">
<span id="_CPPv314heap_caps_freePv"></span><span id="_CPPv214heap_caps_freePv"></span><span id="heap_caps_free__voidP"></span><span class="target" id="esp__heap__caps_8h_1aefb117b700d0577eaf80b02fedb41e39"></span>void <code class="descname">heap_caps_free</code><span class="sig-paren">(</span>void *<em>პტრ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv414heap_caps_freePv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>თავისუფალი მეხსიერება ადრე გამოყოფილი იყო heap_caps_malloc() ან heap_caps_realloc()-ის მეშვეობით. </p>
<p>libc free()-ის ეკვივალენტური სემანტიკა, შესაძლებლობების გათვალისწინებით შექმნილი მეხსიერებისთვის.</p>
<p>IDF-ში, <code class="docutils literal notranslate"><span class="pre">free(p)</span></code> უდრის <code class="docutils literal notranslate"><span class="pre">heap_caps_free(p)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: მეხსიერების მაჩვენებელი, რომელიც ადრე დაბრუნებული იყო heap_caps_malloc() ან heap_caps_realloc() ფუნქციებიდან. შეიძლება იყოს NULL. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417heap_caps_reallocPv6size_ti">
<span id="_CPPv317heap_caps_reallocPv6size_ti"></span><span id="_CPPv217heap_caps_reallocPv6size_ti"></span><span id="heap_caps_realloc__voidP.s.i"></span><span class="target" id="esp__heap__caps_8h_1ae9d230cd97014ae5e0e218bd477c94c2"></span>void *<code class="descname">heap_caps_realloc</code><span class="sig-paren">(</span>void *<em>პტრ</em>, size_t <em>ზომა</em>, int <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv417heap_caps_reallocPv6size_ti" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>heap_caps_malloc() ან heap_caps_realloc() მეშვეობით ადრე გამოყოფილი მეხსიერების ხელახლა განაწილება. </p>
<p>შესაძლებლობების გათვალისწინებით მეხსიერებისთვის, libc realloc()-ის ეკვივალენტური სემანტიკა.</p>
<p>IDF-ში, <code class="docutils literal notranslate"><span class="pre">realloc(p,</span> <span class="pre">s)</span></code> უდრის <code class="docutils literal notranslate"><span class="pre">heap_caps_realloc(p,</span> <span class="pre">s,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p>პარამეტრი „caps“ შეიძლება განსხვავდებოდეს იმ შესაძლებლობებისგან, რომლებიც ნებისმიერ ორიგინალ „ptr“-ს ჰქონდა გამოყოფილი. ამ გზით, realloc-ის გამოყენება შესაძლებელია ბუფერის „გადასაადგილებლად“, საჭიროების შემთხვევაში, რათა უზრუნველყოფილი იყოს, რომ ის აკმაყოფილებს შესაძლებლობების ახალ ნაკრებს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Pointer to a new buffer of size ‘size’ with capabilities ‘caps’, or NULL if allocation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: მითითება ადრე გამოყოფილ მეხსიერებაზე, ან NULL ახალი გამოყოფისთვის. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: მოთხოვნილი ახალი ბუფერის ზომა, ან 0 ბუფერის გასათავისუფლებლად. </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური OR, რომლებიც მიუთითებენ ახალი განაწილებისთვის სასურველ მეხსიერების ტიპზე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423heap_caps_aligned_alloc6size_t6size_ti">
<span id="_CPPv323heap_caps_aligned_alloc6size_t6size_ti"></span><span id="_CPPv223heap_caps_aligned_alloc6size_t6size_ti"></span><span id="heap_caps_aligned_alloc__s.s.i"></span><span class="target" id="esp__heap__caps_8h_1abdec7b01277123f950aafc739565ec37"></span>void *<code class="descname">heap_caps_aligned_alloc</code><span class="sig-paren">(</span>size_t <em>გასწორება</em>, size_t <em>ზომა</em>, int <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv423heap_caps_aligned_alloc6size_t6size_ti" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყავით მეხსიერების გასწორებული ნაწილი, რომელსაც აქვს მოცემული შესაძლებლობები. </p>
<p>შესაძლებლობების მქონე მეხსიერებისთვის, libc aligned_alloc()-ის ეკვივალენტური სემანტიკა. <dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>Any memory allocated with heaps_caps_aligned_alloc() MUST be freed with heap_caps_aligned_free() and CANNOT be passed to free() </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>მიღებული მაჩვენებლის გასწორების საჭიროება ორის ხარისხში უნდა იყოს. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: გამოსაყოფი მეხსიერების ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* ფლაგების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ დასაბრუნებელი მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t">
<span id="_CPPv324heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t"></span><span id="_CPPv224heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t"></span><span id="heap_caps_aligned_calloc__s.s.s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ae4fd0561451035c858cd2cc3f93d61b6"></span>void *<code class="descname">heap_caps_aligned_calloc</code><span class="sig-paren">(</span>size_t <em>გასწორება</em>, size_t <em>ნ</em>, size_t <em>ზომა</em>, uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv424heap_caps_aligned_calloc6size_t6size_t6size_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყავით მეხსიერების გასწორებული ნაწილი, რომელსაც აქვს მოცემული შესაძლებლობები. მეხსიერებაში ინიციალიზებული მნიშვნელობა ნულზეა დაყენებული. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>Any memory allocated with heap_caps_aligned_calloc() MUST be freed with heap_caps_aligned_free() and CANNOT be passed to free() </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>მიღებული მაჩვენებლის გასწორების საჭიროება ორის ხარისხში უნდა იყოს. </li>
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>მეხსიერების გასანაწილებელი მუდმივი ნაწილების რაოდენობა </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>გამოსაყოფი მეხსიერების ნაწილის ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* ფლაგების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ დასაბრუნებელი მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422heap_caps_aligned_freePv">
<span id="_CPPv322heap_caps_aligned_freePv"></span><span id="_CPPv222heap_caps_aligned_freePv"></span><span id="heap_caps_aligned_free__voidP"></span><span class="target" id="esp__heap__caps_8h_1a2aa70af40dda32723d5c98890c1187d3"></span>void <code class="descname">heap_caps_aligned_free</code><span class="sig-paren">(</span>void *<em>პტრ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv422heap_caps_aligned_freePv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება heap_caps_aligned_alloc-ით ადრე გამოყოფილი მეხსიერების დელოკაციისთვის. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function is aimed to deallocate only memory allocated with heap_caps_aligned_alloc, memory allocated with heap_caps_malloc MUST not be passed to this function </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>გამოყოფილი მეხსიერების მაჩვენებელი </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416heap_caps_calloc6size_t6size_t8uint32_t">
<span id="_CPPv316heap_caps_calloc6size_t6size_t8uint32_t"></span><span id="_CPPv216heap_caps_calloc6size_t6size_t8uint32_t"></span><span id="heap_caps_calloc__s.s.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a8c1ffa70e033b9485580af0078a66cf1"></span>void *<code class="descname">heap_caps_calloc</code><span class="sig-paren">(</span>size_t <em>ნ</em>, size_t <em>ზომა</em>, uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv416heap_caps_calloc6size_t6size_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყავით მეხსიერების ის ნაწილი, რომელსაც აქვს მოცემული შესაძლებლობები. მეხსიერებაში ინიციალიზებული მნიშვნელობა ნულზეა დაყენებული. </p>
<p>შესაძლებლობების მქონე მეხსიერებისთვის, libc calloc()-ის ეკვივალენტური სემანტიკა.</p>
<p>IDF-ში, <code class="docutils literal notranslate"><span class="pre">calloc(p)</span></code> უდრის <code class="docutils literal notranslate"><span class="pre">heap_caps_calloc(p,</span> <span class="pre">MALLOC_CAP_8BIT)</span></code>.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>მეხსიერების გასანაწილებელი მუდმივი ნაწილების რაოდენობა </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>გამოსაყოფი მეხსიერების ნაწილის ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* ფლაგების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ დასაბრუნებელი მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424heap_caps_get_total_size8uint32_t">
<span id="_CPPv324heap_caps_get_total_size8uint32_t"></span><span id="_CPPv224heap_caps_get_total_size8uint32_t"></span><span id="heap_caps_get_total_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1acc9e000e44c005280d4bfb2b0237cb04"></span>size_t <code class="descname">heap_caps_get_total_size</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv424heap_caps_get_total_size8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ყველა იმ რეგიონის საერთო ზომა, რომელსაც აქვს მოცემული შესაძლებლობები. </p>
<p>ეს ფუნქცია იღებს ყველა რეგიონს, რომელშიც მოცემული შესაძლებლობების გამოყოფაა შესაძლებელი და აჯამებს მათ მიერ არსებულ მთლიან სივრცეს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>total size in bytes </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423heap_caps_get_free_size8uint32_t">
<span id="_CPPv323heap_caps_get_free_size8uint32_t"></span><span id="_CPPv223heap_caps_get_free_size8uint32_t"></span><span id="heap_caps_get_free_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1aba551fca7214bbab39f9dfaa93ce581f"></span>size_t <code class="descname">heap_caps_get_free_size</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv423heap_caps_get_free_size8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ყველა იმ რეგიონის სრული უფასო ზომა, რომელსაც აქვს მოცემული შესაძლებლობები. </p>
<p>ეს ფუნქცია იღებს ყველა რეგიონს, რომელშიც მოცემული შესაძლებლობებია გამოყოფილი და აგროვებს მათში არსებულ თავისუფალ სივრცეს.</p>
<p>გაითვალისწინეთ, რომ გროვის ფრაგმენტაციის გამო, სავარაუდოდ, შეუძლებელია ამ ზომის მეხსიერების ერთი ბლოკის გამოყოფა. ამ მიზნით გამოიყენეთ heap_caps_get_largest_free_block() ფუნქცია.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Amount of free bytes in the regions </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv431heap_caps_get_minimum_free_size8uint32_t">
<span id="_CPPv331heap_caps_get_minimum_free_size8uint32_t"></span><span id="_CPPv231heap_caps_get_minimum_free_size8uint32_t"></span><span id="heap_caps_get_minimum_free_size__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a9a90e8d38ee9a6a900a90f1dfa5393fb"></span>size_t <code class="descname">heap_caps_get_minimum_free_size</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv431heap_caps_get_minimum_free_size8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული შესაძლებლობების მქონე ყველა რეგიონის მინიმალური თავისუფალი მეხსიერება. </p>
<p>ეს ამატებს იმ რეგიონების ყველა დაბალ ნიშნულს, რომლებსაც შეუძლიათ მოცემული შესაძლებლობებით მეხსიერების მიწოდება.</p>
<p>გაითვალისწინეთ, რომ შედეგი შეიძლება ნაკლები იყოს ამ ტიპის გლობალური მინიმალური ხელმისაწვდომი გროვის მაჩვენებელზე, რადგან „დაბალი წყლის ნიშნულები“ რეგიონების მიხედვით კონტროლდება. ცალკეული რეგიონების გროვები შესაძლოა „დაბალი წყლის ნიშნულებს“ სხვადასხვა დროს მიაღწიონ. თუმცა, ეს შედეგი მაინც იძლევა „უარესი შემთხვევის“ მითითებას ყველა დროის მინიმალური თავისუფალი გროვისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Amount of free bytes in the regions </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv432heap_caps_get_largest_free_block8uint32_t">
<span id="_CPPv332heap_caps_get_largest_free_block8uint32_t"></span><span id="_CPPv232heap_caps_get_largest_free_block8uint32_t"></span><span id="heap_caps_get_largest_free_block__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a557602c430237f580762415ccfff8c72"></span>size_t <code class="descname">heap_caps_get_largest_free_block</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv432heap_caps_get_largest_free_block8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული შესაძლებლობებით გამოყოფილი მეხსიერების უდიდესი თავისუფალი ბლოკი. </p>
<p>აბრუნებს უდიდეს მნიშვნელობას <code class="docutils literal notranslate"><span class="pre">s</span></code> რისთვისაც <code class="docutils literal notranslate"><span class="pre">heap_caps_malloc(s,</span> <span class="pre">caps)</span></code> წარმატებას მიაღწევს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Size of largest free block in bytes. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t">
<span id="_CPPv318heap_caps_get_infoP17multi_heap_info_t8uint32_t"></span><span id="_CPPv218heap_caps_get_infoP17multi_heap_info_t8uint32_t"></span><span id="heap_caps_get_info__multi_heap_info_tP.uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a149c4d5f97b416d97c43e699297d308d"></span>void <code class="descname">heap_caps_get_info</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv417multi_heap_info_t" title="multi_heap_info_t">multi_heap_info_t</a> *<em>ინფორმაცია</em>, uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv418heap_caps_get_infoP17multi_heap_info_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ გროვის ინფორმაცია მოცემული შესაძლებლობების მქონე ყველა რეგიონისთვის. </p>
<p>გამოიძახებს multi_heap_info() ფუნქციას ყველა გროვაზე, რომელიც იზიარებს მოცემულ შესაძლებლობებს. დაბრუნებული ინფორმაცია წარმოადგენს ყველა შესაბამის გროვაზე აგრეგირებულ ინფორმაციას. ველების მნიშვნელობა იგივეა, რაც განსაზღვრულია <a class="reference internal" href="mem_alloc.html#structmulti__heap__info__t"><span class="std std-ref">multi_heap_info_t</span></a>, გარდა იმისა, რომ <code class="docutils literal notranslate"><span class="pre">minimum_free_bytes</span></code> აქვს იგივე შეზღუდვები, რაც აღწერილია heap_caps_get_minimum_free_size() ფუნქციაში.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">info</span></code>: მაჩვენებელი სტრუქტურაზე, რომელიც შეივსება შესაბამისი გროვის მეტამონაცემებით. </li>
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425heap_caps_print_heap_info8uint32_t">
<span id="_CPPv325heap_caps_print_heap_info8uint32_t"></span><span id="_CPPv225heap_caps_print_heap_info8uint32_t"></span><span id="heap_caps_print_heap_info__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1a9128a61529561f49fec49416cbe7a1e6"></span>void <code class="descname">heap_caps_print_heap_info</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv425heap_caps_print_heap_info8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული შესაძლებლობებით აღჭურვილი ყველა მეხსიერების შეჯამება დაბეჭდეთ. </p>
<p>გამოიძახებს multi_heap_info-ს ყველა გროვაზე, რომლებიც იზიარებენ მოცემულ შესაძლებლობებს და ბეჭდავს თითოეულისთვის ორსტრიქონიან შეჯამებას, შემდეგ კი მთლიან შეჯამებას.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv429heap_caps_check_integrity_allb">
<span id="_CPPv329heap_caps_check_integrity_allb"></span><span id="_CPPv229heap_caps_check_integrity_allb"></span><span id="heap_caps_check_integrity_all__b"></span><span class="target" id="esp__heap__caps_8h_1a211c894e4d9caf638c3f4969729a42b5"></span>bool <code class="descname">heap_caps_check_integrity_all</code><span class="sig-paren">(</span>bool <em>ბეჭდვის_შეცდომები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv429heap_caps_check_integrity_allb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ სისტემაში არსებული ყველა მეხსიერების მთლიანობა. </p>
<p>ყველა გროვაზე multi_heap_check-ის გამოძახება. სურვილისამებრ, გროვების დაზიანების შემთხვევაში, შეცდომების დაბეჭდვა.</p>
<p>ამ ფუნქციის გამოძახება ეკვივალენტურია heap_caps_check_integrity-ის გამოძახებისა, როდესაც caps არგუმენტი დაყენებულია MALLOC_CAP_INVALID-ზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>True if all heaps are valid, False if at least one heap is corrupt. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: კონკრეტული შეცდომების დაბეჭდვა, თუ გროვის დაზიანება აღმოჩნდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425heap_caps_check_integrity8uint32_tb">
<span id="_CPPv325heap_caps_check_integrity8uint32_tb"></span><span id="_CPPv225heap_caps_check_integrity8uint32_tb"></span><span id="heap_caps_check_integrity__uint32_t.b"></span><span class="target" id="esp__heap__caps_8h_1a2a45e5c3e46f6e3b2fe2f09ffa49079f"></span>bool <code class="descname">heap_caps_check_integrity</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em>, bool <em>ბეჭდვის_შეცდომები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv425heap_caps_check_integrity8uint32_tb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ ყველა გროვის მთლიანობა მოცემული შესაძლებლობებით. </p>
<p>გამოიძახებს multi_heap_check-ს ყველა გროვაზე, რომელიც იზიარებს მოცემულ შესაძლებლობებს. სურვილისამებრ, ბეჭდავს შეცდომებს, თუ გროვები დაზიანებულია.</p>
<p>ასევე იხილეთ heap_caps_check_integrity_all სისტემაში არსებული მთელი heap მეხსიერების შესამოწმებლად და heap_caps_check_integrity_addr ერთი მისამართის გარშემო მეხსიერების შესამოწმებლად.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>True if all heaps are valid, False if at least one heap is corrupt. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: კონკრეტული შეცდომების დაბეჭდვა, თუ გროვის დაზიანება აღმოჩნდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430heap_caps_check_integrity_addr8intptr_tb">
<span id="_CPPv330heap_caps_check_integrity_addr8intptr_tb"></span><span id="_CPPv230heap_caps_check_integrity_addr8intptr_tb"></span><span id="heap_caps_check_integrity_addr__intptr_t.b"></span><span class="target" id="esp__heap__caps_8h_1a70306edd596739207e9b56301d2e3cc5"></span>bool <code class="descname">heap_caps_check_integrity_addr</code><span class="sig-paren">(</span>intptr_t <em>მისამართი</em>, bool <em>ბეჭდვის_შეცდომები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv430heap_caps_check_integrity_addr8intptr_tb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ მოცემული მისამართის გარშემო არსებული ჰუპის მეხსიერების მთლიანობა. </p>
<p>ეს ფუნქცია შეიძლება გამოყენებულ იქნას გროვის მეხსიერების ერთი რეგიონის მთლიანობის შესამოწმებლად, რომელიც შეიცავს მოცემულ მისამართს.</p>
<p>ეს შეიძლება სასარგებლო იყოს, თუ გამართვა ცნობილ მისამართზე დაზიანების აღმოსაჩენად გროვის მთლიანობას ამოწმებს, რადგან მას ყველა გროვის რეგიონის შემოწმებასთან შედარებით უფრო დაბალი დატვირთვა აქვს. გაითვალისწინეთ, რომ თუ დაზიანებული მისამართი გაშვებებს შორის მოძრაობს (დროის ან სხვა ფაქტორების გამო), მაშინ ეს მიდგომა არ იმუშავებს და ამის ნაცვლად უნდა გამოიძახოთ heap_caps_check_integrity ან heap_caps_check_integrity_all.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>The entire heap region around the address is checked, not only the adjacent heap blocks.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>True if the heap containing the specified address is valid, False if at least one heap is corrupt or the address doesn’t belong to a heap region. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>მისამართი მეხსიერებაშია. შეამოწმეთ დაზიანებულია თუ არა ამ მისამართის შემცველი რეგიონი. </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>: კონკრეტული შეცდომების დაბეჭდვა, თუ გროვის დაზიანება აღმოჩნდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430heap_caps_malloc_extmem_enable6size_t">
<span id="_CPPv330heap_caps_malloc_extmem_enable6size_t"></span><span id="_CPPv230heap_caps_malloc_extmem_enable6size_t"></span><span id="heap_caps_malloc_extmem_enable__s"></span><span class="target" id="esp__heap__caps_8h_1a94574f33deb2cacc7ed5b5ce3920440f"></span>void <code class="descname">heap_caps_malloc_extmem_enable</code><span class="sig-paren">(</span>size_t <em>ლიმიტი</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv430heap_caps_malloc_extmem_enable6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩართეთ malloc() ფუნქცია გარე მეხსიერებაში და დააყენეთ ლიმიტი, რომლის ქვემოთაც malloc() მცდელობები განთავსდება შიდა მეხსიერებაში. </p>
<p>როდესაც გარე მეხსიერება გამოიყენება, განაწილების სტრატეგია თავდაპირველად გულისხმობს მცირე ზომის განაწილების მოთხოვნების დაკმაყოფილებას შიდა მეხსიერებით, ხოლო უფრო დიდი ზომის მოთხოვნების - გარე მეხსიერებით. ეს ადგენს ზღვარს ორს შორის და ზოგადად საშუალებას იძლევა განაწილება გარე მეხსიერებაში.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">limit</span></code>ლიმიტი, ბაიტებში. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423heap_caps_malloc_prefer6size_t6size_tz">
<span id="_CPPv323heap_caps_malloc_prefer6size_t6size_tz"></span><span id="_CPPv223heap_caps_malloc_prefer6size_t6size_tz"></span><span id="heap_caps_malloc_prefer__s.s.z"></span><span class="target" id="esp__heap__caps_8h_1a7744d1d1932294a1171b684e9633d096"></span>void *<code class="descname">heap_caps_malloc_prefer</code><span class="sig-paren">(</span>size_t <em>ზომა</em>, size_t <em>ნომერი</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv423heap_caps_malloc_prefer6size_t6size_tz" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მეხსიერების გარკვეული ნაწილი გამოყავით უპირატესობის მიხედვით კლებადი თანმიმდევრობით. </p>
<p><dl class="docutils">
<dt><strong>ყურადღება</strong></dt>
<dd>The variable parameters are bitwise OR of MALLOC_CAP_* flags indicating the type of memory. This API prefers to allocate memory with the first parameter. If failed, allocate memory with the next parameter. It will try in this order until allocating a chunk of memory successfully or fail to allocate memories with any of the parameters.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: გამოსაყოფი მეხსიერების ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>ცვლადი პარამეტრების რაოდენობა</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424heap_caps_realloc_preferPv6size_t6size_tz">
<span id="_CPPv324heap_caps_realloc_preferPv6size_t6size_tz"></span><span id="_CPPv224heap_caps_realloc_preferPv6size_t6size_tz"></span><span id="heap_caps_realloc_prefer__voidP.s.s.z"></span><span class="target" id="esp__heap__caps_8h_1a2953dd52680bec9536f305856e709b4a"></span>void *<code class="descname">heap_caps_realloc_prefer</code><span class="sig-paren">(</span>void *<em>პტრ</em>, size_t <em>ზომა</em>, size_t <em>ნომერი</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv424heap_caps_realloc_preferPv6size_t6size_tz" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მეხსიერების გარკვეული ნაწილი გამოყავით უპირატესობის მიხედვით კლებადი თანმიმდევრობით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Pointer to a new buffer of size ‘size’, or NULL if allocation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: მითითება ადრე გამოყოფილ მეხსიერებაზე, ან NULL ახალი გამოყოფისთვის. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: მოთხოვნილი ახალი ბუფერის ზომა, ან 0 ბუფერის გასათავისუფლებლად. </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>ცვლადი პარამეტრების რაოდენობა</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423heap_caps_calloc_prefer6size_t6size_t6size_tz">
<span id="_CPPv323heap_caps_calloc_prefer6size_t6size_t6size_tz"></span><span id="_CPPv223heap_caps_calloc_prefer6size_t6size_t6size_tz"></span><span id="heap_caps_calloc_prefer__s.s.s.z"></span><span class="target" id="esp__heap__caps_8h_1aa05e878ed334b584bcb0b2c6229e4b2b"></span>void *<code class="descname">heap_caps_calloc_prefer</code><span class="sig-paren">(</span>size_t <em>ნ</em>, size_t <em>ზომა</em>, size_t <em>ნომერი</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv423heap_caps_calloc_prefer6size_t6size_t6size_tz" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მეხსიერების გარკვეული ნაწილი გამოყავით უპირატესობის მიხედვით კლებადი თანმიმდევრობით. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the memory allocated on success, NULL on failure </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>მეხსიერების გასანაწილებელი მუდმივი ნაწილების რაოდენობა </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>გამოსაყოფი მეხსიერების ნაწილის ზომა, ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>ცვლადი პარამეტრების რაოდენობა</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414heap_caps_dump8uint32_t">
<span id="_CPPv314heap_caps_dump8uint32_t"></span><span id="_CPPv214heap_caps_dump8uint32_t"></span><span id="heap_caps_dump__uint32_t"></span><span class="target" id="esp__heap__caps_8h_1ae19d3bc2f6f027fe30e47cbf991f1a6b"></span>void <code class="descname">heap_caps_dump</code><span class="sig-paren">(</span>uint32_t <em>ქუდები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv414heap_caps_dump8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შესაბამისი შესაძლებლობების მქონე ყველა გროვის სრული სტრუქტურის დემპინგი. </p>
<p>დიდი რაოდენობით გამომავალი მონაცემების ბეჭდვა სერიულ პორტატულ სისტემებში (დაბლოკვის შეზღუდვების გამო, გამომავალი გვერდს უვლის stdout/stderr-ს). თითოეული შესაბამისი გროვის თითოეული (ცვლადი ზომის) ბლოკისთვის, შემდეგი გამომავალი მონაცემები იბეჭდება ერთ ხაზზე:</p>
<p><ul class="simple">
<li>ბლოკის მისამართი (malloc-ის მიერ დაბრუნებული მონაცემთა ბუფერი ამის შემდეგ 4 ბაიტია, თუ heap გამართვა ging დაყენებულია Basic-ზე, ან 8 ბაიტი სხვა შემთხვევაში).</li>
<li>მონაცემთა ზომა (მონაცემთა ზომა შეიძლება იყოს malloc-ის მიერ მოთხოვნილ ზომაზე დიდი, ან გროვის ფრაგმენტაციის, ან გროვის გამართვა ging დონის გამო).</li>
<li>გროვაში შემდეგი ბლოკის მისამართი.</li>
<li>თუ ბლოკი თავისუფალია, შემდეგი თავისუფალი ბლოკის მისამართიც იბეჭდება.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>MALLOC_CAP_* დროშების ბიტური ან ბიტური OR, რომლებიც მიუთითებენ მეხსიერების ტიპზე </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418heap_caps_dump_allv">
<span id="_CPPv318heap_caps_dump_allv"></span><span id="_CPPv218heap_caps_dump_allv"></span><span id="heap_caps_dump_all__void"></span><span class="target" id="esp__heap__caps_8h_1a38a354fb76dfa5b8f9ea0755455ff02b"></span>void <code class="descname">heap_caps_dump_all</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv418heap_caps_dump_allv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გადაყარეთ ყველა გროვის სრული სტრუქტურა. </p>
<p>მოიცავს ყველა რეგისტრირებულ გროვას. ბეჭდავს დიდი რაოდენობით გამომავალ მონაცემებს სერიულ პორტში.</p>
<p>გამომავალი იგივეა, რაც heap_caps_dump-ისთვის. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428heap_caps_get_allocated_sizePv">
<span id="_CPPv328heap_caps_get_allocated_sizePv"></span><span id="_CPPv228heap_caps_get_allocated_sizePv"></span><span id="heap_caps_get_allocated_size__voidP"></span><span class="target" id="esp__heap__caps_8h_1a048217cbb477451ec4739bdac4021583"></span>size_t <code class="descname">heap_caps_get_allocated_size</code><span class="sig-paren">(</span>void *<em>პტრ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv428heap_caps_get_allocated_sizePv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ ზომა, რომელიც კონკრეტულ მაჩვენებელს ჰქონდა მინიჭებული. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>The app will crash with an assertion failure if the pointer is not valid.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>Size of the memory allocated at this block. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ptr</span></code>: ამჟამად გამოყოფილი გროვის მეხსიერების მაჩვენებელი. უნდა იყოს მაჩვენებელის მნიშვნელობა, რომელიც ადრე დააბრუნა heap_caps_malloc,malloc, calloc და ა.შ.-მა და ჯერ არ გაათავისუფლა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="mem_alloc.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.MALLOC_CAP_EXEC">
<span class="target" id="esp__heap__caps_8h_1a7c96cafcb8ab916f84bca17603ec7ba7"></span><code class="descname">MALLOC_CAP_EXEC</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_EXEC" title="Permalink to this definition">¶</a></dt>
<dd><p>დროშები სხვადასხვა მეხსიერების სისტემის შესაძლებლობების აღსანიშნავად. </p>
<p>მეხსიერებას უნდა შეეძლოს შესრულებადი კოდის გაშვება </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_32BIT">
<span class="target" id="esp__heap__caps_8h_1a826059625c016d96c251325d6673e096"></span><code class="descname">MALLOC_CAP_32BIT</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_32BIT" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერებამ უნდა უზრუნველყოს 32-ბიტიანი მონაცემების წვდომის გასწორება. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_8BIT">
<span class="target" id="esp__heap__caps_8h_1aac0f0a20c619ae2e979820ffbf2a74ca"></span><code class="descname">MALLOC_CAP_8BIT</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_8BIT" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერებამ უნდა უზრუნველყოს 8/16/…-ბიტიანი მონაცემებზე წვდომა. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_DMA">
<span class="target" id="esp__heap__caps_8h_1ad54f7d30a5138ac70088b9532043ebd7"></span><code class="descname">MALLOC_CAP_DMA</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_DMA" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერებაზე წვდომა DMA-ს საშუალებით უნდა იყოს შესაძლებელი. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID2">
<span class="target" id="esp__heap__caps_8h_1a3673338a10ab2461426397b1f08b1f46"></span><code class="descname">MALLOC_CAP_PID2</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID2" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID2 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID3">
<span class="target" id="esp__heap__caps_8h_1a0de919b5cc5d4d45f645a3386c717a6e"></span><code class="descname">MALLOC_CAP_PID3</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID3" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID3 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID4">
<span class="target" id="esp__heap__caps_8h_1a3d003de2672f6516e41c6af17b14dcd3"></span><code class="descname">MALLOC_CAP_PID4</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID4" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID4 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID5">
<span class="target" id="esp__heap__caps_8h_1ac9769710e6abd937d3b3b9d06ffb4fc2"></span><code class="descname">MALLOC_CAP_PID5</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID5" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID5 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID6">
<span class="target" id="esp__heap__caps_8h_1abecfbaa7697633318a031eff5ea50dc6"></span><code class="descname">MALLOC_CAP_PID6</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID6" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID6 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_PID7">
<span class="target" id="esp__heap__caps_8h_1a6f793bf08b8197cc457062ecba25b984"></span><code class="descname">MALLOC_CAP_PID7</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_PID7" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება უნდა იყოს დაკავშირებული PID7 მეხსიერების სივრცესთან (PID-ები ამჟამად არ გამოიყენება) </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_SPIRAM">
<span class="target" id="esp__heap__caps_8h_1ace53477a25da151b259cb66c4c486f48"></span><code class="descname">MALLOC_CAP_SPIRAM</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_SPIRAM" title="Permalink to this definition">¶</a></dt>
<dd><p>ოპერატიული მეხსიერება უნდა იყოს SPI RAM-ში. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_INTERNAL">
<span class="target" id="esp__heap__caps_8h_1a5f2f4d8ffb828c43078750c475cf6047"></span><code class="descname">MALLOC_CAP_INTERNAL</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_INTERNAL" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერება შიდა უნდა იყოს; კერძოდ, ის არ უნდა გაქრეს ფლეშ მეხსიერება /spiram ქეშის გამორთვის შემდეგ. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_DEFAULT">
<span class="target" id="esp__heap__caps_8h_1ac2819ab42951525fcea5025c268f069c"></span><code class="descname">MALLOC_CAP_DEFAULT</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_DEFAULT" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერების დაბრუნება შესაძლებელია არასპეციფიკური მეხსიერების განაწილებით (მაგ. malloc(), calloc()) გამოძახებით. </p>
</dd></dl>
<dl class="macro">
<dt id="c.MALLOC_CAP_INVALID">
<span class="target" id="esp__heap__caps_8h_1ab711dea757d655e249112adc67a879ad"></span><code class="descname">MALLOC_CAP_INVALID</code><a class="headerlink" href="mem_alloc.html#c.MALLOC_CAP_INVALID" title="Permalink to this definition">¶</a></dt>
<dd><p>მეხსიერების გამოყენება შეუძლებელია / სიის ბოლოს მარკერი. </p>
</dd></dl>
</div>
<div class="section" id="thread-safety">
<h3>ძაფის უსაფრთხოება<a class="headerlink" href="mem_alloc.html#thread-safety" title="Permalink to this headline">¶</a></h3>
<p>Heap ფუნქციები ძაფებისთვის უსაფრთხოა, რაც იმას ნიშნავს, რომ მათი გამოძახება სხვადასხვა დავალებიდან ერთდროულად შესაძლებელია ყოველგვარი შეზღუდვის გარეშე.</p>
<p>ტექნიკურად შესაძლებელია დარეკვა <code class="docutils literal notranslate"><span class="pre">malloc</span></code>, <code class="docutils literal notranslate"><span class="pre">free</span></code>და მასთან დაკავშირებული ფუნქციები შეწყვეტის დამმუშავებლის (ISR) კონტექსტიდან. თუმცა, ეს არ არის რეკომენდებული, რადგან გროვის ფუნქციის გამოძახებამ შეიძლება სხვა შეწყვეტები შეაფერხოს. მკაცრად რეკომენდებულია აპლიკაციების რეფაქტორიზაცია ისე, რომ ISR-ის მიერ გამოყენებული ნებისმიერი ბუფერი წინასწარ იყოს გამოყოფილი ISR-ის გარეთ. ISR-ებიდან გროვის ფუნქციების გამოძახების მხარდაჭერა შესაძლოა მომავალ განახლებაში გაუქმდეს.</p>
</div>
</div>
<div class="section" id="heap-tracing-debugging">
<h2>გროვის ტრასირება და გამართვა<a class="headerlink" href="mem_alloc.html#heap-tracing-debugging" title="Permalink to this headline">¶</a></h2>
<p>შემდეგი მახასიათებლები დოკუმენტირებულია <a class="reference internal" href="heap_debug.html"><span class="doc">გროვის მეხსიერების გამართვა</span></a> გვერდი:</p>
<ul class="simple">
<li><a class="reference internal" href="heap_debug.html#heap-information"><span class="std std-ref">გროვის ინფორმაცია</span></a> (თავისუფალი სივრცე და ა.შ.)</li>
<li><a class="reference internal" href="heap_debug.html#heap-corruption"><span class="std std-ref">გროვის დაზიანების აღმოჩენა</span></a></li>
<li><a class="reference internal" href="heap_debug.html#heap-tracing"><span class="std std-ref">გროვის ტრასირება</span></a> (მეხსიერების გაჟონვის აღმოჩენა, მონიტორინგი და ა.შ.)</li>
</ul>
</div>
<div class="section" id="api-reference-initialisation">
<h2>API მითითება - ინიციალიზაცია<a class="headerlink" href="mem_alloc.html#api-reference-initialisation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>სათაურის ფაილი<a class="headerlink" href="mem_alloc.html#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/esp_heap_caps_init.h">heap/include/esp_heap_caps_init.h</a></li>
</ul>
</div>
<div class="section" id="id4">
<h3>ფუნქციები<a class="headerlink" href="mem_alloc.html#id4" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv414heap_caps_initv">
<span id="_CPPv314heap_caps_initv"></span><span id="_CPPv214heap_caps_initv"></span><span id="heap_caps_init__void"></span><span class="target" id="esp__heap__caps__init_8h_1abacfe65210ed89804126b128dcdc6db0"></span>void <code class="descname">heap_caps_init</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv414heap_caps_initv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შესაძლებლობების გათვალისწინებით შექმნილი გროვის გამანაწილებლის ინიციალიზაცია. </p>
<p>ეს IDF-ის გაშვების კოდში ერთხელ გამოიძახება. სხვა დროს არ გამოიძახოთ. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv434heap_caps_enable_nonos_stack_heapsv">
<span id="_CPPv334heap_caps_enable_nonos_stack_heapsv"></span><span id="_CPPv234heap_caps_enable_nonos_stack_heapsv"></span><span id="heap_caps_enable_nonos_stack_heaps__void"></span><span class="target" id="esp__heap__caps__init_8h_1af5c1dc12cab8b7acd97863f433316c19"></span>void <code class="descname">heap_caps_enable_nonos_stack_heaps</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv434heap_caps_enable_nonos_stack_heapsv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მეხსიერების იმ რეგიონებში, სადაც გაშვების სტეკებია განთავსებული, გროვის(ების) ჩართვა. </p>
<p>გაშვებისას, pro/app CPU-ებს აქვთ გარკვეული მეხსიერების რეგიონი, რომელსაც ისინი იყენებენ როგორც სტეკს, ამიტომ ჩვენ არ შეგვიძლია განვახორციელოთ გამოყოფა იმ რეგიონებში, სადაც ეს სტეკის ჩარჩოებია. როდესაც Free RTOS სრულად ჩაირთვება, ისინი აღარ იყენებენ ამ მეხსიერებას და იქ არსებული ჰუპ(ები) შეიძლება ჩაირთოს. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420heap_caps_add_region8intptr_t8intptr_t">
<span id="_CPPv320heap_caps_add_region8intptr_t8intptr_t"></span><span id="_CPPv220heap_caps_add_region8intptr_t8intptr_t"></span><span id="heap_caps_add_region__intptr_t.intptr_t"></span><span class="target" id="esp__heap__caps__init_8h_1ae22488c4edee3a2bff04a19938dc7b23"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">heap_caps_add_region</code><span class="sig-paren">(</span>intptr_t <em>დაწყება</em>, intptr_t <em>დასასრული</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv420heap_caps_add_region8intptr_t8intptr_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაშვების დროს დაამატეთ მეხსიერების რეგიონი გროვების კოლექციას. </p>
<p>მეხსიერების რეგიონების უმეტესობა განსაზღვრულია soc_memory_layout.c-ში SoC-ისთვის და რეგისტრირდება heap_caps_init() ფუნქციის მეშვეობით. ზოგიერთი რეგიონის გამოყენება დაუყოვნებლივ შეუძლებელია და მოგვიანებით გააქტიურდება heap_caps_enable_nonos_stack_heaps() ფუნქციის მეშვეობით.</p>
<p>გამოიძახეთ ეს ფუნქცია, რათა მოგვიანებით გროვაში მეხსიერების რეგიონი დაამატოთ.</p>
<p>ეს ფუნქცია არ ითვალისწინებს soc_memory_layout-ში არსებულ არცერთ „დაჯავშნილ“ რეგიონს ან სხვა მონაცემებს, გამომძახებელმა ეს თავად უნდა გაითვალისწინოს.</p>
<p>საწყისი და დასასრული პარამეტრებით მითითებულ რეგიონში არსებული ყველა მეხსიერება სხვაგვარად გამოუყენებელი უნდა იყოს.</p>
<p>ახლად რეგისტრირებული მეხსიერების შესაძლებლობები განისაზღვრება საწყისი მისამართით, რომელიც მოიძებნება soc_memory_layout.c ფაილში მითითებულ რეგიონებში.</p>
<p>გამოიყენეთ heap_caps_add_region_with_caps() ფუნქცია, რათა დარეგისტრირდეთ რეგიონი მორგებული შესაძლებლობებით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>ESP_OK on success, ESP_ERR_INVALID_ARG if a parameter is invalid, ESP_ERR_NOT_FOUND if the specified start address doesn’t reside in a known region, or any error returned by heap_caps_add_region_with_caps(). </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>ახალი რეგიონის საწყისი მისამართი. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>ახალი რეგიონის საბოლოო მისამართი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t">
<span id="_CPPv330heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t"></span><span id="_CPPv230heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t"></span><span id="heap_caps_add_region_with_caps__uint32_tCA.intptr_t.intptr_t"></span><span class="target" id="esp__heap__caps__init_8h_1a6960ca17873b47de977541b37cde3404"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">heap_caps_add_region_with_caps</code><span class="sig-paren">(</span><em class="property">კონსტ</em> uint32_t <em>ქუდები</em>[], intptr_t <em>დაწყება</em>, intptr_t <em>დასასრული</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv430heap_caps_add_region_with_capsA_K8uint32_t8intptr_t8intptr_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაშვების დროს, მორგებული შესაძლებლობებით, დაამატეთ მეხსიერების რეგიონი გროვების კოლექციას. </p>
<p>heap_caps_add_region()-ის მსგავსად, გამომძახებელი მხოლოდ მეხსიერების მორგებულ შესაძლებლობებს განსაზღვრავს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_INVALID_ARG თუ პარამეტრი არასწორია</li>
<li>ESP_ERR_NO_MEM, თუ არ არის მეხსიერება ახალი გროვის რეგისტრაციისთვის.</li>
<li>ESP_ERR_INVALID_SIZE თუ მეხსიერების რეგიონი ძალიან პატარაა გროვის დასატევად</li>
<li>ESP_FAIL თუ რეგიონი ემთხვევა არსებული რეგიონის დასაწყისს და/ან დასასრულს </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">caps</span></code>ახალი რეგიონისთვის შესაძლებლობების ნიღბების მასივი დალაგებულია პრიორიტეტულობის მიხედვით. სიგრძე უნდა იყოს SOC_MEMORY_TYPE_NO_PRIOS. ზარის დაბრუნების შემდეგ მისი ძალაში დარჩენა სავალდებულო არ არის. </li>
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>ახალი რეგიონის საწყისი მისამართი. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>ახალი რეგიონის საბოლოო მისამართი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</div>
<div class="section" id="implementation-notes">
<h2>განხორციელების შენიშვნები<a class="headerlink" href="mem_alloc.html#implementation-notes" title="Permalink to this headline">¶</a></h2>
<p>ჩიპში მეხსიერების რეგიონების შესახებ ცოდნა მომდინარეობს ტერმინიდან „soc“ კომპონენტი , რომელიც შეიცავს ჩიპის მეხსიერების განლაგების ინფორმაციას და თითოეული რეგიონის განსხვავებულ შესაძლებლობებს. თითოეული რეგიონის შესაძლებლობები პრიორიტეტულია, ამიტომ (მაგალითად) გამოყოფილი DRAM და IRAM რეგიონები გამოყენებული იქნება განაწილებისთვის უფრო მრავალმხრივი D/IRAM რეგიონების წინ.</p>
<p>მეხსიერების თითოეული მომიჯნავე რეგიონი შეიცავს საკუთარ მეხსიერების გროვას. გროვები იქმნება შემდეგი მეთოდის გამოყენებით: <a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/en/latest/api-reference/system/APIReference-MultiHeapAPI">მრავალგროვა</a> ფუნქციონალურობა. multi_heap საშუალებას იძლევა მეხსიერების ნებისმიერი მომიჯნავე რეგიონი გამოყენებულ იქნას როგორც heap.</p>
<p>გროვის შესაძლებლობების გამანაწილებელი იყენებს მეხსიერების რეგიონების ცოდნას თითოეული ინდივიდუალური გროვის ინიციალიზაციისთვის. გროვის შესაძლებლობების API ში განაწილების ფუნქციები იპოვის განაწილებისთვის ყველაზე შესაფერის გროვას (სასურველი შესაძლებლობების, ხელმისაწვდომი სივრცისა და თითოეული რეგიონის გამოყენების პრეფერენციების საფუძველზე) და შემდეგ გამოიძახებს <a class="reference internal" href="mem_alloc.html#_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t" title="multi_heap_malloc"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_malloc()</span></code></a> ან <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_calloc()</span></code> ამ კონკრეტულ რეგიონში განლაგებული გროვისთვის.</p>
<p>ზარი <code class="docutils literal notranslate"><span class="pre">free()</span></code> მოიცავს გათავისუფლებული მისამართის შესაბამისი კონკრეტული გროვის პოვნას და შემდეგ გამოძახებას <a class="reference internal" href="mem_alloc.html#_CPPv415multi_heap_free19multi_heap_handle_tPv" title="multi_heap_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">multi_heap_free()</span></code></a> ამ კონკრეტულ multi_heap ინსტანციაზე.</p>
</div>
<div class="section" id="api-reference-multi-heap-api">
<h2>API მითითება - მრავალჯერადი გროვა API<a class="headerlink" href="mem_alloc.html#api-reference-multi-heap-api" title="Permalink to this headline">¶</a></h2>
<p>(შენიშვნა: მრავალჯერადი გროვის API გამოიყენება გროვის შესაძლებლობების განაწილების შიდა პროგრამით. IDF პროგრამების უმეტესობას არასდროს დასჭირდება ამ API პირდაპირ გამოძახება.)</p>
<div class="section" id="id5">
<h3>სათაურის ფაილი<a class="headerlink" href="mem_alloc.html#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/heap/include/multi_heap.h">heap/include/multi_heap.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>ფუნქციები<a class="headerlink" href="mem_alloc.html#id6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv424multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t">
<span id="_CPPv324multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t"></span><span id="_CPPv224multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t"></span><span id="multi_heap_aligned_alloc__multi_heap_handle_t.s.s"></span><span class="target" id="multi__heap_8h_1a3cc0c646637c5a8b7ba32bef73ef8cf2"></span>void *<code class="descname">multi_heap_aligned_alloc</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, size_t <em>ზომა</em>, size_t <em>გასწორება</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv424multi_heap_aligned_alloc19multi_heap_handle_t6size_t6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მეხსიერების გარკვეული ნაწილის გამოყოფა კონკრეტული განლაგებით </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pointer to the memory allocated, NULL on failure </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: მეხსიერების ნაწილის ზომა ბაიტებში </li>
<li><code class="docutils literal notranslate"><span class="pre">alignment</span></code>როგორ უნდა იყოს მეხსიერება გასწორებული</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t">
<span id="_CPPv317multi_heap_malloc19multi_heap_handle_t6size_t"></span><span id="_CPPv217multi_heap_malloc19multi_heap_handle_t6size_t"></span><span id="multi_heap_malloc__multi_heap_handle_t.s"></span><span class="target" id="multi__heap_8h_1ac212763e8d7784e6d497e1f43b2df28e"></span>void *<code class="descname">multi_heap_malloc</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv417multi_heap_malloc19multi_heap_handle_t6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>malloc() ბუფერი მოცემულ გროვაში </p>
<p>სემანტიკა იგივეა, რაც სტანდარტული malloc()-ის, მხოლოდ დაბრუნებული ბუფერი იქნება გამოყოფილი მითითებულ გროვაში.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Pointer to new memory, or NULL if allocation fails. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>სასურველი ბუფერის ზომა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423multi_heap_aligned_free19multi_heap_handle_tPv">
<span id="_CPPv323multi_heap_aligned_free19multi_heap_handle_tPv"></span><span id="_CPPv223multi_heap_aligned_free19multi_heap_handle_tPv"></span><span id="multi_heap_aligned_free__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1a96b36bfa54860ff4d98f218d5c472d7d"></span>void <code class="descname">multi_heap_aligned_free</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, void *<em>გვ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv423multi_heap_aligned_free19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>free() ბუფერი, რომელიც გასწორებულია მოცემულ გროვაში. </p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, ან მაჩვენებელი, რომელიც ადრე დაბრუნებული იყო multi_heap_aligned_alloc()-დან იმავე გროვისთვის. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415multi_heap_free19multi_heap_handle_tPv">
<span id="_CPPv315multi_heap_free19multi_heap_handle_tPv"></span><span id="_CPPv215multi_heap_free19multi_heap_handle_tPv"></span><span id="multi_heap_free__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1a57ece2f1499c39b5756498ec331bd468"></span>void <code class="descname">multi_heap_free</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, void *<em>გვ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv415multi_heap_free19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>free() ბუფერი მოცემულ გროვაში. </p>
<p>სემანტიკა იგივეა, რაც სტანდარტული free(), მხოლოდ არგუმენტი &amp;#39;p&amp;#39; უნდა იყოს NULL ან გამოყოფილი იყოს მითითებულ გროვაში.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, ან მაჩვენებელი, რომელიც ადრე დაბრუნებული იყო multi_heap_malloc()-დან ან multi_heap_realloc()-დან იმავე გროვისთვის. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418multi_heap_realloc19multi_heap_handle_tPv6size_t">
<span id="_CPPv318multi_heap_realloc19multi_heap_handle_tPv6size_t"></span><span id="_CPPv218multi_heap_realloc19multi_heap_handle_tPv6size_t"></span><span id="multi_heap_realloc__multi_heap_handle_t.voidP.s"></span><span class="target" id="multi__heap_8h_1a9d3f3a85cb7c2581e5d822bb2682d8c9"></span>void *<code class="descname">multi_heap_realloc</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, void *<em>გვ</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv418multi_heap_realloc19multi_heap_handle_tPv6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>realloc() ბუფერი მოცემულ გროვაში. </p>
<p>სემანტიკა იგივეა, რაც სტანდარტული realloc()-ის, მხოლოდ არგუმენტი &amp;#39;p&amp;#39; უნდა იყოს NULL ან გამოყოფილი იყოს მითითებულ გროვაში.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>New buffer of ‘size’ containing contents of ‘p’, or NULL if reallocation failed. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: NULL, ან მაჩვენებელი, რომელიც ადრე დაბრუნებული იყო multi_heap_malloc()-დან ან multi_heap_realloc()-დან იმავე გროვისთვის. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: ბუფერისთვის სასურველი ახალი ზომა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv429multi_heap_get_allocated_size19multi_heap_handle_tPv">
<span id="_CPPv329multi_heap_get_allocated_size19multi_heap_handle_tPv"></span><span id="_CPPv229multi_heap_get_allocated_size19multi_heap_handle_tPv"></span><span id="multi_heap_get_allocated_size__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1af88d5a13cce47e48c329ef86f29f5fa2"></span>size_t <code class="descname">multi_heap_get_allocated_size</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, void *<em>გვ</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv429multi_heap_get_allocated_size19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ ზომა, რომელიც კონკრეტულ მაჩვენებელს ჰქონდა მინიჭებული. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Size of the memory allocated at this block. May be more than the original size argument, due to padding and minimum block sizes. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: მაჩვენებელი, რომელიც ადრე უნდა დაბრუნებულიყო multi_heap_malloc()-დან ან multi_heap_realloc()-დან იმავე გროვისთვის.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419multi_heap_registerPv6size_t">
<span id="_CPPv319multi_heap_registerPv6size_t"></span><span id="_CPPv219multi_heap_registerPv6size_t"></span><span id="multi_heap_register__voidP.s"></span><span class="target" id="multi__heap_8h_1a83ee39aa9c03378c9eb32dc45c27f016"></span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <code class="descname">multi_heap_register</code><span class="sig-paren">(</span>void *<em>დაწყება</em>, size_t <em>ზომა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv419multi_heap_registerPv6size_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაარეგისტრირეთ ახალი გროვა გამოსაყენებლად. </p>
<p>ეს ფუნქცია ინიციალიზაციას უკეთებს გროვას მითითებულ მისამართზე და აბრუნებს სახელურს მომავალი გროვური ოპერაციებისთვის.</p>
<p>არ არსებობს ეკვივალენტური ფუნქცია გროვის რეგისტრაციის გასაუქმებლად - თუ გროვის ყველა ბლოკი თავისუფალია, შეგიძლიათ დაუყოვნებლივ დაიწყოთ მეხსიერების გამოყენება სხვა მიზნებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Handle of a new heap ready for use, or NULL if the heap region was too small to be initialised. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">start</span></code>ახალი გროვისთვის გამოსაყენებელი მეხსიერების საწყისი მისამართი. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>ახალი გროვის ზომა (ბაიტებში).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419multi_heap_set_lock19multi_heap_handle_tPv">
<span id="_CPPv319multi_heap_set_lock19multi_heap_handle_tPv"></span><span id="_CPPv219multi_heap_set_lock19multi_heap_handle_tPv"></span><span id="multi_heap_set_lock__multi_heap_handle_t.voidP"></span><span class="target" id="multi__heap_8h_1af1e3c624610b9768289eb95496f6cdeb"></span>void <code class="descname">multi_heap_set_lock</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, void *<em>საკეტი</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv419multi_heap_set_lock19multi_heap_handle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>კერძო საკეტის მაჩვენებლის გროვასთან დაკავშირება. </p>
<p>დაბლოკვის არგუმენტი მიეწოდება MULTI_HEAP_LOCK() და MULTI_HEAP_UNLOCK() მაკროებს, რომლებიც განსაზღვრულია multi_heap_platform.h-ში.</p>
<p>შესაბამისი საკეტი რეკურსიული უნდა იყოს.</p>
<p>როდესაც გროვა პირველად დარეგისტრირდება, მასთან დაკავშირებული საკეტი არის NULL.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">lock</span></code>: ამ გროვასთან ასოცირებული დაბლოკვის სტრუქტურის სურვილისამებრ მითითება. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415multi_heap_dump19multi_heap_handle_t">
<span id="_CPPv315multi_heap_dump19multi_heap_handle_t"></span><span id="_CPPv215multi_heap_dump19multi_heap_handle_t"></span><span id="multi_heap_dump__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a498d52c8ab07c5863ce49cc142b01828"></span>void <code class="descname">multi_heap_dump</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv415multi_heap_dump19multi_heap_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დემპინგის გროვის ინფორმაციის stdout-ში გადატანა. </p>
<p>გამართვა ging-ის მიზნებისთვის, ეს ფუნქცია stdout-ში გადასცემს ინფორმაციას გროვაში არსებული ყველა ბლოკის შესახებ.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416multi_heap_check19multi_heap_handle_tb">
<span id="_CPPv316multi_heap_check19multi_heap_handle_tb"></span><span id="_CPPv216multi_heap_check19multi_heap_handle_tb"></span><span id="multi_heap_check__multi_heap_handle_t.b"></span><span class="target" id="multi__heap_8h_1ad1f307768d124bc73ec03a44ef28d740"></span>bool <code class="descname">multi_heap_check</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, bool <em>ბეჭდვის_შეცდომები</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv416multi_heap_check19multi_heap_handle_tb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეამოწმეთ გროვის მთლიანობა. </p>
<p>ამოწმებს გროვას და ამოწმებს გროვაში არსებული ყველა მონაცემთა სტრუქტურის სისწორეს. თუ რაიმე შეცდომა გამოვლინდა, შეცდომის სპეციფიკური შეტყობინება შეიძლება დაიბეჭდოს stderr-ში სურვილისამებრ. ბეჭდვის ქცევის გადაფარვა შესაძლებელია კომპილაცია ზე multi_heap_platform.h-ში MULTI_CHECK_FAIL_PRINTF-ის განსაზღვრით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>true if heap is valid, false otherwise. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">print_errors</span></code>თუ true-ა, შეცდომები დაიბეჭდება stderr-ში. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420multi_heap_free_size19multi_heap_handle_t">
<span id="_CPPv320multi_heap_free_size19multi_heap_handle_t"></span><span id="_CPPv220multi_heap_free_size19multi_heap_handle_t"></span><span id="multi_heap_free_size__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a31baeeba41b9560413af745b33c5b6b5"></span>size_t <code class="descname">multi_heap_free_size</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv420multi_heap_free_size19multi_heap_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უფასო გროვის ზომის დაბრუნება. </p>
<p>აბრუნებს გროვაში ხელმისაწვდომი ბაიტების რაოდენობას.</p>
<p>multi_heap_get_heap_info()-ის მიერ დაბრუნებული total_free_bytes წევრის ექვივალენტურია.</p>
<p>გაითვალისწინეთ, რომ გროვა შეიძლება ფრაგმენტირებული იყოს, ამიტომ ერთი malloc() ფუნქციის მაქსიმალური ზომა შეიძლება უფრო დაბალი იყოს. ამ ზომის გასაგებად იხილეთ multi_heap_get_heap_info() ფუნქციის მიერ დაბრუნებული largest_free_block წევრი.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Number of free bytes. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428multi_heap_minimum_free_size19multi_heap_handle_t">
<span id="_CPPv328multi_heap_minimum_free_size19multi_heap_handle_t"></span><span id="_CPPv228multi_heap_minimum_free_size19multi_heap_handle_t"></span><span id="multi_heap_minimum_free_size__multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a7073b215edc403edd4ef7083d8f86e13"></span>size_t <code class="descname">multi_heap_minimum_free_size</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv428multi_heap_minimum_free_size19multi_heap_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ სიცოცხლის განმავლობაში მინიმალური თავისუფალი გროვის ზომა. </p>
<p>multi_heap_get_info()-ის მიერ დაბრუნებული minimum_free_bytes წევრის ექვივალენტურია.</p>
<p>აბრუნებს multi_free_heap_size()-დან მითითებული გროვისთვის დაბრუნებული შესაძლო მნიშვნელობების სიცოცხლის განმავლობაში არსებულ „დაბალ წყლის ნიშნულს“.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Number of free bytes. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t">
<span id="_CPPv319multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t"></span><span id="_CPPv219multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t"></span><span id="multi_heap_get_info__multi_heap_handle_t.multi_heap_info_tP"></span><span class="target" id="multi__heap_8h_1aad3673c369c1efc02fd8aa1cbebcf713"></span>void <code class="descname">multi_heap_get_info</code><span class="sig-paren">(</span><a class="reference internal" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="multi_heap_handle_t">მრავალგროიანი სახელური</a> <em>გროვა</em>, <a class="reference internal" href="mem_alloc.html#_CPPv417multi_heap_info_t" title="multi_heap_info_t">multi_heap_info_t</a> *<em>ინფორმაცია</em><span class="sig-paren">)</span><a class="headerlink" href="mem_alloc.html#_CPPv419multi_heap_get_info19multi_heap_handle_tP17multi_heap_info_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული გროვის შესახებ მეტამონაცემების დაბრუნება. </p>
<p>ავსებს <a class="reference internal" href="mem_alloc.html#structmulti__heap__info__t"><span class="std std-ref">multi_heap_info_t</span></a> სტრუქტურა მითითებული გროვის შესახებ ინფორმაციით.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">heap</span></code>: რეგისტრირებული გროვისთვის მართვა. </li>
<li><code class="docutils literal notranslate"><span class="pre">info</span></code>: მაჩვენებელი სტრუქტურაზე, რომელიც უნდა შეივსოს გროვის მეტამონაცემებით. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="mem_alloc.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv417multi_heap_info_t">
<span id="_CPPv317multi_heap_info_t"></span><span id="_CPPv217multi_heap_info_t"></span><span id="multi_heap_info_t"></span><span class="target" id="structmulti__heap__info__t"></span><em class="property">სტრუქტურა </em><code class="descname">multi_heap_info_t</code><a class="headerlink" href="mem_alloc.html#_CPPv417multi_heap_info_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სტრუქტურა multi_heap_get_info-ს მეშვეობით გროვის მეტამონაცემებზე წვდომისთვის. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t16total_free_bytesE">
<span id="_CPPv3N17multi_heap_info_t16total_free_bytesE"></span><span id="_CPPv2N17multi_heap_info_t16total_free_bytesE"></span><span id="multi_heap_info_t::total_free_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1a579d218a5e7be434de0e06c4a5e2fc44"></span>size_t <code class="descname">total_free_bytes</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t16total_free_bytesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში თავისუფალი ბაიტების საერთო რაოდენობა. multi_free_heap_size()-ის ექვივალენტურია. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t21total_allocated_bytesE">
<span id="_CPPv3N17multi_heap_info_t21total_allocated_bytesE"></span><span id="_CPPv2N17multi_heap_info_t21total_allocated_bytesE"></span><span id="multi_heap_info_t::total_allocated_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1af7ac7bb9523d54bc65ff43ca695eaa4d"></span>size_t <code class="descname">total_allocated_bytes</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t21total_allocated_bytesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში მონაცემებზე გამოყოფილი ბაიტების საერთო რაოდენობა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t18largest_free_blockE">
<span id="_CPPv3N17multi_heap_info_t18largest_free_blockE"></span><span id="_CPPv2N17multi_heap_info_t18largest_free_blockE"></span><span id="multi_heap_info_t::largest_free_block__s"></span><span class="target" id="structmulti__heap__info__t_1ab1f0470a7a39d0ff6624aa3a51ebe314"></span>size_t <code class="descname">largest_free_block</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t18largest_free_blockE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში ყველაზე დიდი თავისუფალი ბლოკის ზომა. ეს არის ყველაზე დიდი malloc-ით დასაშვები ზომა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t18minimum_free_bytesE">
<span id="_CPPv3N17multi_heap_info_t18minimum_free_bytesE"></span><span id="_CPPv2N17multi_heap_info_t18minimum_free_bytesE"></span><span id="multi_heap_info_t::minimum_free_bytes__s"></span><span class="target" id="structmulti__heap__info__t_1aaae058568c1b0c400bf53060c64d1193"></span>size_t <code class="descname">minimum_free_bytes</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t18minimum_free_bytesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უფასო გროვის მინიმალური ზომა სიცოცხლის განმავლობაში. multi_minimum_free_heap_size()-ის ექვივალენტურია. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t16allocated_blocksE">
<span id="_CPPv3N17multi_heap_info_t16allocated_blocksE"></span><span id="_CPPv2N17multi_heap_info_t16allocated_blocksE"></span><span id="multi_heap_info_t::allocated_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1a216a36cb5c73cec2f2a1afafdbdb4727"></span>size_t <code class="descname">allocated_blocks</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t16allocated_blocksE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში გამოყოფილი (ცვლადი ზომის) ბლოკების რაოდენობა. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t11free_blocksE">
<span id="_CPPv3N17multi_heap_info_t11free_blocksE"></span><span id="_CPPv2N17multi_heap_info_t11free_blocksE"></span><span id="multi_heap_info_t::free_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1ab18daccada986848b88c9c61b06183a7"></span>size_t <code class="descname">free_blocks</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t11free_blocksE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში თავისუფალი ბლოკების რაოდენობა (ცვლადი ზომის). </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N17multi_heap_info_t12total_blocksE">
<span id="_CPPv3N17multi_heap_info_t12total_blocksE"></span><span id="_CPPv2N17multi_heap_info_t12total_blocksE"></span><span id="multi_heap_info_t::total_blocks__s"></span><span class="target" id="structmulti__heap__info__t_1a0298f4fdc59110fe56a29c2e130ea9f7"></span>size_t <code class="descname">total_blocks</code><a class="headerlink" href="mem_alloc.html#_CPPv4N17multi_heap_info_t12total_blocksE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გროვაში (ცვლადი ზომის) ბლოკების საერთო რაოდენობა. </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="mem_alloc.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv419multi_heap_handle_t">
<span id="_CPPv319multi_heap_handle_t"></span><span id="_CPPv219multi_heap_handle_t"></span><span id="multi_heap_handle_t"></span><span class="target" id="multi__heap_8h_1a051dfcd4b982e1c1d33930f96fb6539d"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> multi_heap_info *<code class="descname">multi_heap_handle_t</code><a class="headerlink" href="mem_alloc.html#_CPPv419multi_heap_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაუმჭვირვალე სახელური რეგისტრირებული გროვისთვის. </p>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="heap_debug.html" rel="next" title="Heap Memory Debugging">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="freertos_additions.html" rel="prev" title="FreeRTOS Additions"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>