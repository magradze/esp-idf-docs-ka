
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>ენერგიის მართვა — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="sleep_modes.html" rel="next" title="Sleep Modes"/>
<link href="perfmon.html" rel="prev" title="Performance Monitor"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/power_management.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/system/power_management"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/system/power_management.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">შენახვა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">სისტემა</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">აპლიკაციის სურათის ფორმატი</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse მენეჯერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">შეცდომის კოდები და დამხმარე ფუნქციები</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_pthread.html">ESP pthread</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">მოვლენების ციკლის ბიბლიოთეკა</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos.html">უფასო RTOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">უფასო RTOS დამატებები</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">გროვის მეხსიერების განაწილება</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">გროვის მეხსიერების გამართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">მაღალი გარჩევადობის ტაიმერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem (დიდი გარე SPI ოპერატიული მეხსიერება) API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">პროცესორებს შორის ზარი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_expression_with_stack.html">ფუნქციის გამოძახება გარე სტეკით</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">შეწყვეტის განაწილება</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">ლოგირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="system.html">სხვადასხვა სისტემა, API წმ</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">უსადენო განახლებები (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">შესრულების მონიტორი</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="power_management.html#">ენერგიის მართვა</a><ul>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#overview">მიმოხილვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#configuration">კონფიგურაცია</a></li>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#power-management-locks">ენერგიის მართვის საკეტები</a></li>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#esp32-power-management-algorithm">ESP32 ენერგიის მართვის ალგორითმი</a></li>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#dynamic-frequency-scaling-and-peripheral-drivers">დინამიური სიხშირის მასშტაბირება და პერიფერიული დრაივერები</a></li>
<li class="toctree-l4"><a class="reference internal" href="power_management.html#api-reference">API მითითება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">ძილის რეჟიმები</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">მეთვალყურე ძაღლები</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">სისტემის დრო</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">სისტემის API</a> »</li>
<li>ენერგიის მართვა</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/system/power_management.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="power-management">
<h1>ენერგიის მართვა<a class="headerlink" href="power_management.html#power-management" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://espressif-docs.readthedocs-hosted.com/projects/esp-idf/zh_CN/latest/api-reference/system/power_management.html">[中文]</a></p>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="power_management.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ESP-IDF ში შემავალ ენერგიის მართვის ალგორითმს შეუძლია დაარეგულიროს მოწინავე პერიფერიული ავტობუსის (APB) სიხშირე, CPU სიხშირე და გადაიყვანოს ჩიპი მსუბუქი ძილის რეჟიმში, რათა აპლიკაცია გაუშვას ყველაზე დაბალი შესაძლო ენერგომოხმარებით, აპლიკაციის კომპონენტი s მოთხოვნების გათვალისწინებით.</p>
<p>განაცხადის კომპონენტი -ს შეუძლია გამოხატოს თავისი მოთხოვნები ენერგიის მართვის ბლოკირების შექმნითა და შეძენით.</p>
<p>მაგალითად:</p>
<ul class="simple">
<li>APB-დან დაქოქილი პერიფერიული მოწყობილობის დრაივერს შეუძლია მოითხოვოს APB სიხშირის 80 MHz-ზე დაყენება პერიფერიული მოწყობილობის გამოყენებისას.</li>
<li>RTOS შეუძლია მოითხოვოს CPU-ს მუშაობა ყველაზე მაღალი კონფიგურირებული სიხშირით, სანამ არსებობს გასაშვებად მზად დავალებები.</li>
<li>პერიფერიული მოწყობილობის დრაივერს შეიძლება დასჭირდეს შეფერხებების ჩართვა, რაც ნიშნავს, რომ მას მოუწევს მსუბუქი ძილის რეჟიმის გამორთვის მოთხოვნა.</li>
</ul>
<p>რადგან უფრო მაღალი APB ან CPU სიხშირეების მოთხოვნა ან მსუბუქი ძილის რეჟიმის გამორთვა იწვევს დენის მოხმარების ზრდას, გთხოვთ, კომპონენტი ის მიერ ენერგიის მართვის ბლოკირების გამოყენება მინიმუმამდე დაიყვანოთ.</p>
</div>
<div class="section" id="configuration">
<h2>კონფიგურაცია<a class="headerlink" href="power_management.html#configuration" title="Permalink to this headline">¶</a></h2>
<p>ენერგიის მართვის ჩართვა შესაძლებელია კომპილაცია დროს, ოფციის გამოყენებით <a class="reference internal" href="../kconfig.html#config-pm-enable"><span class="std std-ref">CONFIG_PM_ENABLE</span></a>.</p>
<p>ენერგიის მართვის ფუნქციების ჩართვას თან ახლავს შეფერხების შეყოვნების გაზრდა. დამატებითი შეყოვნება დამოკიდებულია რიგ ფაქტორებზე, როგორიცაა პროცესორის სიხშირე, ერთბირთვიანი/ორბირთვიანი რეჟიმი, საჭიროა თუ არა სიხშირის შეცვლა. მინიმალური დამატებითი შეყოვნებაა 0.2 აშშ დოლარი (როდესაც პროცესორის სიხშირეა 240 MHz და სიხშირის მასშტაბირება არ არის ჩართული). მაქსიმალური დამატებითი შეყოვნებაა 40 აშშ დოლარი (როდესაც სიხშირის მასშტაბირება ჩართულია და შეფერხებისას ხდება 40 MHz-დან 80 MHz-ზე გადართვა).</p>
<p>დინამიური სიხშირის სკალირება (DFS) და ავტომატური მსუბუქი ძილის ჩართვა შესაძლებელია აპლიკაციაში ფუნქციის გამოძახებით. <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a>მისი არგუმენტი არის სტრუქტურა, რომელიც განსაზღვრავს სიხშირის მასშტაბირების პარამეტრებს, <a class="reference internal" href="power_management.html#_CPPv421esp_pm_config_esp32_t" title="esp_pm_config_esp32_t"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">esp_pm_config_esp32_t</span></code></a>ამ სტრუქტურაში სამი ველის ინიციალიზაციაა საჭირო:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">max_freq_mhz</span></code>მაქსიმალური CPU სიხშირე MHz-ში, ანუ სიხშირე, რომელიც გამოიყენება, როდესაც <code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code> დაბლოკვა მიღებულია. ეს ველი, როგორც წესი, დაყენებული იქნება <a class="reference internal" href="../kconfig.html#config-esp32-default-cpu-freq-mhz"><span class="std std-ref">CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">min_freq_mhz</span></code>მინიმალური CPU სიხშირე MHz-ში, ანუ სიხშირე, რომელიც გამოიყენება მხოლოდ მაშინ, როდესაც <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> დაბლოკვა მიღებულია. ეს ველი შეიძლება დაყენდეს XTAL სიხშირის მნიშვნელობად, ან XTAL სიხშირის მთელ რიცხვზე გაყოფით. გაითვალისწინეთ, რომ 10 MHz არის ყველაზე დაბალი სიხშირე, რომელზეც შესაძლებელია 1 MHz-ის ნაგულისხმევი REF_TICK საათის გენერირება.</li>
<li><code class="docutils literal notranslate"><span class="pre">light_sleep_enable</span></code>: ავტომატურად უნდა გადავიდეს თუ არა სისტემა მსუბუქი ძილის რეჟიმში, როდესაც საკეტები არ არის მიღებული (<code class="docutils literal notranslate"><span class="pre">true</span></code>/<code class="docutils literal notranslate"><span class="pre">false</span></code>).</li>
</ul>
<p>ალტერნატიულად, თუ ჩართავთ პარამეტრს <a class="reference internal" href="../kconfig.html#config-pm-dfs-init-auto"><span class="std std-ref">CONFIG_PM_DFS_INIT_AUTO</span></a> menuconfig ში, CPU-ს მაქსიმალური სიხშირე განისაზღვრება <a class="reference internal" href="../kconfig.html#config-esp32-default-cpu-freq-mhz"><span class="std std-ref">CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</span></a> პარამეტრის მიხედვით, CPU-ს მინიმალური სიხშირე XTAL სიხშირეზე იქნება დაფიქსირებული.</p>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">ავტომატური მსუბუქი ძილის რეჟიმი დაფუძნებულია Free RTOS Tickless Idle ფუნქციონალზე. თუ ავტომატური მსუბუქი ძილის რეჟიმი მოთხოვნილია ოფციის დროს <a class="reference internal" href="../kconfig.html#config-freertos-use-tickless-idle"><span class="std std-ref">CONFIG_FREE RTOS _USE_TICKLESS_IDLE</span></a> არ არის ჩართული menuconfig ში, <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a> შეცდომას დააბრუნებს <cite>ESP_ERR_NOT_SUPPORTED</cite>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">შენიშვნა</p>
<p class="last">მსუბუქი ძილის დროს, პერიფერიული მოწყობილობები საათის კარიბჭით არის დარეგულირებული და შეწყვეტები ( GPIO 7-დან და შიდა პერიფერიული მოწყობილობებიდან) არ გენერირდება. გაღვიძების წყარო აღწერილია <a class="reference internal" href="sleep_modes.html"><span class="doc">ძილის რეჟიმები</span></a> დოკუმენტაციის გამოყენება შესაძლებელია მსუბუქი ძილის მდგომარეობიდან გამოღვიძების გასააქტიურებლად. მაგალითად, EXT0 და EXT1 გამოღვიძების წყაროების გამოყენება შესაძლებელია ჩიპის გასაღვიძებლად GPIO საშუალებით.</p>
</div>
</div>
<div class="section" id="power-management-locks">
<h2>ენერგიის მართვის საკეტები<a class="headerlink" href="power_management.html#power-management-locks" title="Permalink to this headline">¶</a></h2>
<p>აპლიკაციებს აქვთ დაბლოკვის მოპოვების/მოხსნის შესაძლებლობა ენერგიის მართვის ალგორითმის გასაკონტროლებლად. როდესაც აპლიკაცია იღებს დაბლოკვას, ენერგიის მართვის ალგორითმის მოქმედება შეზღუდულია ქვემოთ აღწერილი წესით. როდესაც დაბლოკვა მოიხსნება, ასეთი შეზღუდვები იხსნება.</p>
<p>ენერგიის მართვის საკეტებს აქვთ მოპოვების/გათავისუფლების მრიცხველები. თუ საკეტი რამდენჯერმე იქნა მოპოვებული, მასთან დაკავშირებული შეზღუდვების მოსახსნელად ის იმავე რაოდენობის ჯერ უნდა გათავისუფლდეს.</p>
<p>ESP32 მხარს უჭერს ქვემოთ მოცემულ ცხრილში აღწერილ სამ ტიპის საკეტს.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%"/>
<col width="85%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">საკეტი</th>
<th class="head">აღწერა</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code></td>
<td>მოითხოვს CPU-ს სიხშირის მაქსიმალურ მნიშვნელობას, რომელიც მითითებულია <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a>ESP32-ისთვის, ეს მნიშვნელობა შეიძლება დაყენდეს 80 MHz, 160 MHz ან 240 MHz-ზე.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code></td>
<td>მოითხოვს APB სიხშირის მაქსიმალურ მხარდაჭერილ მნიშვნელობას. ESP32-ისთვის ეს არის 80 MHz.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ESP_PM_NO_LIGHT_SLEEP</span></code></td>
<td>გამორთავს მსუბუქ ძილზე ავტომატურ გადართვას.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="esp32-power-management-algorithm">
<h2>ESP32 ენერგიის მართვის ალგორითმი<a class="headerlink" href="power_management.html#esp32-power-management-algorithm" title="Permalink to this headline">¶</a></h2>
<p>ქვემოთ მოცემულ ცხრილში ნაჩვენებია, თუ როგორ შეიცვლება CPU და APB სიხშირეები, თუ ჩართულია დინამიური სიხშირის მასშტაბირება. თქვენ შეგიძლიათ მიუთითოთ CPU-ს მაქსიმალური სიხშირე შემდეგი ხერხებით: <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a> ან <a class="reference internal" href="../kconfig.html#config-esp32-default-cpu-freq-mhz"><span class="std std-ref">CONFIG_ESP32_DEFAULT_CPU_FREQ_MHZ</span></a>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%"/>
<col width="43%"/>
<col width="41%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>მაქსიმალური CPU სიხშირის დაყენება</td>
<td>საკეტის მოპოვება</td>
<td>CPU და APB სიხშირეები</td>
</tr>
<tr class="row-even"><td rowspan="2">240</td>
<td><div class="first last line-block">
<div class="line">Any of <code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code></div>
<div class="line">or <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> acquired</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">CPU: 240 MHz</div>
<div class="line">APB: 80 MHz</div>
</div>
</td>
</tr>
<tr class="row-odd"><td>არცერთი</td>
<td>ორივე სიხშირის მინიმალური მნიშვნელობები დაყენებულია <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a></td>
</tr>
<tr class="row-even"><td rowspan="3">160</td>
<td><code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code> შეძენილი</td>
<td><div class="first last line-block">
<div class="line">CPU: 160 MHz</div>
<div class="line">APB: 80 MHz</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code> შეძენილი,
<code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> არ არის შეძენილი</td>
<td><div class="first last line-block">
<div class="line">CPU: 80 MHz</div>
<div class="line">APB: 80 MHz</div>
</div>
</td>
</tr>
<tr class="row-even"><td>არცერთი</td>
<td>ორივე სიხშირის მინიმალური მნიშვნელობები დაყენებულია <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a></td>
</tr>
<tr class="row-odd"><td rowspan="2">80</td>
<td><div class="first last line-block">
<div class="line">Any of <code class="docutils literal notranslate"><span class="pre">ESP_PM_CPU_FREQ_MAX</span></code></div>
<div class="line">or <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> acquired</div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">CPU: 80 MHz</div>
<div class="line">APB: 80 MHz</div>
</div>
</td>
</tr>
<tr class="row-even"><td>არცერთი</td>
<td>ორივე სიხშირის მინიმალური მნიშვნელობები დაყენებულია <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a></td>
</tr>
</tbody>
</table>
<p>თუ არცერთი საკეტი არ არის მიღებული და მსუბუქი ძილი ჩართულია ზარში <a class="reference internal" href="power_management.html#_CPPv416esp_pm_configurePKv" title="esp_pm_configure"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_pm_configure()</span></code></a>, სისტემა გადავა მსუბუქი ძილის რეჟიმში. მსუბუქი ძილის ხანგრძლივობა განისაზღვრება შემდეგით:</p>
<ul class="simple">
<li>თავისუფალი RTOS დავალებები დაბლოკილია სასრული ვადით</li>
<li>ტაიმერები რეგისტრირებულია <a class="reference internal" href="esp_timer.html"><span class="doc">მაღალი გარჩევადობის ტაიმერი</span></a> API სთ</li>
</ul>
<p>მსუბუქი ძილის ხანგრძლივობა შეირჩევა იმისათვის, რომ ჩიპი გააღვიძოს უახლოეს მოვლენამდე (დავალების განბლოკვა ან ტაიმერის გასვლა).</p>
</div>
<div class="section" id="dynamic-frequency-scaling-and-peripheral-drivers">
<h2>დინამიური სიხშირის მასშტაბირება და პერიფერიული დრაივერები<a class="headerlink" href="power_management.html#dynamic-frequency-scaling-and-peripheral-drivers" title="Permalink to this headline">¶</a></h2>
<p>როდესაც DFS ჩართულია, APB სიხშირის რამდენჯერმე შეცვლა შესაძლებელია ერთი RTOS განმავლობაში. APB სიხშირის ცვლილება გავლენას არ ახდენს ზოგიერთი პერიფერიული მოწყობილობის მუშაობაზე, მაშინ როცა სხვა პერიფერიულ მოწყობილობებს შეიძლება პრობლემები შეექმნათ. მაგალითად, ტაიმერის ჯგუფის პერიფერიული ტაიმერები გააგრძელებენ დათვლას, თუმცა, მათი დათვლის სიჩქარე შეიცვლება APB სიხშირის პროპორციულად.</p>
<p>შემდეგი პერიფერიული მოწყობილობები ნორმალურად მუშაობენ მაშინაც კი, როდესაც APB სიხშირე იცვლება:</p>
<ul class="simple">
<li><strong>UART</strong>: თუ REF_TICK გამოიყენება როგორც საათის წყარო. იხილეთ <cite>use_ref_tick</cite> წევრი <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">uart_config_t</span></code>.</li>
<li><strong>LEDC</strong>: თუ REF_TICK გამოიყენება როგორც საათის წყარო. იხილეთ <a class="reference internal" href="../peripherals/ledc.html#_CPPv417ledc_timer_configPK19ledc_timer_config_t" title="ledc_timer_config"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">ledc_timer_config()</span></code></a> ფუნქცია.</li>
<li><strong>RMT</strong>: თუ REF_TICK გამოიყენება როგორც საათის წყარო. მიუხედავად იმისა, რომ დრაივერი არ უჭერს მხარს REF_TICK-ს, ამ ფუნქციის ჩართვა შესაძლებელია წაშლით <code class="docutils literal notranslate"><span class="pre">RMT_REF_ALWAYS_ON_CHx</span></code> ბიტი შესაბამისი არხისთვის.</li>
</ul>
<p>ამჟამად, შემდეგი პერიფერიული მოწყობილობების დრაივერები იცნობენ DFS-ს და გამოიყენებენ მას: <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> დაბლოკვა ტრანზაქციის მთელი ხანგრძლივობის განმავლობაში:</p>
<ul class="simple">
<li>SPI-ის ოსტატი</li>
<li>I2C</li>
<li>I2S (თუ APLL საათი გამოიყენება, მაშინ ის გამოიყენებს <code class="docutils literal notranslate"><span class="pre">ESP_PM_NO_LIGHT_SLEEP</span></code> საკეტი)</li>
<li>SDMMC</li>
</ul>
<p>შემდეგი მძღოლები დაიკავებენ <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> დაბლოკვა დრაივერის ჩართვისას:</p>
<ul class="simple">
<li><strong>SPI მონა</strong>: ზარებს შორის <a class="reference internal" href="../peripherals/spi_slave.html#_CPPv420spi_slave_initialize17spi_host_device_tPK16spi_bus_config_tPK28spi_slave_interface_config_ti" title="spi_slave_initialize"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_slave_initialize()</span></code></a> და <a class="reference internal" href="../peripherals/spi_slave.html#_CPPv414spi_slave_free17spi_host_device_t" title="spi_slave_free"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">spi_slave_free()</span></code></a>.</li>
<li><strong>Ethernet</strong>: ზარებს შორის <a class="reference internal" href="../network/esp_eth.html#_CPPv422esp_eth_driver_installPK16esp_eth_config_tP16esp_eth_handle_t" title="esp_eth_driver_install"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_eth_driver_install()</span></code></a> და <a class="reference internal" href="../network/esp_eth.html#_CPPv424esp_eth_driver_uninstall16esp_eth_handle_t" title="esp_eth_driver_uninstall"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_eth_driver_uninstall()</span></code></a>.</li>
<li><strong>Wi-Fi</strong>: ზარებს შორის <a class="reference internal" href="../network/esp_wifi.html#_CPPv414esp_wifi_startv" title="esp_wifi_start"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_start()</span></code></a> და <a class="reference internal" href="../network/esp_wifi.html#_CPPv413esp_wifi_stopv" title="esp_wifi_stop"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_wifi_stop()</span></code></a>თუ მოდემის ძილის რეჟიმი ჩართულია, საკეტი მოიხსნება იმ პერიოდებისთვის, როდესაც რადიო გამორთულია.</li>
<li><strong>Bluetooth</strong>: ზარებს შორის <a class="reference internal" href="../bluetooth/controller_vhci.html#_CPPv424esp_bt_controller_enable13esp_bt_mode_t" title="esp_bt_controller_enable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_bt_controller_enable()</span></code></a> და <a class="reference internal" href="../bluetooth/controller_vhci.html#_CPPv425esp_bt_controller_disablev" title="esp_bt_controller_disable"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">esp_bt_controller_disable()</span></code></a>თუ Bluetooth მოდემის ძილის რეჟიმი ჩართულია, <code class="docutils literal notranslate"><span class="pre">ESP_PM_APB_FREQ_MAX</span></code> რადიოს გამორთვის პერიოდის განმავლობაში საკეტი მოიხსნება. თუმცა <code class="docutils literal notranslate"><span class="pre">ESP_PM_NO_LIGHT_SLEEP</span></code> საკეტი კვლავ შენარჩუნებული იქნება, თუ <a class="reference internal" href="../kconfig.html#config-btdm-low-power-clock"><span class="std std-ref">CONFIG_BTDM_LOW_POWER_CLOCK</span></a> პარამეტრი დაყენებულია „გარე 32kHz კრისტალზე“.</li>
<li><strong>შეიძლება</strong>: ზარებს შორის <a class="reference internal" href="../peripherals/can.html#_CPPv418can_driver_installPK20can_general_config_tPK19can_timing_config_tPK19can_filter_config_t" title="can_driver_install"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">can_driver_install()</span></code></a> და <a class="reference internal" href="../peripherals/can.html#_CPPv420can_driver_uninstallv" title="can_driver_uninstall"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">can_driver_uninstall()</span></code></a>.</li>
</ul>
<p>შემდეგ პერიფერიულ დრაივერებს ჯერ არ აქვთ ინფორმაცია DFS-ის შესახებ. აპლიკაციებმა საჭიროების შემთხვევაში თავად უნდა მოიპოვონ/მოხსნან საკეტები:</p>
<ul class="simple">
<li>MCPWM</li>
<li>PCNT</li>
<li>სიგმა-დელტა</li>
<li>ტაიმერის ჯგუფი</li>
</ul>
</div>
<div class="section" id="api-reference">
<h2>API მითითება<a class="headerlink" href="power_management.html#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="power_management.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/esp_common/include/esp_pm.h">esp_common/include/esp_pm.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="power_management.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv416esp_pm_configurePKv">
<span id="_CPPv316esp_pm_configurePKv"></span><span id="_CPPv216esp_pm_configurePKv"></span><span id="esp_pm_configure__voidCP"></span><span class="target" id="esp__pm_8h_1a44155b70884b6475fc0c43db7f140095"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_configure</code><span class="sig-paren">(</span><em class="property">კონსტ</em> void *<em>კონფიგურაცია</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv416esp_pm_configurePKv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააყენეთ იმპლემენტაციისთვის სპეციფიკური ენერგიის მართვის კონფიგურაცია. </p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_INVALID_ARG თუ კონფიგურაციის მნიშვნელობები არასწორია</li>
<li>ESP_ERR_NOT_SUPPORTED, თუ მნიშვნელობების გარკვეული კომბინაცია არ არის მხარდაჭერილი, ან თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში. </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">config</span></code>: იმპლემენტაციის სპეციფიკური კონფიგურაციის სტრუქტურის მითითება (მაგ. esp_pm_config_esp32) </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_pm_lock_create18esp_pm_lock_type_tiPKcP20esp_pm_lock_handle_t">
<span id="_CPPv318esp_pm_lock_create18esp_pm_lock_type_tiPKcP20esp_pm_lock_handle_t"></span><span id="_CPPv218esp_pm_lock_create18esp_pm_lock_type_tiPKcP20esp_pm_lock_handle_t"></span><span id="esp_pm_lock_create__esp_pm_lock_type_t.i.cCP.esp_pm_lock_handle_tP"></span><span class="target" id="esp__pm_8h_1ae42237e0138a098f7c7159c28ee3cdd5"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_lock_create</code><span class="sig-paren">(</span><a class="reference internal" href="power_management.html#_CPPv418esp_pm_lock_type_t" title="esp_pm_lock_type_t">esp_pm_lock_type_t</a> <em>საკეტის_ტიპი</em>, int <em>არგუმენტი</em>, <em class="property">კონსტ</em> char *<em>სახელი</em>, <a class="reference internal" href="power_management.html#_CPPv420esp_pm_lock_handle_t" title="esp_pm_lock_handle_t">esp_pm_lock_handle_t</a> *<em>გაუმკლავებელი</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv418esp_pm_lock_create18esp_pm_lock_type_tiPKcP20esp_pm_lock_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გარკვეული ენერგიის მართვის პარამეტრისთვის დაბლოკვის სახელურის ინიციალიზაცია. </p>
<p>როდესაც საკეტი იქმნება, თავდაპირველად ის არ იკავებენ. საკეტის ასაღებად გამოიძახეთ esp_pm_lock_acquire.</p>
<p>ეს ფუნქცია არ უნდა გამოიძახოს ISR-დან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NO_MEM, თუ საკეტის სტრუქტურის გამოყოფა შეუძლებელია</li>
<li>ESP_ERR_INVALID_ARG თუ out_handle არის NULL ან ტიპის არგუმენტი არასწორია</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">lock_type</span></code>ენერგიის მართვის შეზღუდვა, რომელიც საკეტმა უნდა აკონტროლოს </li>
<li><code class="docutils literal notranslate"><span class="pre">arg</span></code>: არგუმენტი, მნიშვნელობა დამოკიდებულია lock_type-ზე, იხილეთ esp_pm_lock_type_t </li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: საკეტის იდენტიფიცირების ნებისმიერი სტრიქონი (მაგ. „wifi“ ან „spi“). გამოიყენება esp_pm_dump_locks ფუნქციის მიერ არსებული საკეტების სიის დასათვლელად. შეიძლება დაყენდეს NULL-ზე. თუ არ არის დაყენებული NULL-ზე, უნდა მიუთითებდეს სტრიქონზე, რომელიც ძალაშია საკეტის მთელი სიცოცხლის განმავლობაში. </li>
<li><code class="docutils literal notranslate"><span class="pre">out_handle</span></code>: ამ ფუნქციიდან დაბრუნებული სახელური. გამოიყენეთ ეს სახელური esp_pm_lock_delete, esp_pm_lock_acquire, esp_pm_lock_release-ის გამოძახებისას. არ უნდა იყოს NULL. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419esp_pm_lock_acquire20esp_pm_lock_handle_t">
<span id="_CPPv319esp_pm_lock_acquire20esp_pm_lock_handle_t"></span><span id="_CPPv219esp_pm_lock_acquire20esp_pm_lock_handle_t"></span><span id="esp_pm_lock_acquire__esp_pm_lock_handle_t"></span><span class="target" id="esp__pm_8h_1af232756882d8732a73b88f40e0ab4572"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_lock_acquire</code><span class="sig-paren">(</span><a class="reference internal" href="power_management.html#_CPPv420esp_pm_lock_handle_t" title="esp_pm_lock_handle_t">esp_pm_lock_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv419esp_pm_lock_acquire20esp_pm_lock_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აიღეთ ენერგიის მართვის საკეტი. </p>
<p>დაბლოკვის აღების შემდეგ, ენერგიის მართვის ალგორითმი არ გადავა esp_pm_lock_create-ის გამოძახებისას მითითებულ რეჟიმში ან რომელიმე უფრო დაბალი სიმძლავრის რეჟიმზე (&amp;#39;mode&amp;#39;-ის უფრო მაღალი რიცხვითი მნიშვნელობები).</p>
<p>საკეტი რეკურსიული ხასიათისაა, იმ გაგებით, რომ თუ esp_pm_lock_acquire გამოიძახება რამდენჯერმე, საკეტის გასახსნელად esp_pm_lock_release უნდა გამოიძახოთ იმავე რაოდენობის ჯერ.</p>
<p>ეს ფუნქცია შეიძლება გამოიძახონ ISR-დან.</p>
<p>ეს ფუნქცია არ არის ძაფებისთვის უსაფრთხო wrt გამოძახებებისთვის სხვა esp_pm_lock_* ფუნქციებზე იმავე სახელურისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_INVALID_ARG თუ სახელური არასწორია</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: esp_pm_lock_create ფუნქციიდან მიღებული სახელური </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419esp_pm_lock_release20esp_pm_lock_handle_t">
<span id="_CPPv319esp_pm_lock_release20esp_pm_lock_handle_t"></span><span id="_CPPv219esp_pm_lock_release20esp_pm_lock_handle_t"></span><span id="esp_pm_lock_release__esp_pm_lock_handle_t"></span><span class="target" id="esp__pm_8h_1a822861449d5fda28c2dd47d4efb0902f"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_lock_release</code><span class="sig-paren">(</span><a class="reference internal" href="power_management.html#_CPPv420esp_pm_lock_handle_t" title="esp_pm_lock_handle_t">esp_pm_lock_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv419esp_pm_lock_release20esp_pm_lock_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაათავისუფლეთ აღებული საკეტი esp_pm_lock_acquire-ის გამოყენებით. </p>
<p>ამ ფუნქციის გამოძახება ხსნის საკეტის აღებისას დაყენებულ ენერგიის მართვის შეზღუდვებს.</p>
<p>საკეტები რეკურსიული ხასიათისაა, ამიტომ თუ esp_pm_lock_acquire გამოიძახება რამდენჯერმე, საკეტის გასათავისუფლებლად esp_pm_lock_release უნდა გამოიძახოთ იმავე რაოდენობის ჯერ.</p>
<p>ეს ფუნქცია შეიძლება გამოიძახონ ISR-დან.</p>
<p>ეს ფუნქცია არ არის ძაფებისთვის უსაფრთხო wrt გამოძახებებისთვის სხვა esp_pm_lock_* ფუნქციებზე იმავე სახელურისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_INVALID_ARG თუ სახელური არასწორია</li>
<li>ESP_ERR_INVALID_STATE თუ საკეტი არ არის მოპოვებული</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: esp_pm_lock_create ფუნქციიდან მიღებული სახელური </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418esp_pm_lock_delete20esp_pm_lock_handle_t">
<span id="_CPPv318esp_pm_lock_delete20esp_pm_lock_handle_t"></span><span id="_CPPv218esp_pm_lock_delete20esp_pm_lock_handle_t"></span><span id="esp_pm_lock_delete__esp_pm_lock_handle_t"></span><span class="target" id="esp__pm_8h_1a4c24f2a8ee647d6ec51faf38a83b62d0"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_lock_delete</code><span class="sig-paren">(</span><a class="reference internal" href="power_management.html#_CPPv420esp_pm_lock_handle_t" title="esp_pm_lock_handle_t">esp_pm_lock_handle_t</a> <em>სახელური</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv418esp_pm_lock_delete20esp_pm_lock_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>esp_pm_lock-ის გამოყენებით შექმნილი საკეტის წაშლა. </p>
<p>ამ ფუნქციის გამოძახებამდე საკეტი უნდა მოიხსნას.</p>
<p>ეს ფუნქცია არ უნდა გამოიძახოს ISR-დან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_INVALID_ARG, თუ სახელურის არგუმენტი NULL-ია</li>
<li>ESP_ERR_INVALID_STATE თუ საკეტი კვლავ შეძენილია</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">handle</span></code>: esp_pm_lock_create ფუნქციიდან მიღებული სახელური </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417esp_pm_dump_locksP4FILE">
<span id="_CPPv317esp_pm_dump_locksP4FILE"></span><span id="_CPPv217esp_pm_dump_locksP4FILE"></span><span id="esp_pm_dump_locks__FILEP"></span><span class="target" id="esp__pm_8h_1a833eb396e9e828a769ed891d058d5913"></span><a class="reference internal" href="esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">esp_pm_dump_locks</code><span class="sig-paren">(</span>FILE *<em>ნაკადი</em><span class="sig-paren">)</span><a class="headerlink" href="power_management.html#_CPPv417esp_pm_dump_locksP4FILE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ყველა საკეტის სიის stderr-ში გადატანა</p>
<p>ეს ფუნქცია esp_pm_lock_create-ის გამოყენებით შექმნილი ბლოკირების შესახებ გამართვა ინფორმაციას გამომავალ ნაკადში აგზავნის.</p>
<p>ეს ფუნქცია არ უნდა გამოიძახოს ISR-დან. თუ esp_pm_lock_acquire/release გამოიძახება ამ ფუნქციის გაშვებისას, შესაძლოა არათანმიმდევრული შედეგები მოჰყვეს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK წარმატების შემთხვევაში</li>
<li>ESP_ERR_NOT_SUPPORTED თუ CONFIG_PM_ENABLE არ არის ჩართული sdkconfig-ში </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">stream</span></code>: ნაკადი ინფორმაციის დასაბეჭდად; კონსოლზე დასაბეჭდად გამოიყენეთ stdout ან stderr; სტრიქონულ ბუფერზე დასაბეჭდად გამოიყენეთ fmemopen/open_memstream. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="power_management.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv420esp_pm_lock_handle_t">
<span id="_CPPv320esp_pm_lock_handle_t"></span><span id="_CPPv220esp_pm_lock_handle_t"></span><span id="esp_pm_lock_handle_t"></span><span class="target" id="esp__pm_8h_1a21da52d75f3be5398817602b196b6a63"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> esp_pm_lock *<code class="descname">esp_pm_lock_handle_t</code><a class="headerlink" href="power_management.html#_CPPv420esp_pm_lock_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ენერგიის მართვის საკეტის გაუმჭვირვალე სახელური. </p>
</dd></dl>
</div>
<div class="section" id="enumerations">
<h3>ჩამოთვლები<a class="headerlink" href="power_management.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv418esp_pm_lock_type_t">
<span id="_CPPv318esp_pm_lock_type_t"></span><span id="_CPPv218esp_pm_lock_type_t"></span><span id="esp_pm_lock_type_t"></span><span class="target" id="esp__pm_8h_1afbfc19b34963b4af9bd297511e395a65"></span><em class="property">ჩამოთვლა </em><code class="descname">esp_pm_lock_type_t</code><a class="headerlink" href="power_management.html#_CPPv418esp_pm_lock_type_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ენერგიის მართვის შეზღუდვები. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv419ESP_PM_CPU_FREQ_MAX">
<span id="_CPPv319ESP_PM_CPU_FREQ_MAX"></span><span id="_CPPv219ESP_PM_CPU_FREQ_MAX"></span><span class="target" id="esp__pm_8h_1afbfc19b34963b4af9bd297511e395a65a11bc9d01585a00c073bdf74905a398aa"></span><code class="descname">ESP_PM_CPU_FREQ_MAX</code><a class="headerlink" href="power_management.html#_CPPv419ESP_PM_CPU_FREQ_MAX" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოითხოვეთ, რომ CPU-ს სიხშირე იყოს esp_pm_configure-ის მეშვეობით დაყენებული მაქსიმალური მნიშვნელობის. არგუმენტი არ გამოიყენება და უნდა იყოს 0-ზე დაყენებული. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv419ESP_PM_APB_FREQ_MAX">
<span id="_CPPv319ESP_PM_APB_FREQ_MAX"></span><span id="_CPPv219ESP_PM_APB_FREQ_MAX"></span><span class="target" id="esp__pm_8h_1afbfc19b34963b4af9bd297511e395a65a589cd59500c1e2360fbe174c9c183fde"></span><code class="descname">ESP_PM_APB_FREQ_MAX</code><a class="headerlink" href="power_management.html#_CPPv419ESP_PM_APB_FREQ_MAX" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოითხოვეთ, რომ APB სიხშირე იყოს ჩიპის მიერ მხარდაჭერილი მაქსიმალური მნიშვნელობის. არგუმენტი არ გამოიყენება და უნდა იყოს 0-ზე დაყენებული. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv421ESP_PM_NO_LIGHT_SLEEP">
<span id="_CPPv321ESP_PM_NO_LIGHT_SLEEP"></span><span id="_CPPv221ESP_PM_NO_LIGHT_SLEEP"></span><span class="target" id="esp__pm_8h_1afbfc19b34963b4af9bd297511e395a65a1f0a8265811148c862a987eb32330ac4"></span><code class="descname">ESP_PM_NO_LIGHT_SLEEP</code><a class="headerlink" href="power_management.html#_CPPv421ESP_PM_NO_LIGHT_SLEEP" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სისტემის მსუბუქი ძილის რეჟიმიდან გადასვლის თავიდან აცილება. არგუმენტი არ გამოიყენება და უნდა იყოს 0-ზე დაყენებული. </p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="id1">
<h3>სათაურის ფაილი<a class="headerlink" href="power_management.html#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/esp32/include/esp32/pm.h">esp32/include/esp32/pm.h</a></li>
</ul>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="power_management.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv421esp_pm_config_esp32_t">
<span id="_CPPv321esp_pm_config_esp32_t"></span><span id="_CPPv221esp_pm_config_esp32_t"></span><span id="esp_pm_config_esp32_t"></span><span class="target" id="structesp__pm__config__esp32__t"></span><em class="property">სტრუქტურა </em><code class="descname">esp_pm_config_esp32_t</code><a class="headerlink" href="power_management.html#_CPPv421esp_pm_config_esp32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ენერგიის მართვის კონფიგურაცია ESP32-ისთვის. </p>
<p>ამ სტრუქტურის მაჩვენებელი გადაეცით esp_pm_configure ფუნქციის არგუმენტად. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N21esp_pm_config_esp32_t12max_freq_mhzE">
<span id="_CPPv3N21esp_pm_config_esp32_t12max_freq_mhzE"></span><span id="_CPPv2N21esp_pm_config_esp32_t12max_freq_mhzE"></span><span id="esp_pm_config_esp32_t::max_freq_mhz__i"></span><span class="target" id="structesp__pm__config__esp32__t_1a55e5303f8a7d89687f6229fc49a2e3aa"></span>int <code class="descname">max_freq_mhz</code><a class="headerlink" href="power_management.html#_CPPv4N21esp_pm_config_esp32_t12max_freq_mhzE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მაქსიმალური CPU სიხშირე, MHz-ში </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N21esp_pm_config_esp32_t12min_freq_mhzE">
<span id="_CPPv3N21esp_pm_config_esp32_t12min_freq_mhzE"></span><span id="_CPPv2N21esp_pm_config_esp32_t12min_freq_mhzE"></span><span id="esp_pm_config_esp32_t::min_freq_mhz__i"></span><span class="target" id="structesp__pm__config__esp32__t_1aaaf6855e839ab4571b703e570ed8f8be"></span>int <code class="descname">min_freq_mhz</code><a class="headerlink" href="power_management.html#_CPPv4N21esp_pm_config_esp32_t12min_freq_mhzE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მინიმალური CPU სიხშირე, რომელიც უნდა იქნას გამოყენებული, როდესაც დაბლოკვა არ ხდება, MHz-ში </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N21esp_pm_config_esp32_t18light_sleep_enableE">
<span id="_CPPv3N21esp_pm_config_esp32_t18light_sleep_enableE"></span><span id="_CPPv2N21esp_pm_config_esp32_t18light_sleep_enableE"></span><span id="esp_pm_config_esp32_t::light_sleep_enable__b"></span><span class="target" id="structesp__pm__config__esp32__t_1a18ba324ab15ae606c969b5c1667dac5c"></span>bool <code class="descname">light_sleep_enable</code><a class="headerlink" href="power_management.html#_CPPv4N21esp_pm_config_esp32_t18light_sleep_enableE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მსუბუქ ძილში შესვლა, როდესაც საკეტები არ არის აღებული </p>
</dd></dl>
</div>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="sleep_modes.html" rel="next" title="Sleep Modes">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="perfmon.html" rel="prev" title="Performance Monitor"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>