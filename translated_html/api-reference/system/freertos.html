
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>უფასო RTOS — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="freertos_additions.html" rel="next" title="FreeRTOS Additions"/>
<link href="esp_event_legacy.html" rel="prev" title="Legacy event loop"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/system/freertos.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/system/freertos"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/system/freertos.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../provisioning/index.html">უზრუნველყოფა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">შენახვა</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">სისტემა</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="app_image_format.html">აპლიკაციის სურათის ფორმატი</a></li>
<li class="toctree-l3"><a class="reference internal" href="app_trace.html">აპლიკაციის დონის ტრასირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="efuse.html">eFuse მენეჯერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_err.html">შეცდომის კოდები და დამხმარე ფუნქციები</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_https_ota.html">ESP HTTPS OTA</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_pthread.html">ESP pthread</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_event.html">მოვლენების ციკლის ბიბლიოთეკა</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="freertos.html#">უფასო RTOS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#overview">მიმოხილვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#task-api">დავალების API</a></li>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#queue-api">რიგის API</a></li>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#semaphore-api">სემაფორი API</a></li>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#timer-api">ტაიმერი API</a></li>
<li class="toctree-l4"><a class="reference internal" href="freertos.html#event-group-api">ღონისძიებების ჯგუფი, API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="freertos_additions.html">უფასო RTOS დამატებები</a></li>
<li class="toctree-l3"><a class="reference internal" href="mem_alloc.html">გროვის მეხსიერების განაწილება</a></li>
<li class="toctree-l3"><a class="reference internal" href="heap_debug.html">გროვის მეხსიერების გამართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_timer.html">მაღალი გარჩევადობის ტაიმერი</a></li>
<li class="toctree-l3"><a class="reference internal" href="himem.html">Himem (დიდი გარე SPI ოპერატიული მეხსიერება) API</a></li>
<li class="toctree-l3"><a class="reference internal" href="ipc.html">პროცესორებს შორის ზარი</a></li>
<li class="toctree-l3"><a class="reference internal" href="esp_expression_with_stack.html">ფუნქციის გამოძახება გარე სტეკით</a></li>
<li class="toctree-l3"><a class="reference internal" href="intr_alloc.html">შეწყვეტის განაწილება</a></li>
<li class="toctree-l3"><a class="reference internal" href="log.html">ლოგირება</a></li>
<li class="toctree-l3"><a class="reference internal" href="system.html">სხვადასხვა სისტემა, API წმ</a></li>
<li class="toctree-l3"><a class="reference internal" href="ota.html">უსადენო განახლებები (OTA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="perfmon.html">შესრულების მონიტორი</a></li>
<li class="toctree-l3"><a class="reference internal" href="power_management.html">ენერგიის მართვა</a></li>
<li class="toctree-l3"><a class="reference internal" href="sleep_modes.html">ძილის რეჟიმები</a></li>
<li class="toctree-l3"><a class="reference internal" href="wdts.html">მეთვალყურე ძაღლები</a></li>
<li class="toctree-l3"><a class="reference internal" href="system_time.html">სისტემის დრო</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">სისტემის API</a> »</li>
<li>უფასო RTOS</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/system/freertos.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="freertos">
<h1>უფასო RTOS<a class="headerlink" href="freertos.html#freertos" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="freertos.html#overview" title="Permalink to this headline">¶</a></h2>
<p>ეს განყოფილება შეიცავს Free RTOS ტიპების, ფუნქციებისა და მაკროების დოკუმენტაციას. ის ავტომატურად გენერირდება Free RTOS სათაურის ფაილებიდან.</p>
<p>დამატებითი ინფორმაციისთვის ESP-IDF ისთვის სპეციფიკური Free RTOS ფუნქციების შესახებ იხილეთ <a class="reference internal" href="../../api-guides/freertos-smp.html"><span class="doc">ESP-IDF უფასო RTOS SMP ცვლილებები</span></a>
და <a class="reference internal" href="freertos_additions.html"><span class="doc">ESP-IDF უფასო RTOS დამატებები</span></a>.</p>
</div>
<div class="section" id="task-api">
<h2>დავალების API<a class="headerlink" href="freertos.html#task-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="freertos.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/task.h">freertos/include/freertos/task.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="freertos.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t">
<span id="_CPPv323xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="_CPPv223xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t"></span><span id="xTaskCreatePinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.TaskHandle_tPC.BaseType_tC"></span><span class="target" id="task_8h_1a27c6feed2bffa9de57b93f20abafa44c"></span>BaseType_t <code class="descname">xTaskCreatePinnedToCore</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის სახელი</em>, <em class="property">კონსტ</em> uint32_t <em>usStackDepth</em>, void *<em class="property">კონსტ</em> <em>pvპარამეტრები</em>, UBaseType_t <em>uxPriority</em>, <a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> *<em class="property">კონსტ</em> <em>pvCreatedTask</em>, <em class="property">კონსტ</em> BaseType_t <em>xCoreID</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv423xTaskCreatePinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_tK10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი დავალება მითითებული მსგავსებით.</p>
<p>ეს ფუნქცია xTaskCreate-ის მსგავსია, მაგრამ საშუალებას გაძლევთ დააყენოთ დავალების შესაბამისობა SMP სისტემაში.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: ამოცანის შეყვანის ფუნქციის მაჩვენებელი. დავალებები უნდა იყოს იმპლემენტირებული ისე, რომ არასდროს დაბრუნდეს (ანუ უწყვეტი ციკლი).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>დავალების აღწერითი სახელი. ეს ძირითადად გამოიყენება გამართვა ging-ის გასაადვილებლად. მაქსიმალური სიგრძე განსაზღვრულია configMAX_TASK_NAME_LEN-ით - ნაგულისხმევი მნიშვნელობაა 16.</li>
<li><code class="docutils literal notranslate"><span class="pre">usStackDepth</span></code>ბაიტების რაოდენობით მითითებული დავალებების დასტის ზომა. გაითვალისწინეთ, რომ ეს განსხვავდება სტანდარტული Free RTOS ისგან.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>მაჩვენებელი, რომელიც გამოყენებული იქნება შექმნილი დავალების პარამეტრად.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: პრიორიტეტი, რომლითაც დავალება უნდა შესრულდეს. სისტემებს, რომლებიც მოიცავს MPU მხარდაჭერას, შეუძლიათ სურვილისამებრ შექმნან დავალებები პრივილეგირებულ (სისტემურ) რეჟიმში პრიორიტეტის პარამეტრის portPRIVILEGE_BIT ბიტის დაყენებით. მაგალითად, პრიორიტეტი 2-ით პრივილეგირებული დავალების შესაქმნელად, uxPriority პარამეტრი უნდა იყოს დაყენებული (2 | portPRIVILEGE_BIT).</li>
<li><code class="docutils literal notranslate"><span class="pre">pvCreatedTask</span></code>გამოიყენება იმ სახელურის უკან გადასაცემად, რომლითაც შესაძლებელია შექმნილი დავალების მითითება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCoreID</span></code>თუ მნიშვნელობაა tskNO_AFFINITY, შექმნილი დავალება არ არის მიმაგრებული არცერთ პროცესორზე და დამგეგმავს შეუძლია მისი გაშვება ნებისმიერ ხელმისაწვდომ ბირთვზე. მნიშვნელობები 0 ან 1 მიუთითებს პროცესორის ინდექსის ნომერზე, რომელზეც დავალება უნდა იყოს მიმაგრებული. (portNUM_PROCESSORS - 1)-ზე მეტი მნიშვნელობების მითითება გამოიწვევს ფუნქციის ჩავარდნას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv411xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t">
<span id="_CPPv311xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t"></span><span id="_CPPv211xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t"></span><span id="xTaskCreate__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.TaskHandle_tPC"></span><span class="target" id="task_8h_1a178c0f619519faf823e5cd9c87f8f201"></span><em class="property">სტატიკური</em> BaseType_t <code class="descname">xTaskCreate</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის სახელი</em>, <em class="property">კონსტ</em> uint32_t <em>usStackDepth</em>, void *<em class="property">კონსტ</em> <em>pvპარამეტრები</em>, UBaseType_t <em>uxPriority</em>, <a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> *<em class="property">კონსტ</em> <em>pvCreatedTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv411xTaskCreate14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი დავალება და დაამატეთ ის გასაშვებად მზად დავალებების სიაში.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, დავალებები იყენებენ მეხსიერების ორ ბლოკს. პირველი ბლოკი გამოიყენება დავალების მონაცემთა სტრუქტურების შესანახად. მეორე ბლოკი გამოიყენება დავალების მიერ, როგორც მისი დასტა. თუ დავალება იქმნება xTaskCreate() ფუნქციის გამოყენებით, მაშინ მეხსიერების ორივე ბლოკი ავტომატურად დინამიურად გამოიყოფა xTaskCreate() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ დავალება იქმნება xTaskCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს საჭირო მეხსიერება. შესაბამისად, xTaskCreateStatic() საშუალებას იძლევა დავალების შექმნა დინამიური მეხსიერების გამოყოფის გარეშე.</p>
<p>დინამიური მეხსიერების განაწილების არმქონე ვერსიისთვის იხილეთ xTaskCreateStatic().</p>
<p>xTaskCreate() ფუნქციის გამოყენება შესაძლებელია მხოლოდ ისეთი დავალების შესაქმნელად, რომელსაც აქვს შეუზღუდავი წვდომა მთელ მიკროკონტროლერი მეხსიერების რუკაზე. სისტემებს, რომლებიც მოიცავს MPU მხარდაჭერას, ალტერნატიულად შეუძლიათ შექმნან MPU შეზღუდული დავალება xTaskCreateRestricted() ფუნქციის გამოყენებით.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">be</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskCode</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">static</span> <span class="n">uint8_t</span> <span class="n">ucParameterToPass</span><span class="p">;</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">parameter</span> <span class="n">ucParameterToPass</span>
 <span class="o">//</span> <span class="n">must</span> <span class="n">exist</span> <span class="k">for</span> <span class="n">the</span> <span class="n">lifetime</span> <span class="n">of</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span> <span class="ow">is</span> <span class="n">declared</span> <span class="n">static</span><span class="o">.</span>  <span class="n">If</span> <span class="n">it</span> <span class="n">was</span> <span class="n">just</span> <span class="n">an</span>
 <span class="o">//</span> <span class="n">an</span> <span class="n">automatic</span> <span class="n">stack</span> <span class="n">variable</span> <span class="n">it</span> <span class="n">might</span> <span class="n">no</span> <span class="n">longer</span> <span class="n">exist</span><span class="p">,</span> <span class="ow">or</span> <span class="n">at</span> <span class="n">least</span> <span class="n">have</span> <span class="n">been</span> <span class="n">corrupted</span><span class="p">,</span> <span class="n">by</span> <span class="n">the</span> <span class="n">time</span>
 <span class="o">//</span> <span class="n">the</span> <span class="n">new</span> <span class="n">task</span> <span class="n">attempts</span> <span class="n">to</span> <span class="n">access</span> <span class="n">it</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">"NAME"</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ucParameterToPass</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>
    <span class="n">configASSERT</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">delete</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHandle</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
     <span class="n">vTaskDelete</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>If program uses thread local variables (ones specified with “__thread” keyword) then storage for them will be allocated on the task’s stack.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: ამოცანის შეყვანის ფუნქციის მაჩვენებელი. დავალებები უნდა იყოს იმპლემენტირებული ისე, რომ არასდროს დაბრუნდეს (ანუ უწყვეტი ციკლი).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>დავალების აღწერითი სახელი. ეს ძირითადად გამოიყენება გამართვა ging-ის გასაადვილებლად. მაქსიმალური სიგრძე განსაზღვრულია configMAX_TASK_NAME_LEN-ით - ნაგულისხმევი მნიშვნელობაა 16.</li>
<li><code class="docutils literal notranslate"><span class="pre">usStackDepth</span></code>ბაიტების რაოდენობით მითითებული დავალებების დასტის ზომა. გაითვალისწინეთ, რომ ეს განსხვავდება სტანდარტული Free RTOS ისგან.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>მაჩვენებელი, რომელიც გამოყენებული იქნება შექმნილი დავალების პარამეტრად.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: პრიორიტეტი, რომლითაც დავალება უნდა შესრულდეს. სისტემებს, რომლებიც მოიცავს MPU მხარდაჭერას, შეუძლიათ სურვილისამებრ შექმნან დავალებები პრივილეგირებულ (სისტემურ) რეჟიმში პრიორიტეტის პარამეტრის portPRIVILEGE_BIT ბიტის დაყენებით. მაგალითად, პრიორიტეტი 2-ით პრივილეგირებული დავალების შესაქმნელად, uxPriority პარამეტრი უნდა იყოს დაყენებული (2 | portPRIVILEGE_BIT).</li>
<li><code class="docutils literal notranslate"><span class="pre">pvCreatedTask</span></code>გამოიყენება იმ სახელურის უკან გადასაცემად, რომლითაც შესაძლებელია შექმნილი დავალების მითითება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t">
<span id="_CPPv329xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="_CPPv229xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t"></span><span id="xTaskCreateStaticPinnedToCore__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC.BaseType_tC"></span><span class="target" id="task_8h_1a8655dc497b2205f7b8fb6947859124eb"></span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskCreateStaticPinnedToCore</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის სახელი</em>, <em class="property">კონსტ</em> uint32_t <em>ulStackDepth</em>, void *<em class="property">კონსტ</em> <em>pvპარამეტრები</em>, UBaseType_t <em>uxPriority</em>, StackType_t *<em class="property">კონსტ</em> <em>pxStackBuffer</em>, StaticTask_t *<em class="property">კონსტ</em> <em>pxTaskBuffer</em>, <em class="property">კონსტ</em> BaseType_t <em>xCoreID</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv429xTaskCreateStaticPinnedToCore14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_tK10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი დავალება მითითებული მსგავსებით.</p>
<p>ეს ფუნქცია xTaskCreateStatic-ის მსგავსია, მაგრამ საშუალებას გაძლევთ მიუთითოთ დავალების მსგავსება SMP სისტემაში.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and a task handle will be returned by which the created task can be referenced. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: ამოცანის შეყვანის ფუნქციის მაჩვენებელი. დავალებები უნდა იყოს იმპლემენტირებული ისე, რომ არასდროს დაბრუნდეს (ანუ უწყვეტი ციკლი).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: დავალების აღწერითი სახელი. ეს ძირითადად გამოიყენება გამართვა ging-ის გასაადვილებლად. სტრიქონის მაქსიმალური სიგრძე განისაზღვრება configMAX_TASK_NAME_LEN-ით Free RTOS Config.h ფაილში.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulStackDepth</span></code>ბაიტების რაოდენობით მითითებული დავალებების დასტის ზომა. გაითვალისწინეთ, რომ ეს განსხვავდება სტანდარტული Free RTOS ისგან.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>მაჩვენებელი, რომელიც გამოყენებული იქნება შექმნილი დავალების პარამეტრად.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: პრიორიტეტი, რომლითაც დავალება შესრულდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxStackBuffer</span></code>უნდა მიუთითებდეს StackType_t მასივზე, რომელსაც აქვს სულ მცირე ulStackDepth ინდექსები - მასივი შემდეგ გამოყენებული იქნება დავალების სტეკად, რაც გამორიცხავს სტეკის დინამიურად განაწილების საჭიროებას.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTaskBuffer</span></code>უნდა მიუთითებდეს StaticTask_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება დავალების მონაცემთა სტრუქტურების შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCoreID</span></code>თუ მნიშვნელობაა tskNO_AFFINITY, შექმნილი დავალება არ არის მიმაგრებული არცერთ პროცესორზე და დამგეგმავს შეუძლია მისი გაშვება ნებისმიერ ხელმისაწვდომ ბირთვზე. მნიშვნელობები 0 ან 1 მიუთითებს პროცესორის ინდექსის ნომერზე, რომელზეც დავალება უნდა იყოს მიმაგრებული. (portNUM_PROCESSORS - 1)-ზე მეტი მნიშვნელობების მითითება გამოიწვევს ფუნქციის ჩავარდნას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t">
<span id="_CPPv317xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="_CPPv217xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t"></span><span id="xTaskCreateStatic__TaskFunction_t.cCPC.uint32_tC.voidPC.UBaseType_t.StackType_tPC.StaticTask_tPC"></span><span class="target" id="task_8h_1a415a359e0177add17a963f5e97c16f8c"></span><em class="property">სტატიკური</em> <a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskCreateStatic</code><span class="sig-paren">(</span>TaskFunction_t <em>pvTaskCode</em>, <em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის სახელი</em>, <em class="property">კონსტ</em> uint32_t <em>ulStackDepth</em>, void *<em class="property">კონსტ</em> <em>pvპარამეტრები</em>, UBaseType_t <em>uxPriority</em>, StackType_t *<em class="property">კონსტ</em> <em>pxStackBuffer</em>, StaticTask_t *<em class="property">კონსტ</em> <em>pxTaskBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xTaskCreateStatic14TaskFunction_tPCKcK8uint32_tPCv11UBaseType_tPC11StackType_tPC12StaticTask_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი დავალება და დაამატეთ ის გასაშვებად მზად დავალებების სიაში.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, დავალებები იყენებენ მეხსიერების ორ ბლოკს. პირველი ბლოკი გამოიყენება დავალების მონაცემთა სტრუქტურების შესანახად. მეორე ბლოკი გამოიყენება დავალების მიერ, როგორც მისი დასტა. თუ დავალება იქმნება xTaskCreate() ფუნქციის გამოყენებით, მაშინ მეხსიერების ორივე ბლოკი ავტომატურად დინამიურად გამოიყოფა xTaskCreate() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ დავალება იქმნება xTaskCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს საჭირო მეხსიერება. შესაბამისად, xTaskCreateStatic() საშუალებას იძლევა დავალების შექმნა დინამიური მეხსიერების გამოყოფის გარეშე.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Dimensions</span> <span class="n">the</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span> <span class="n">will</span> <span class="n">use</span> <span class="k">as</span> <span class="n">its</span> <span class="n">stack</span><span class="o">.</span>
<span class="o">//</span> <span class="n">NOTE</span><span class="p">:</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="nb">bytes</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">will</span> <span class="n">hold</span><span class="p">,</span> <span class="ow">not</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span>
<span class="o">//</span> <span class="n">words</span> <span class="k">as</span> <span class="n">found</span> <span class="ow">in</span> <span class="n">vanilla</span> <span class="n">FreeRTOS</span><span class="o">.</span>
<span class="c1">#define STACK_SIZE 200</span>

<span class="o">//</span> <span class="n">Structure</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">TCB</span> <span class="n">of</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span><span class="o">.</span>
<span class="n">StaticTask_t</span> <span class="n">xTaskBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Buffer</span> <span class="n">that</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span> <span class="n">will</span> <span class="n">use</span> <span class="k">as</span> <span class="n">its</span> <span class="n">stack</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">this</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">array</span> <span class="n">of</span> <span class="n">StackType_t</span> <span class="n">variables</span><span class="o">.</span>  <span class="n">The</span> <span class="n">size</span> <span class="n">of</span> <span class="n">StackType_t</span> <span class="ow">is</span> <span class="n">dependent</span> <span class="n">on</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">RTOS</span> <span class="n">port</span><span class="o">.</span>
<span class="n">StackType_t</span> <span class="n">xStack</span><span class="p">[</span> <span class="n">STACK_SIZE</span> <span class="p">];</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">implements</span> <span class="n">the</span> <span class="n">task</span> <span class="n">being</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskCode</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">parameter</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">expected</span> <span class="n">to</span> <span class="n">be</span> <span class="mi">1</span> <span class="k">as</span> <span class="mi">1</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">pvParameters</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xTaskCreateStatic</span><span class="p">()</span><span class="o">.</span>
    <span class="n">configASSERT</span><span class="p">(</span> <span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="n">pvParameters</span> <span class="o">==</span> <span class="mi">1</span><span class="n">UL</span> <span class="p">);</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">TaskHandle_t</span> <span class="n">xHandle</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span> <span class="n">without</span> <span class="n">using</span> <span class="nb">any</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span><span class="o">.</span>
    <span class="n">xHandle</span> <span class="o">=</span> <span class="n">xTaskCreateStatic</span><span class="p">(</span>
                  <span class="n">vTaskCode</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Function</span> <span class="n">that</span> <span class="n">implements</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="s2">"NAME"</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Text</span> <span class="n">name</span> <span class="k">for</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="n">STACK_SIZE</span><span class="p">,</span>      <span class="o">//</span> <span class="n">Stack</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">,</span> <span class="ow">not</span> <span class="n">words</span><span class="o">.</span>
                  <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="mi">1</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Parameter</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
                  <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span><span class="o">//</span> <span class="n">Priority</span> <span class="n">at</span> <span class="n">which</span> <span class="n">the</span> <span class="n">task</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span>
                  <span class="n">xStack</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Array</span> <span class="n">to</span> <span class="n">use</span> <span class="k">as</span> <span class="n">the</span> <span class="n">task</span><span class="s1">'s stack.</span>
                  <span class="o">&amp;</span><span class="n">xTaskBuffer</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">Variable</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">task</span><span class="s1">'s data structure.</span>

    <span class="o">//</span> <span class="n">puxStackBuffer</span> <span class="ow">and</span> <span class="n">pxTaskBuffer</span> <span class="n">were</span> <span class="ow">not</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">task</span> <span class="n">will</span> <span class="n">have</span>
    <span class="o">//</span> <span class="n">been</span> <span class="n">created</span><span class="p">,</span> <span class="ow">and</span> <span class="n">xHandle</span> <span class="n">will</span> <span class="n">be</span> <span class="n">the</span> <span class="n">task</span><span class="s1">'s handle.  Use the handle</span>
    <span class="o">//</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will be created and a task handle will be returned by which the created task can be referenced. If either pxStackBuffer or pxTaskBuffer are NULL then the task will not be created and NULL is returned.</dd>
<dt><strong>შენიშვნა</strong></dt>
<dd>If program uses thread local variables (ones specified with “__thread” keyword) then storage for them will be allocated on the task’s stack.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pvTaskCode</span></code>: ამოცანის შეყვანის ფუნქციის მაჩვენებელი. დავალებები უნდა იყოს იმპლემენტირებული ისე, რომ არასდროს დაბრუნდეს (ანუ უწყვეტი ციკლი).</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: დავალების აღწერითი სახელი. ეს ძირითადად გამოიყენება გამართვა ging-ის გასაადვილებლად. სტრიქონის მაქსიმალური სიგრძე განისაზღვრება configMAX_TASK_NAME_LEN-ით Free RTOS Config.h ფაილში.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulStackDepth</span></code>ბაიტების რაოდენობით მითითებული დავალებების დასტის ზომა. გაითვალისწინეთ, რომ ეს განსხვავდება სტანდარტული Free RTOS ისგან.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameters</span></code>მაჩვენებელი, რომელიც გამოყენებული იქნება შექმნილი დავალების პარამეტრად.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxPriority</span></code>: პრიორიტეტი, რომლითაც დავალება შესრულდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxStackBuffer</span></code>უნდა მიუთითებდეს StackType_t მასივზე, რომელსაც აქვს სულ მცირე ulStackDepth ინდექსები - მასივი შემდეგ გამოყენებული იქნება დავალების სტეკად, რაც გამორიცხავს სტეკის დინამიურად განაწილების საჭიროებას.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTaskBuffer</span></code>უნდა მიუთითებდეს StaticTask_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება დავალების მონაცემთა სტრუქტურების შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv411vTaskDelete12TaskHandle_t">
<span id="_CPPv311vTaskDelete12TaskHandle_t"></span><span id="_CPPv211vTaskDelete12TaskHandle_t"></span><span id="vTaskDelete__TaskHandle_t"></span><span class="target" id="task_8h_1a27ff4ebce26565bef136bda84201ff80"></span>void <code class="descname">vTaskDelete</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToDelete</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv411vTaskDelete12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>RTOS რეალურ დროში ბირთვის მართვის ფუნქციიდან დავალების ამოღება.</p>
<p>წასაშლელი დავალება წაიშლება ყველა მზადყოფნის, დაბლოკილის, შეჩერებულის და მოვლენის სიიდან.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskDelete უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p><p>vTaskDelete ()-ის გამოყენებით კოდის ნიმუშისთვის იხილეთ აპლიკაციის დემო ფაილი death.c.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</dd>
</dl>
</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vOtherFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
    <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">"NAME"</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">delete</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
    <span class="n">vTaskDelete</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToDelete</span></code>წასაშლელი დავალების სახელური. NULL-ის გატარება გამოიწვევს გამომძახებელი დავალების წაშლას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv410vTaskDelayK10TickType_t">
<span id="_CPPv310vTaskDelayK10TickType_t"></span><span id="_CPPv210vTaskDelayK10TickType_t"></span><span id="vTaskDelay__TickType_tC"></span><span class="target" id="task_8h_1aa154068cecd7f31446a7a84af44ab1a3"></span>void <code class="descname">vTaskDelay</code><span class="sig-paren">(</span><em class="property">კონსტ</em> TickType_t <em>xTicksToDelay</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv410vTaskDelayK10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების გადადება ტიკების მოცემული რაოდენობით.</p>
<p>დავალების დაბლოკვის ფაქტობრივი დრო დამოკიდებულია ტიკ-სიჩქარეზე. ტიკ-სიჩქარიდან რეალური დროის გამოსათვლელად შეიძლება გამოყენებულ იქნას portTICK_PERIOD_MS მუდმივი - ერთი ტიკ-პერიოდის გარჩევადობით.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskDelay უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>vTaskDelay() განსაზღვრავს დროს, როდესაც დავალება უნდა განბლოკოს vTaskDelay() გამოძახების დროსთან შედარებით. მაგალითად, 100 ტიკის ბლოკის პერიოდის მითითება გამოიწვევს დავალების 100 ტიკის განბლოკვას vTaskDelay() გამოძახების შემდეგ. შესაბამისად, vTaskDelay() არ იძლევა კარგ მეთოდს პერიოდული დავალების სიხშირის კონტროლისთვის, რადგან კოდის გავლით გავლილი გზა, ისევე როგორც სხვა დავალება და შეფერხების აქტივობა, გავლენას მოახდენს vTaskDelay() გამოძახების სიხშირეზე და შესაბამისად, დავალების შემდეგ შესრულების დროზე. იხილეთ vTaskDelayUntil() ალტერნატიული API ფუნქციისთვის, რომელიც შექმნილია ფიქსირებული სიხშირის შესრულების გასაადვილებლად. ის ამას აკეთებს აბსოლუტური დროის (და არა ფარდობითი დროის) მითითებით, როდესაც გამოძახების დავალება უნდა განბლოკოს.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vTaskFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">Block</span> <span class="k">for</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xDelay</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Simply</span> <span class="n">toggle</span> <span class="n">the</span> <span class="n">LED</span> <span class="n">every</span> <span class="mi">500</span><span class="n">ms</span><span class="p">,</span> <span class="n">blocking</span> <span class="n">between</span> <span class="n">each</span> <span class="n">toggle</span><span class="o">.</span>
        <span class="n">vToggleLED</span><span class="p">();</span>
        <span class="n">vTaskDelay</span><span class="p">(</span> <span class="n">xDelay</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTicksToDelay</span></code>: დროის რაოდენობა, ტიკ-პერიოდებში, რომელიც გამომძახებელმა დავალებამ უნდა დაბლოკოს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415vTaskDelayUntilPC10TickType_tK10TickType_t">
<span id="_CPPv315vTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="_CPPv215vTaskDelayUntilPC10TickType_tK10TickType_t"></span><span id="vTaskDelayUntil__TickType_tPC.TickType_tC"></span><span class="target" id="task_8h_1a067da3e949e248096ec6c01f9cb75a47"></span>void <code class="descname">vTaskDelayUntil</code><span class="sig-paren">(</span>TickType_t *<em class="property">კონსტ</em> <em>pxწინა გაღვიძების დრო</em>, <em class="property">კონსტ</em> TickType_t <em>x დროის ნამატი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415vTaskDelayUntilPC10TickType_tK10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების გადადება განსაზღვრულ დრომდე.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskDelayUntil უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>ეს ფუნქცია შეიძლება გამოყენებულ იქნას პერიოდული დავალებების მიერ, რათა უზრუნველყოფილი იყოს შესრულების მუდმივი სიხშირე.</p>
<p>ეს ფუნქცია vTaskDelay () ფუნქციისგან ერთი მნიშვნელოვანი ასპექტით განსხვავდება: vTaskDelay () ფუნქცია გამოიწვევს დავალების დაბლოკვას vTaskDelay () ფუნქციის გამოძახების მომენტიდან მითითებული რაოდენობის ტიკების განმავლობაში. ამიტომ, რთულია vTaskDelay () ფუნქციის გამოყენება ფიქსირებული შესრულების სიხშირის გენერირებისთვის, რადგან დავალების შესრულების დაწყებასა და vTaskDelay () ფუნქციის გამოძახებას შორის დრო შეიძლება არ იყოს ფიქსირებული [დავალებამ შეიძლება კოდის მეშვეობით განსხვავებული გზა გაიაროს გამოძახებებს შორის, ან შეიძლება შეწყდეს ან წინასწარ შეჩერდეს სხვადასხვა რაოდენობის ჯერ ყოველ შესრულებაზე].</p>
<p>მიუხედავად იმისა, რომ vTaskDelay () განსაზღვრავს გამოღვიძების დროს ფუნქციის გამოძახების დროსთან მიმართებაში, vTaskDelayUntil () განსაზღვრავს აბსოლუტურ (ზუსტ) დროს, როდესაც მას სურს განბლოკვის გაუქმება.</p>
<p>ტიკის სიხშირიდან რეალური დროის გამოსათვლელად შესაძლებელია portTICK_PERIOD_MS კონსტანტის გამოყენება - ერთი ტიკის პერიოდის გარჩევადობით.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Perform</span> <span class="n">an</span> <span class="n">action</span> <span class="n">every</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vTaskFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TickType_t</span> <span class="n">xLastWakeTime</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xFrequency</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Initialise</span> <span class="n">the</span> <span class="n">xLastWakeTime</span> <span class="n">variable</span> <span class="k">with</span> <span class="n">the</span> <span class="n">current</span> <span class="n">time</span><span class="o">.</span>
    <span class="n">xLastWakeTime</span> <span class="o">=</span> <span class="n">xTaskGetTickCount</span> <span class="p">();</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Wait</span> <span class="k">for</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">cycle</span><span class="o">.</span>
        <span class="n">vTaskDelayUntil</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xLastWakeTime</span><span class="p">,</span> <span class="n">xFrequency</span> <span class="p">);</span>

        <span class="o">//</span> <span class="n">Perform</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxPreviousWakeTime</span></code>: მაჩვენებელი ცვლადზე, რომელიც ინახავს დროს, როდესაც დავალება ბოლოს განბლოკილი იქნა. ცვლადი უნდა იყოს ინიციალიზებული მიმდინარე დროით მის პირველ გამოყენებამდე (იხილეთ მაგალითი ქვემოთ). ამის შემდეგ ცვლადი ავტომატურად განახლდება vTaskDelayUntil ()-ში.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimeIncrement</span></code>ციკლის დროის პერიოდი. დავალება განბლოკილი იქნება *pxPreviousWakeTime + xTimeIncrement დროს. vTaskDelayUntil-ის გამოძახება იგივე xTimeIncrement პარამეტრის მნიშვნელობით გამოიწვევს დავალების შესრულებას ფიქსირებული ინტერფეისის პერიოდით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417uxTaskPriorityGet12TaskHandle_t">
<span id="_CPPv317uxTaskPriorityGet12TaskHandle_t"></span><span id="_CPPv217uxTaskPriorityGet12TaskHandle_t"></span><span id="uxTaskPriorityGet__TaskHandle_t"></span><span class="target" id="task_8h_1a3edc3f1a0adc8403f42529bce4ae3446"></span>UBaseType_t <code class="descname">uxTaskPriorityGet</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417uxTaskPriorityGet12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიაღწიეთ ნებისმიერი დავალების პრიორიტეტს.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_uxTaskPriorityGet უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> void vAFunction( void )
 {
 TaskHandle_t xHandle;

  // Create a task, storing the handle.
  xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &amp;xHandle );

  // ...

  // Use the handle to obtain the priority of the created task.
  // It was created with tskIDLE_PRIORITY, but may have changed
  // it itself.
  if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
  {
      // The task has changed it's priority.
  }

  // ...

  // Is our priority higher than the created task?
  if( uxTaskPriorityGet( xHandle ) &lt; uxTaskPriorityGet( NULL ) )
  {
      // Our priority (obtained using NULL handle) is higher.
  }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The priority of xTask.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: მოთხოვნილი დავალების სახელური. NULL სახელურის გაცემა იწვევს გამომძახებელი დავალების პრიორიტეტის დაბრუნებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424uxTaskPriorityGetFromISR12TaskHandle_t">
<span id="_CPPv324uxTaskPriorityGetFromISR12TaskHandle_t"></span><span id="_CPPv224uxTaskPriorityGetFromISR12TaskHandle_t"></span><span id="uxTaskPriorityGetFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1abc808e43d257a47de4b431483c65ea15"></span>UBaseType_t <code class="descname">uxTaskPriorityGetFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv424uxTaskPriorityGetFromISR12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>uxTaskPriorityGet()-ის ვერსია, რომლის გამოყენებაც შესაძლებელია ISR-დან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The priority of xTask. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: მოთხოვნილი დავალების სახელური. NULL სახელურის გაცემა იწვევს გამომძახებელი დავალების პრიორიტეტის დაბრუნებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv413eTaskGetState12TaskHandle_t">
<span id="_CPPv313eTaskGetState12TaskHandle_t"></span><span id="_CPPv213eTaskGetState12TaskHandle_t"></span><span id="eTaskGetState__TaskHandle_t"></span><span class="target" id="task_8h_1a954df77397d616484edb7c58c7760b10"></span><a class="reference internal" href="freertos.html#_CPPv410eTaskState" title="eTaskState">eTaskState</a> <code class="descname">eTaskGetState</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv413eTaskGetState12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ნებისმიერი დავალების მდგომარეობა.</p>
<p>მდგომარეობები კოდირებულია eTaskState ჩამოთვლილი ტიპით.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_eTaskGetState უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The state of xTask at the time the function was called. Note the state of the task might change between the function being called, and the functions return value being tested by the calling task. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: მოთხოვნის დასასრული ამოცანის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t">
<span id="_CPPv316vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="_CPPv216vTaskPrioritySet12TaskHandle_t11UBaseType_t"></span><span id="vTaskPrioritySet__TaskHandle_t.UBaseType_t"></span><span class="target" id="task_8h_1a1ee31be76e326e0644dbd6ac40a787b6"></span>void <code class="descname">vTaskPrioritySet</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, UBaseType_t <em>uxNewPriority</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv416vTaskPrioritySet12TaskHandle_t11UBaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააყენეთ ნებისმიერი დავალების პრიორიტეტი.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskPrioritySet უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>კონტექსტის შეცვლა მოხდება ფუნქციის დაბრუნებამდე, თუ დაყენებული პრიორიტეტი უფრო მაღალია, ვიდრე ამჟამად შესრულებული დავალება.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">"NAME"</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="k">raise</span> <span class="n">the</span> <span class="n">priority</span> <span class="n">of</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskPrioritySet</span><span class="p">(</span> <span class="n">xHandle</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">a</span> <span class="n">NULL</span> <span class="n">handle</span> <span class="n">to</span> <span class="k">raise</span> <span class="n">our</span> <span class="n">priority</span> <span class="n">to</span> <span class="n">the</span> <span class="n">same</span> <span class="n">value</span><span class="o">.</span>
 <span class="n">vTaskPrioritySet</span><span class="p">(</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: დავალების სახელური, რომლისთვისაც პრიორიტეტი დაყენებულია. NULL სახელურის გადაცემა იწვევს გამომძახებელი დავალების პრიორიტეტის დაყენების პროცესს.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxNewPriority</span></code>: პრიორიტეტი, რომელსაც დავალება მიენიჭება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv412vTaskSuspend12TaskHandle_t">
<span id="_CPPv312vTaskSuspend12TaskHandle_t"></span><span id="_CPPv212vTaskSuspend12TaskHandle_t"></span><span id="vTaskSuspend__TaskHandle_t"></span><span class="target" id="task_8h_1a84d4e660b04630be2939d91b3c2412f8"></span>void <code class="descname">vTaskSuspend</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSuspend</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv412vTaskSuspend12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შეჩერება.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskSuspend უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>შეჩერების შემთხვევაში, დავალება არასდროს მიიღებს მიკროკონტროლერი დამუშავების დროს, მისი პრიორიტეტის მიუხედავად.</p>
<p>vTaskSuspend-ის გამოძახებები არ არის აკუმულაციური - ანუ vTaskSuspend()-ის ორჯერ გამოძახება ერთი და იგივე დავალების შესრულებისას მაინც მოითხოვს vTaskResume()-ის მხოლოდ ერთ გამოძახებას შეჩერებული დავალების მოსამზადებლად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">"NAME"</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">run</span> <span class="n">during</span> <span class="n">this</span> <span class="n">period</span><span class="p">,</span> <span class="n">unless</span>
 <span class="o">//</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">)</span><span class="o">.</span>

 <span class="o">//...</span>


 <span class="o">//</span> <span class="n">Suspend</span> <span class="n">ourselves</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">NULL</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">We</span> <span class="n">cannot</span> <span class="n">get</span> <span class="n">here</span> <span class="n">unless</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span>
 <span class="o">//</span> <span class="k">with</span> <span class="n">our</span> <span class="n">handle</span> <span class="k">as</span> <span class="n">the</span> <span class="n">parameter</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSuspend</span></code>შეჩერებული დავალების სახელური. NULL სახელურის გადაცემა გამოიწვევს გამომძახებელი დავალების შეჩერებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv411vTaskResume12TaskHandle_t">
<span id="_CPPv311vTaskResume12TaskHandle_t"></span><span id="_CPPv211vTaskResume12TaskHandle_t"></span><span id="vTaskResume__TaskHandle_t"></span><span class="target" id="task_8h_1a84a1584f29fb7736a1aa72ad5b3e9b44"></span>void <code class="descname">vTaskResume</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToResume</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv411vTaskResume12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განაახლებს შეჩერებულ დავალებას.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_vTaskSuspend უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>vTaskSuspend ()-ის ერთი ან მეტი გამოძახებით შეჩერებული დავალება ხელახლა გასაშვებად ხელმისაწვდომი გახდება vTaskResume ()-ის ერთი გამოძახებით.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">TaskHandle_t</span> <span class="n">xHandle</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="n">storing</span> <span class="n">the</span> <span class="n">handle</span><span class="o">.</span>
 <span class="n">xTaskCreate</span><span class="p">(</span> <span class="n">vTaskCode</span><span class="p">,</span> <span class="s2">"NAME"</span><span class="p">,</span> <span class="n">STACK_SIZE</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">tskIDLE_PRIORITY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Use</span> <span class="n">the</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">suspend</span> <span class="n">the</span> <span class="n">created</span> <span class="n">task</span><span class="o">.</span>
 <span class="n">vTaskSuspend</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">run</span> <span class="n">during</span> <span class="n">this</span> <span class="n">period</span><span class="p">,</span> <span class="n">unless</span>
 <span class="o">//</span> <span class="n">another</span> <span class="n">task</span> <span class="n">calls</span> <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">)</span><span class="o">.</span>

 <span class="o">//...</span>


 <span class="o">//</span> <span class="n">Resume</span> <span class="n">the</span> <span class="n">suspended</span> <span class="n">task</span> <span class="n">ourselves</span><span class="o">.</span>
 <span class="n">vTaskResume</span><span class="p">(</span> <span class="n">xHandle</span> <span class="p">);</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">created</span> <span class="n">task</span> <span class="n">will</span> <span class="n">once</span> <span class="n">again</span> <span class="n">get</span> <span class="n">microcontroller</span> <span class="n">processing</span>
 <span class="o">//</span> <span class="n">time</span> <span class="ow">in</span> <span class="n">accordance</span> <span class="k">with</span> <span class="n">its</span> <span class="n">priority</span> <span class="n">within</span> <span class="n">the</span> <span class="n">system</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToResume</span></code>: გაუმკლავდით მოსამზადებელ დავალებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418xTaskResumeFromISR12TaskHandle_t">
<span id="_CPPv318xTaskResumeFromISR12TaskHandle_t"></span><span id="_CPPv218xTaskResumeFromISR12TaskHandle_t"></span><span id="xTaskResumeFromISR__TaskHandle_t"></span><span class="target" id="task_8h_1aefbfd37c0661c3062fafd7334bff9aed"></span>BaseType_t <code class="descname">xTaskResumeFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToResume</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv418xTaskResumeFromISR12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>vTaskResume()-ის იმპლემენტაცია, რომლის გამოძახებაც შესაძლებელია ISR-დან.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის INCLUDE_xTaskResumeFromISR უნდა განისაზღვროს, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ კონფიგურაციის განყოფილება.</p>
<p>vTaskSuspend ()-ის ერთი ან მეტი გამოძახებით შეჩერებული დავალება ხელახლა გასაშვებად ხელმისაწვდომი გახდება xTaskResumeFromISR ()-ის ერთი გამოძახებით.</p>
<p>xTaskResumeFromISR() არ უნდა იქნას გამოყენებული შეფერხების მქონე დავალების სინქრონიზაციისთვის, თუ არსებობს შანსი, რომ შეფერხება დავალების შეჩერებამდე მოვიდეს - რადგან ამან შეიძლება გამოიწვიოს შეფერხებების გამოტოვება. სემაფორის, როგორც სინქრონიზაციის მექანიზმის გამოყენება, თავიდან აგვაცილებს ამ შემთხვევას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if resuming the task should result in a context switch, otherwise pdFALSE. This is used by the ISR to determine if a context switch may be required following the ISR. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToResume</span></code>: გაუმკლავდით მოსამზადებელ დავალებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415vTaskSuspendAllv">
<span id="_CPPv315vTaskSuspendAllv"></span><span id="_CPPv215vTaskSuspendAllv"></span><span id="vTaskSuspendAll__void"></span><span class="target" id="task_8h_1a366b302eba79d10b5ee2a3756f0fcc43"></span>void <code class="descname">vTaskSuspendAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415vTaskSuspendAllv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აჩერებს დამგეგმავს შეფერხებების გამორთვის გარეშე.</p>
<p>კონტექსტის გადართვა არ მოხდება, როდესაც დამგეგმავი შეჩერებულია.</p>
<p>vTaskSuspendAll () გამოძახების შემდეგ, დავალების გამოძახება გააგრძელებს შესრულებას მისი გადატანის რისკის გარეშე, სანამ xTaskResumeAll () გამოძახება არ განხორციელდება.</p>
<p>API ფუნქციები, რომლებსაც შეუძლიათ კონტექსტის გადართვის გამოწვევა (მაგალითად, vTaskDelayUntil(), xQueueSend() და ა.შ.), არ უნდა გამოიძახონ დამგეგმავის შეჩერებისას.</p>
<p>გამოყენების მაგალითი: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vTask1</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>

     <span class="o">//</span> <span class="o">...</span>

     <span class="o">//</span> <span class="n">At</span> <span class="n">some</span> <span class="n">point</span> <span class="n">the</span> <span class="n">task</span> <span class="n">wants</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">long</span> <span class="n">operation</span> <span class="n">during</span>
     <span class="o">//</span> <span class="n">which</span> <span class="n">it</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">want</span> <span class="n">to</span> <span class="n">get</span> <span class="n">swapped</span> <span class="n">out</span><span class="o">.</span>  <span class="n">It</span> <span class="n">cannot</span> <span class="n">use</span>
     <span class="o">//</span> <span class="n">taskENTER_CRITICAL</span> <span class="p">()</span><span class="o">/</span><span class="n">taskEXIT_CRITICAL</span> <span class="p">()</span> <span class="k">as</span> <span class="n">the</span> <span class="n">length</span> <span class="n">of</span> <span class="n">the</span>
     <span class="o">//</span> <span class="n">operation</span> <span class="n">may</span> <span class="n">cause</span> <span class="n">interrupts</span> <span class="n">to</span> <span class="n">be</span> <span class="n">missed</span> <span class="o">-</span> <span class="n">including</span> <span class="n">the</span>
     <span class="o">//</span> <span class="n">ticks</span><span class="o">.</span>

     <span class="o">//</span> <span class="n">Prevent</span> <span class="n">the</span> <span class="n">real</span> <span class="n">time</span> <span class="n">kernel</span> <span class="n">swapping</span> <span class="n">out</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>
     <span class="n">vTaskSuspendAll</span> <span class="p">();</span>

     <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">here</span><span class="o">.</span>  <span class="n">There</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">use</span> <span class="n">critical</span>
     <span class="o">//</span> <span class="n">sections</span> <span class="k">as</span> <span class="n">we</span> <span class="n">have</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">microcontroller</span> <span class="n">processing</span> <span class="n">time</span><span class="o">.</span>
     <span class="o">//</span> <span class="n">During</span> <span class="n">this</span> <span class="n">time</span> <span class="n">interrupts</span> <span class="n">will</span> <span class="n">still</span> <span class="n">operate</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">kernel</span>
     <span class="o">//</span> <span class="n">tick</span> <span class="n">count</span> <span class="n">will</span> <span class="n">be</span> <span class="n">maintained</span><span class="o">.</span>

     <span class="o">//</span> <span class="o">...</span>

     <span class="o">//</span> <span class="n">The</span> <span class="n">operation</span> <span class="ow">is</span> <span class="n">complete</span><span class="o">.</span>  <span class="n">Restart</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>
     <span class="n">xTaskResumeAll</span> <span class="p">();</span>
 <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414xTaskResumeAllv">
<span id="_CPPv314xTaskResumeAllv"></span><span id="_CPPv214xTaskResumeAllv"></span><span id="xTaskResumeAll__void"></span><span class="target" id="task_8h_1a003f8ae6d649225abd030cc76e1c7d0e"></span>BaseType_t <code class="descname">xTaskResumeAll</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv414xTaskResumeAllv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განაახლებს დამგეგმავის აქტივობას მას შემდეგ, რაც ის შეჩერდა vTaskSuspendAll()-ის გამოძახებით.</p>
<p>xTaskResumeAll() მხოლოდ დამგეგმავის მუშაობას აღადგენს. ის არ ხსნის vTaskSuspend()-ის გამოძახებით ადრე შეჩერებულ დავალებებს.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>void vTask1( void * pvParameters )
{
 for( ;; )
 {
     // Task code goes here.

     // ...

     // At some point the task wants to perform a long operation during
     // which it does not want to get swapped out.  It cannot use
     // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
     // operation may cause interrupts to be missed - including the
     // ticks.

     // Prevent the real time kernel swapping out the task.
     vTaskSuspendAll ();

     // Perform the operation here.  There is no need to use critical
     // sections as we have all the microcontroller processing time.
     // During this time interrupts will still operate and the real
     // time kernel tick count will be maintained.

     // ...

     // The operation is complete.  Restart the kernel.  We want to force
     // a context switch - but there is no point if resuming the scheduler
     // caused a context switch already.
     if( !xTaskResumeAll () )
     {
          taskYIELD ();
     }
 }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417xTaskGetTickCountv">
<span id="_CPPv317xTaskGetTickCountv"></span><span id="_CPPv217xTaskGetTickCountv"></span><span id="xTaskGetTickCount__void"></span><span class="target" id="task_8h_1a753ecfe23e7386066ecccad5d16422f7"></span>TickType_t <code class="descname">xTaskGetTickCount</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xTaskGetTickCountv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ტკიპების რაოდენობა</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The count of ticks since vTaskStartScheduler was called. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424xTaskGetTickCountFromISRv">
<span id="_CPPv324xTaskGetTickCountFromISRv"></span><span id="_CPPv224xTaskGetTickCountFromISRv"></span><span id="xTaskGetTickCountFromISR__void"></span><span class="target" id="task_8h_1a092be3fd5752625303c307620be523ff"></span>TickType_t <code class="descname">xTaskGetTickCountFromISR</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv424xTaskGetTickCountFromISRv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ტკიპების რაოდენობა ISR-დან</p>
<p><p>ეს არის xTaskGetTickCount()-ის ვერსია, რომლის გამოძახებაც უსაფრთხოა ISR-დან - იმ პირობით, რომ TickType_t არის გამოყენებული მიკროკონტროლერი ის ბუნებრივი სიტყვის ზომა ან შეწყვეტის ჩადგმა ან არ არის მხარდაჭერილი, ან არ გამოიყენება. </p>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The count of ticks since vTaskStartScheduler was called.</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422uxTaskGetNumberOfTasksv">
<span id="_CPPv322uxTaskGetNumberOfTasksv"></span><span id="_CPPv222uxTaskGetNumberOfTasksv"></span><span id="uxTaskGetNumberOfTasks__void"></span><span class="target" id="task_8h_1a70a89a0f07c7db5d695707d1f6f44a4a"></span>UBaseType_t <code class="descname">uxTaskGetNumberOfTasks</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422uxTaskGetNumberOfTasksv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ დავალებების მიმდინარე რაოდენობა</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The number of tasks that the real time kernel is currently managing. This includes all ready, blocked and suspended tasks. A task that has been deleted but not yet freed by the idle task will also be included in the count. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417pcTaskGetTaskName12TaskHandle_t">
<span id="_CPPv317pcTaskGetTaskName12TaskHandle_t"></span><span id="_CPPv217pcTaskGetTaskName12TaskHandle_t"></span><span id="pcTaskGetTaskName__TaskHandle_t"></span><span class="target" id="task_8h_1a4344bd56963429dfa26b0af913349e84"></span>char *<code class="descname">pcTaskGetTaskName</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToQuery</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417pcTaskGetTaskName12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ დავალების სახელი</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The text (human readable) name of the task referenced by the handle xTaskToQuery. A task can query its own name by either passing in its own handle, or by setting xTaskToQuery to NULL. INCLUDE_pcTaskGetTaskName must be set to 1 in FreeRTOSConfig.h for pcTaskGetTaskName() to be available. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t">
<span id="_CPPv327uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="_CPPv227uxTaskGetStackHighWaterMark12TaskHandle_t"></span><span id="uxTaskGetStackHighWaterMark__TaskHandle_t"></span><span class="target" id="task_8h_1a799967af01d328132cde814e47733437"></span>UBaseType_t <code class="descname">uxTaskGetStackHighWaterMark</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv427uxTaskGetStackHighWaterMark12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს xTask-თან ასოცირებული დასტის ყველაზე მაღალ ნიშნულს.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის Free RTOS Config.h ფაილში INCLUDE_uxTaskGetStackHighWaterMark უნდა იყოს დაყენებული 1-ზე.</p>
<p>მაღალი წყლის ნიშანი არის მინიმალური თავისუფალი სივრცე, რომელიც დავალების დაწყებიდან დარჩა (ბაიტებში და არა სიტყვებში, როგორც ეს ჩვეულებრივ Free RTOS შია მოცემული). რაც უფრო პატარაა დაბრუნებული რიცხვი, მით უფრო ახლოსაა დავალება დასტის გადავსებასთან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The smallest amount of free stack space there has been (in bytes rather than words as found in vanilla FreeRTOS) since the task referenced by xTask was created. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>შესამოწმებელ დასტასთან დაკავშირებული დავალების სახელური. დააყენეთ xTask NULL-ზე გამომძახებელი დავალების დასტის შესამოწმებლად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419pxTaskGetStackStart12TaskHandle_t">
<span id="_CPPv319pxTaskGetStackStart12TaskHandle_t"></span><span id="_CPPv219pxTaskGetStackStart12TaskHandle_t"></span><span id="pxTaskGetStackStart__TaskHandle_t"></span><span class="target" id="task_8h_1aba038232967f96f9f572d85c01637ad9"></span>uint8_t *<code class="descname">pxTaskGetStackStart</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419pxTaskGetStackStart12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს xTask-თან ასოცირებული დასტის დასაწყისს.</p>
<p>იმისათვის, რომ ეს ფუნქცია ხელმისაწვდომი იყოს, Free RTOS Config.h ფაილში INCLUDE_pxTaskGetStackStart უნდა იყოს დაყენებული 1-ზე.</p>
<p>აბრუნებს ყველაზე მაღალი დასტის მეხსიერების მისამართს არქიტექტურებში, სადაც დასტა მაღალი მეხსიერებიდან მცირდება, და ყველაზე დაბალი მეხსიერების მისამართს არქიტექტურებში, სადაც დასტა დაბალი მეხსიერებიდან იზრდება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>A pointer to the start of the stack. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>დაბრუნებულ დასტასთან დაკავშირებული დავალების სახელური. დააყენეთ xTask NULL-ზე გამომძახებელი დავალების დასტის დასაბრუნებლად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t">
<span id="_CPPv326vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="_CPPv226vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t"></span><span id="vTaskSetApplicationTaskTag__TaskHandle_t.TaskHookFunction_t"></span><span class="target" id="task_8h_1a179295989890733e4f049eacb5114443"></span>void <code class="descname">vTaskSetApplicationTaskTag</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, <a class="reference internal" href="freertos.html#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t">TaskHookFunction_t</a> <em>pxHookFunction</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv426vTaskSetApplicationTaskTag12TaskHandle_t18TaskHookFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აყენებს pxHookFunction-ს, როგორც xTask-ის მიერ გამოყენებულ დავალების hook ფუნქციას. <dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>xTask-ის NULL-ად გადაცემით, დაყენებულია tasks-ის hook ფუნქციის გამოძახების ფუნქცია. </li>
<li><code class="docutils literal notranslate"><span class="pre">pxHookFunction</span></code>: მიმთითებელი კაუჭის ფუნქციაზე. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t">
<span id="_CPPv326xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="_CPPv226xTaskGetApplicationTaskTag12TaskHandle_t"></span><span id="xTaskGetApplicationTaskTag__TaskHandle_t"></span><span class="target" id="task_8h_1a990a40ecfe8059b0a8adbf8daa4512dd"></span><a class="reference internal" href="freertos.html#_CPPv418TaskHookFunction_t" title="TaskHookFunction_t">TaskHookFunction_t</a> <code class="descname">xTaskGetApplicationTaskTag</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv426xTaskGetApplicationTaskTag12TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული დავალებისთვის მინიჭებული ჰუკის ფუნქცია. <dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The pxHookFunction value assigned to the task xTask. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>xTask-ის NULL-ად გავლისას მიიღება tasks-ის hook ფუნქცია. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv">
<span id="_CPPv333vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="_CPPv233vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv"></span><span id="vTaskSetThreadLocalStoragePointer__TaskHandle_t.BaseType_t.voidP"></span><span class="target" id="task_8h_1a33e663d3bab72a691d131e125503e59b"></span>void <code class="descname">vTaskSetThreadLocalStoragePointer</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSet</em>, BaseType_t <em>xIndex</em>, void *<em>pvValue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv433vTaskSetThreadLocalStoragePointer12TaskHandle_t10BaseType_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოცემული ამოცანისთვის სპეციფიკური ლოკალური შენახვის მაჩვენებლის დაყენება.</p>
<p>თითოეული დავალება შეიცავს მაჩვენებლების მასივს, რომლის ზომებიც Free RTOS Config.h ფაილში configNUM_THREAD_LOCAL_STORAGE_POINTERS პარამეტრით არის განსაზღვრული. ბირთვი თავად არ იყენებს მაჩვენებლებს, ამიტომ აპლიკაციის შემქმნელს შეუძლია მათი გამოყენება ნებისმიერი მიზნით.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSet</span></code>: დავალება ძაფის ლოკალური შენახვის მაჩვენებლის დაყენება </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>დასაყენებელი მაჩვენებლის ინდექსი, 0-დან configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1-მდე. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvValue</span></code>: დასაყენებელი მაჩვენებლის მნიშვნელობა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t">
<span id="_CPPv334pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="_CPPv234pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t"></span><span id="pvTaskGetThreadLocalStoragePointer__TaskHandle_t.BaseType_t"></span><span class="target" id="task_8h_1a41c410d6ee9fbf9e882d1a2962f437e0"></span>void *<code class="descname">pvTaskGetThreadLocalStoragePointer</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToQuery</em>, BaseType_t <em>xIndex</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv434pvTaskGetThreadLocalStoragePointer12TaskHandle_t10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული დავალების სპეციფიკური ლოკალური შენახვის მაჩვენებელი.</p>
<p>თითოეული დავალება შეიცავს მაჩვენებლების მასივს, რომლის ზომებიც Free RTOS Config.h ფაილში configNUM_THREAD_LOCAL_STORAGE_POINTERS პარამეტრით არის განსაზღვრული. ბირთვი თავად არ იყენებს მაჩვენებლებს, ამიტომ აპლიკაციის შემქმნელს შეუძლია მათი გამოყენება ნებისმიერი მიზნით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Pointer value </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToQuery</span></code>: დავალება ძაფის ლოკალური შენახვის მაჩვენებლის მისაღებად </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>: მისაღებად მაჩვენებლის ინდექსი, 0-დან configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1-მდე. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t">
<span id="_CPPv347vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="_CPPv247vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t"></span><span id="vTaskSetThreadLocalStoragePointerAndDelCallback__TaskHandle_t.BaseType_t.voidP.TlsDeleteCallbackFunction_t"></span><span class="target" id="task_8h_1ae29bfc51bcf923b80f2d2598c3b51dcd"></span>void <code class="descname">vTaskSetThreadLocalStoragePointerAndDelCallback</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToSet</em>, BaseType_t <em>xIndex</em>, void *<em>pvValue</em>, <a class="reference internal" href="freertos.html#_CPPv427TlsDeleteCallbackFunction_t" title="TlsDeleteCallbackFunction_t">TlsDeleteCallbackFunction_t</a> <em>pvDelCallback</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv447vTaskSetThreadLocalStoragePointerAndDelCallback12TaskHandle_t10BaseType_tPv27TlsDeleteCallbackFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ლოკალური შენახვის მაჩვენებლის და წაშლის უკუკავშირის დაყენება.</p>
<p>თითოეული დავალება შეიცავს მაჩვენებლების მასივს, რომლის ზომებიც Free RTOS Config.h ფაილში configNUM_THREAD_LOCAL_STORAGE_POINTERS პარამეტრით არის განსაზღვრული. ბირთვი თავად არ იყენებს მაჩვენებლებს, ამიტომ აპლიკაციის შემქმნელს შეუძლია მათი გამოყენება ნებისმიერი მიზნით.</p>
<p>დავალებისთვის დაყენებული ლოკალური შენახვის მაჩვენებლები შეიძლება მიუთითებდეს დინამიურად გამოყოფილ რესურსებზე. ეს ფუნქცია vTaskSetThreadLocalStoragePointer-ის მსგავსია, მაგრამ უზრუნველყოფს ამ რესურსების გათავისუფლების გზას დავალების წაშლისას. თითოეული მაჩვენებლისთვის შესაძლებელია უკუკავშირის ფუნქციის დაყენება. ეს ფუნქცია გამოიძახება დავალების წაშლისას, ლოკალური შენახვის მაჩვენებლის ინდექსით და მნიშვნელობით, როგორც არგუმენტებით.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToSet</span></code>: დავალება ძაფის ლოკალური შენახვის მაჩვენებლის დაყენება </li>
<li><code class="docutils literal notranslate"><span class="pre">xIndex</span></code>დასაყენებელი მაჩვენებლის ინდექსი, 0-დან configNUM_THREAD_LOCAL_STORAGE_POINTERS - 1-მდე. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvValue</span></code>: დასაყენებელი მაჩვენებლის მნიშვნელობა. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvDelCallback</span></code>ფუნქცია, რომელიც გამოიძახება ლოკალური შენახვის მაჩვენებლის გასანეიტრალებლად დავალების წაშლისას. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv">
<span id="_CPPv328xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="_CPPv228xTaskCallApplicationTaskHook12TaskHandle_tPv"></span><span id="xTaskCallApplicationTaskHook__TaskHandle_t.voidP"></span><span class="target" id="task_8h_1ab6607e5d8a9664e3aa9fe16efa694e83"></span>BaseType_t <code class="descname">xTaskCallApplicationTaskHook</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTask</em>, void *<em>pvპარამეტრი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv428xTaskCallApplicationTaskHook12TaskHandle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიძახებს xTask-თან ასოცირებულ hook ფუნქციას. xTask-ის NULL-ად გადაცემა იწვევს Running tasks-ის (დავალების გამომძახებელი) hook ფუნქციის გამოძახებას.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTask</span></code>: კაუჭის გამოსაძახებელი დავალების სახელური. </li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter</span></code>პარამეტრი, რომელიც გადაეცემა hook ფუნქციას დავალებისთვის, რათა მან სასურველი ინტერპრეტაცია გაუკეთოს. დაბრუნებული მნიშვნელობა არის მომხმარებლის მიერ რეგისტრირებული task hook ფუნქციის მიერ დაბრუნებული მნიშვნელობა. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422xTaskGetIdleTaskHandlev">
<span id="_CPPv322xTaskGetIdleTaskHandlev"></span><span id="_CPPv222xTaskGetIdleTaskHandlev"></span><span id="xTaskGetIdleTaskHandle__void"></span><span class="target" id="task_8h_1a38e3c3df6fc5b28c14459e32474917fb"></span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskGetIdleTaskHandle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422xTaskGetIdleTaskHandlev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მიმდინარე CPU-სთვის უმოქმედო დავალების სახელური.</p>
<p>xTaskGetIdleTaskHandle() მხოლოდ მაშინ არის ხელმისაწვდომი, თუ Free RTOS Config.h ფაილში INCLUDE_xTaskGetIdleTaskHandle დაყენებულია 1-ზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The handle of the idle task. It is not valid to call xTaskGetIdleTaskHandle() before the scheduler has been started. </dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv428xTaskGetIdleTaskHandleForCPU11UBaseType_t">
<span id="_CPPv328xTaskGetIdleTaskHandleForCPU11UBaseType_t"></span><span id="_CPPv228xTaskGetIdleTaskHandleForCPU11UBaseType_t"></span><span id="xTaskGetIdleTaskHandleForCPU__UBaseType_t"></span><span class="target" id="task_8h_1a9cc9b6611e5b3d64ab32d6e07651ae9b"></span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTaskGetIdleTaskHandleForCPU</code><span class="sig-paren">(</span>UBaseType_t <em>პროცესორის ID</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv428xTaskGetIdleTaskHandleForCPU11UBaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ მოცემული CPU-სთვის უმოქმედო დავალების სახელური.</p>
<p>xTaskGetIdleTaskHandleForCPU() მხოლოდ მაშინ არის ხელმისაწვდომი, თუ Free RTOS Config.h ფაილში INCLUDE_xTaskGetIdleTaskHandle დაყენებულია 1-ზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Idle task handle of a given cpu. It is not valid to call xTaskGetIdleTaskHandleForCPU() before the scheduler has been started. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cpuid</span></code>: CPU, რომლისთვისაც სახელური უნდა იქნას მიღებული</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t">
<span id="_CPPv320uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t"></span><span id="_CPPv220uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t"></span><span id="uxTaskGetSystemState__TaskStatus_tPC.UBaseType_tC.uint32_tPC"></span><span class="target" id="task_8h_1a5bd92b080086390cae790e5bd74bd018"></span>UBaseType_t <code class="descname">uxTaskGetSystemState</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskStatus_t" title="TaskStatus_t">დავალების სტატუსი_t</a> *<em class="property">კონსტ</em> <em>pxTaskStatusArray</em>, <em class="property">კონსტ</em> UBaseType_t <em>uxArraySize</em>, uint32_t *<em class="property">კონსტ</em> <em>pulTotalRunTime</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv420uxTaskGetSystemStatePC12TaskStatus_tK11UBaseType_tPC8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ სისტემაში დავალებების მდგომარეობა.</p>
<p>configUSE_TRACE_FACILITY Free RTOS Config.h ფაილში უნდა განისაზღვროს, როგორც 1, რათა uxTaskGetSystemState() ხელმისაწვდომი იყოს.</p>
<p>uxTaskGetSystemState() სისტემაში თითოეული დავალებისთვის ავსებს TaskStatus_t სტრუქტურას. TaskStatus_t სტრუქტურები, სხვა საკითხებთან ერთად, შეიცავს დავალების სახელურის წევრებს, დავალების სახელს, დავალების პრიორიტეტს, დავალების მდგომარეობას და დავალებით დახარჯული შესრულების დროის საერთო რაოდენობას. წევრების სრული სიისთვის იხილეთ TaskStatus_t სტრუქტურის განმარტება ამ ფაილში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// This example demonstrates how a human readable table of run time stats
// information is generated from raw data provided by uxTaskGetSystemState().
// The human readable table is written to pcWriteBuffer
void vTaskGetRunTimeStats( char *pcWriteBuffer )
{
TaskStatus_t *pxTaskStatusArray;
volatile UBaseType_t uxArraySize, x;
uint32_t ulTotalRunTime, ulStatsAsPercentage;

 // Make sure the write buffer does not contain a string.
 *pcWriteBuffer = 0x00;

 // Take a snapshot of the number of tasks in case it changes while this
 // function is executing.
 uxArraySize = uxTaskGetNumberOfTasks();

 // Allocate a TaskStatus_t structure for each task.  An array could be
 // allocated statically at compile time.
 pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );

 if( pxTaskStatusArray != NULL )
 {
     // Generate raw status information about each task.
     uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &amp;ulTotalRunTime );

     // For percentage calculations.
     ulTotalRunTime /= 100UL;

     // Avoid divide by zero errors.
     if( ulTotalRunTime &gt; 0 )
     {
         // For each populated position in the pxTaskStatusArray array,
         // format the raw data as human readable ASCII data
         for( x = 0; x &lt; uxArraySize; x++ )
         {
             // What percentage of the total run time has the task used?
             // This will always be rounded down to the nearest integer.
             // ulTotalRunTimeDiv100 has already been divided by 100.
             ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;

             if( ulStatsAsPercentage &gt; 0UL )
             {
                 sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
             }
             else
             {
                 // If the percentage is zero here then the task has
                 // consumed less than 1% of the total run time.
                 sprintf( pcWriteBuffer, "%s\t\t%lu\t\t&lt;1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
             }

             pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
         }
     }

     // The array is no longer needed, free the memory it consumes.
     vPortFree( pxTaskStatusArray );
 }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function is intended for debugging use only as its use results in the scheduler remaining suspended for an extended period.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd>The number of TaskStatus_t structures that were populated by uxTaskGetSystemState(). This should equal the number returned by the uxTaskGetNumberOfTasks() API function, but will be zero if the value passed in the uxArraySize parameter was too small.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxTaskStatusArray</span></code>: TaskStatus_t სტრუქტურების მასივის მაჩვენებელი. მასივი უნდა შეიცავდეს მინიმუმ ერთ TaskStatus_t სტრუქტურას თითოეული დავალებისთვის, რომელიც RTOS ის კონტროლის ქვეშაა. RTOS ის კონტროლის ქვეშ მყოფი დავალებების რაოდენობის დადგენა შესაძლებელია uxTaskGetNumberOfTasks() API ფუნქციის გამოყენებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxArraySize</span></code>: მასივის ზომა, რომელზეც მიუთითებს pxTaskStatusArray პარამეტრი. ზომა განისაზღვრება მასივში ინდექსების რაოდენობით ან მასივში შემავალი TaskStatus_t სტრუქტურების რაოდენობით და არა მასივში ბაიტების რაოდენობით.</li>
<li><code class="docutils literal notranslate"><span class="pre">pulTotalRunTime</span></code>თუ Free RTOS Config.h ფაილში configGENERATE_RUN_TIME_STATS დაყენებულია 1-ზე, მაშინ *pulTotalRunTime uxTaskGetSystemState() ფუნქციის მიერ დაყენებულია მთლიან გაშვების დროზე (როგორც განსაზღვრულია გაშვების დროის სტატისტიკის საათით, იხ. <a class="reference external" href="http://www.freertos.org/rtos-run-time-stats.html">http://www.freertos.org/rtos-run-time-stats.html</a>) სამიზნე ჩატვირთვის შემდეგ. pulTotalRunTime შეიძლება დაყენდეს NULL-ზე, რათა გამოტოვოთ სრული გაშვების დროის ინფორმაცია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv49vTaskListPc">
<span id="_CPPv39vTaskListPc"></span><span id="_CPPv29vTaskListPc"></span><span id="vTaskList__cP"></span><span class="target" id="task_8h_1ab87abc717f34ddced76802d12588a93d"></span>void <code class="descname">vTaskList</code><span class="sig-paren">(</span>char *<em>pcWriteBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv49vTaskListPc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩამოთვალეთ ყველა მიმდინარე დავალება.</p>
<p>ამ ფუნქციის ხელმისაწვდომობისთვის, configUSE_TRACE_FACILITY და configUSE_STATS_FORMATTING_FUNCTIONS ორივე უნდა იყოს განსაზღვრული, როგორც 1. დამატებითი ინფორმაციისთვის იხილეთ Free RTOS .org ვებსაიტის კონფიგურაციის განყოფილება.</p>
<p><p>ჩამოთვლილია ყველა მიმდინარე დავალება, მათი მიმდინარე მდგომარეობისა და დასტის გამოყენების მაქსიმალური ნიშნულის მითითებით.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</dd>
</dl>
</p>
<p>დავალებები მოხსენებულია, როგორც დაბლოკილი („B“), მზად („R“), წაშლილი („D“) ან შეჩერებული („S“).</p>
<p><p>vTaskList() გამოიძახებს uxTaskGetSystemState() ფუნქციას, შემდეგ კი uxTaskGetSystemState() გამომავალი ნაწილის ფორმატში აფორმებს ადამიანის მიერ წასაკითხ ცხრილში, რომელიც აჩვენებს დავალებების სახელებს, მდგომარეობებს და დასტის გამოყენებას.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</dd>
</dl>
</p>
<p>vTaskList() ფუნქციას აქვს დამოკიდებულება sprintf() C ბიბლიოთეკის ფუნქციაზე, რამაც შეიძლება გაზარდოს კოდის ზომა, გამოიყენოს დიდი რაოდენობით სტეკი და სხვადასხვა პლატფორმაზე განსხვავებული შედეგები მოგვცეს. sprintf()-ის ალტერნატიული, პატარა, მესამე მხარის და შეზღუდული ფუნქციონალურობის იმპლემენტაცია მოცემულია Free RTOS /Demo-ს მრავალ ქვედირექტორიაში printf-stdarg.c სახელწოდების ფაილში (გაითვალისწინეთ, რომ printf-stdarg.c არ იძლევა snprintf()-ის სრულ იმპლემენტაციას!).</p>
<p>რეკომენდებულია, რომ წარმოების სისტემებმა uxTaskGetSystemState() პირდაპირ გამოიძახონ ნედლი სტატისტიკის მონაცემებზე წვდომის მისაღებად და არა ირიბად vTaskList()-ის გამოძახებით.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcWriteBuffer</span></code>ბუფერი, რომელშიც ზემოთ აღნიშნული დეტალები ჩაიწერება ASCII ფორმატში. ვარაუდობენ, რომ ეს ბუფერი საკმარისად დიდია გენერირებული ანგარიშის მოსათავსებლად. დაახლოებით 40 ბაიტი თითო დავალებაზე საკმარისი უნდა იყოს. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420vTaskGetRunTimeStatsPc">
<span id="_CPPv320vTaskGetRunTimeStatsPc"></span><span id="_CPPv220vTaskGetRunTimeStatsPc"></span><span id="vTaskGetRunTimeStats__cP"></span><span class="target" id="task_8h_1a52da9b427041a48dc9f6802e10f151d4"></span>void <code class="descname">vTaskGetRunTimeStats</code><span class="sig-paren">(</span>char *<em>pcWriteBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv420vTaskGetRunTimeStatsPc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ გაშვებული დავალებების მდგომარეობა სტრიქონის სახით</p>
<p>configGENERATE_RUN_TIME_STATS და configUSE_STATS_FORMATTING_FUNCTIONS ორივე უნდა იყოს განსაზღვრული, როგორც 1, რათა ეს ფუნქცია ხელმისაწვდომი იყოს. აპლიკაციამ ასევე უნდა უზრუნველყოს portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() და portGET_RUN_TIME_COUNTER_VALUE() ფუნქციების განმარტებები პერიფერიული ტაიმერის/მრიცხველის კონფიგურაციისთვის და ტაიმერების მიმდინარე დათვლის მნიშვნელობის დასაბრუნებლად, შესაბამისად. მრიცხველი უნდა იყოს მინიმუმ 10-ჯერ მეტი ტიკების დათვლის სიხშირეზე.</p>
<p><p>configGENERATE_RUN_TIME_STATS-ის 1-ზე დაყენების შემთხვევაში, თითოეული დავალების შესრულების დრო შენახული იქნება. დაგროვილი დროის მნიშვნელობის გარჩევადობა დამოკიდებულია portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() მაკროს მიერ კონფიგურირებული ტაიმერის სიხშირეზე. vTaskGetRunTimeStats()-ის გამოძახებით, თითოეული დავალების შესრულების დრო ბუფერში იწერება, როგორც აბსოლუტური რაოდენობის მნიშვნელობის, ასევე სისტემის შესრულების მთლიანი დროის პროცენტული მაჩვენებლის სახით.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.</dd>
</dl>
</p>
<p><p>vTaskGetRunTimeStats() გამოიძახებს uxTaskGetSystemState() ფუნქციას, შემდეგ კი uxTaskGetSystemState() გამომავალი ფუნქციის ნაწილს აფორმებს ადამიანის მიერ წასაკითხ ცხრილში, რომელიც აჩვენებს თითოეული დავალების მიერ გაშვებულ მდგომარეობაში გატარებულ დროს, როგორც აბსოლუტურ, ასევე პროცენტულ მაჩვენებლებში.</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function is provided for convenience only, and is used by many of the demo applications. Do not consider it to be part of the scheduler.</dd>
</dl>
</p>
<p>vTaskGetRunTimeStats() ფუნქცია დამოკიდებულია sprintf() C ბიბლიოთეკის ფუნქციაზე, რამაც შეიძლება გაზარდოს კოდის ზომა, გამოიყენოს დიდი რაოდენობით სტეკი და სხვადასხვა პლატფორმაზე განსხვავებული შედეგები მოგვცეს. sprintf()-ის ალტერნატიული, პატარა, მესამე მხარის და შეზღუდული ფუნქციონალურობის იმპლემენტაცია მოცემულია Free RTOS /Demo-ს მრავალ ქვედირექტორიაში printf-stdarg.c სახელწოდების ფაილში (გაითვალისწინეთ, რომ printf-stdarg.c არ იძლევა snprintf()-ის სრულ იმპლემენტაციას!).</p>
<p>რეკომენდებულია, რომ წარმოების სისტემებმა uxTaskGetSystemState() პირდაპირ გამოიძახონ ნედლი სტატისტიკის მონაცემებზე წვდომის მისაღებად და არა ირიბად vTaskGetRunTimeStats()-ის გამოძახებით.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcWriteBuffer</span></code>ბუფერი, რომელშიც შესრულების დრო ჩაიწერება ASCII ფორმატში. ვარაუდობენ, რომ ეს ბუფერი საკმარისად დიდია გენერირებული ანგარიშის მოსათავსებლად. დაახლოებით 40 ბაიტი თითო დავალებაზე საკმარისი უნდა იყოს. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv411xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction">
<span id="_CPPv311xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction"></span><span id="_CPPv211xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction"></span><span id="xTaskNotify__TaskHandle_t.uint32_t.eNotifyAction"></span><span class="target" id="task_8h_1af765b8c28d01be648c56efe92d544b44"></span>BaseType_t <code class="descname">xTaskNotify</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, uint32_t <em>ulValue</em>, <a class="reference internal" href="freertos.html#_CPPv413eNotifyAction" title="eNotifyAction">eNotifyAction</a> <em>ელექტრონული მოქმედება</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv411xTaskNotify12TaskHandle_t8uint32_t13eNotifyAction" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შეტყობინების გაგზავნა.</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს ფუნქცია ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>დავალების შესასრულებლად გაგზავნილი შეტყობინება მოლოდინის რეჟიმში დარჩება მანამ, სანამ მას არ გაასუფთავებს დავალება xTaskNotifyWait() ან ulTaskNotifyTake() გამოძახებით. თუ დავალება უკვე დაბლოკილ მდგომარეობაში იყო და შეტყობინების მოსვლისას შეტყობინებას ელოდა, მაშინ დავალება ავტომატურად მოიხსნება დაბლოკილი მდგომარეობიდან (განიბლოკება) და შეტყობინება წაიშლება.</p>
<p>დავალებას შეუძლია გამოიყენოს xTaskNotifyWait() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მოლოდინის დასაწყებად, ან ulTaskNotifyTake() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მნიშვნელობის ნულოვანი მნიშვნელობის მიღების დასაწყებად. დაბლოკილი მდგომარეობაში ყოფნისას დავალება არ ხარჯავს CPU-ს დროს.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Dependent on the value of eAction. See the description of the eAction parameter. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: შეტყობინების მიმღები დავალების სახელური. დავალების სახელურის დაბრუნება შესაძლებელია xTaskCreate() API ფუნქციიდან, რომელიც გამოიყენება დავალების შესაქმნელად, ხოლო ამჟამად შესრულებული დავალების სახელურის მიღება შესაძლებელია xTaskGetCurrentTaskHandle()-ის გამოძახებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulValue</span></code>შეტყობინებასთან ერთად გასაგზავნი მონაცემები. მონაცემების გამოყენების წესი დამოკიდებულია eAction პარამეტრის მნიშვნელობაზე.</li>
<li><code class="docutils literal notranslate"><span class="pre">eAction</span></code>: განსაზღვრავს, თუ როგორ განაახლებს შეტყობინება დავალების შეტყობინების მნიშვნელობას, თუ საერთოდ განაახლებს. eAction-ის ვალიდური მნიშვნელობებია შემდეგი:<ul>
<li>eSetBits: დავალების შეტყობინების მნიშვნელობა ბიტურად OR-ით რეგულირდება ulValue-ით. ამ შემთხვევაში xTaskNofify() ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eIncrement: დავალების შეტყობინების მნიშვნელობა იზრდება. ulValue არ გამოიყენება და xTaskNotify() ამ შემთხვევაში ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eSetValueWithOverwrite: დავალების შეტყობინების მნიშვნელობად დაყენებულია ulValue მნიშვნელობა, მაშინაც კი, თუ შეტყობინებაზე მიღებულ დავალებას ჯერ არ დაუმუშავებია წინა შეტყობინება (დავალებას უკვე ჰქონდა შეტყობინება, რომელიც ელოდება). ამ შემთხვევაში xTaskNotify() ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eSetValueWithoutOverwrite: თუ შეტყობინებაზე მიღებულ დავალებას უკვე არ ჰქონდა მოლოდინის რეჟიმში მყოფი შეტყობინება, მაშინ დავალების შეტყობინების მნიშვნელობა დაყენებულია ulValue-ზე და xTaskNotify() დააბრუნებს pdPASS-ს. თუ შეტყობინებაზე მიღებულ დავალებას უკვე ჰქონდა მოლოდინის რეჟიმში მყოფი შეტყობინება, მაშინ არანაირი მოქმედება არ შესრულდება და დაბრუნდება pdFAIL.</li>
<li>eNoAction: დავალება იღებს შეტყობინებას მისი შეტყობინების მნიშვნელობის განახლების გარეშე. ulValue არ გამოიყენება და xTaskNotify() ამ შემთხვევაში ყოველთვის აბრუნებს pdPASS-ს.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t">
<span id="_CPPv318xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t"></span><span id="_CPPv218xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t"></span><span id="xTaskNotifyFromISR__TaskHandle_t.uint32_t.eNotifyAction.BaseType_tP"></span><span class="target" id="task_8h_1a2c7892a9835d67e7b080eddafc6ce0e7"></span>BaseType_t <code class="descname">xTaskNotifyFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, uint32_t <em>ulValue</em>, <a class="reference internal" href="freertos.html#_CPPv413eNotifyAction" title="eNotifyAction">eNotifyAction</a> <em>ელექტრონული მოქმედება</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv418xTaskNotifyFromISR12TaskHandle_t8uint32_t13eNotifyActionP10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შესახებ შეტყობინების გაგზავნა ISR-დან.</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს ფუნქცია ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>xTaskNotify()-ის ვერსია, რომლის გამოყენებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან (ISR).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>დავალების შესასრულებლად გაგზავნილი შეტყობინება მოლოდინის რეჟიმში დარჩება მანამ, სანამ მას არ გაასუფთავებს დავალება xTaskNotifyWait() ან ulTaskNotifyTake() გამოძახებით. თუ დავალება უკვე დაბლოკილ მდგომარეობაში იყო და შეტყობინების მოსვლისას შეტყობინებას ელოდა, მაშინ დავალება ავტომატურად მოიხსნება დაბლოკილი მდგომარეობიდან (განიბლოკება) და შეტყობინება წაიშლება.</p>
<p>დავალებას შეუძლია გამოიყენოს xTaskNotifyWait() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მოლოდინის დასაწყებად, ან ulTaskNotifyTake() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მნიშვნელობის ნულოვანი მნიშვნელობის მიღების დასაწყებად. დაბლოკილი მდგომარეობაში ყოფნისას დავალება არ ხარჯავს CPU-ს დროს.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Dependent on the value of eAction. See the description of the eAction parameter. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: შეტყობინების მიმღები დავალების სახელური. დავალების სახელურის დაბრუნება შესაძლებელია xTaskCreate() API ფუნქციიდან, რომელიც გამოიყენება დავალების შესაქმნელად, ხოლო ამჟამად შესრულებული დავალების სახელურის მიღება შესაძლებელია xTaskGetCurrentTaskHandle()-ის გამოძახებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulValue</span></code>შეტყობინებასთან ერთად გასაგზავნი მონაცემები. მონაცემების გამოყენების წესი დამოკიდებულია eAction პარამეტრის მნიშვნელობაზე.</li>
<li><code class="docutils literal notranslate"><span class="pre">eAction</span></code>: განსაზღვრავს, თუ როგორ განაახლებს შეტყობინება დავალების შეტყობინების მნიშვნელობას, თუ საერთოდ განაახლებს. eAction-ის ვალიდური მნიშვნელობებია შემდეგი:<ul>
<li>eSetBits: დავალების შეტყობინების მნიშვნელობა ბიტურად OR-ით რეგულირდება ulValue-ით. ამ შემთხვევაში xTaskNofify() ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eIncrement: დავალების შეტყობინების მნიშვნელობა იზრდება. ulValue არ გამოიყენება და xTaskNotify() ამ შემთხვევაში ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eSetValueWithOverwrite: დავალების შეტყობინების მნიშვნელობად დაყენებულია ulValue მნიშვნელობა, მაშინაც კი, თუ შეტყობინებაზე მიღებულ დავალებას ჯერ არ დაუმუშავებია წინა შეტყობინება (დავალებას უკვე ჰქონდა შეტყობინება, რომელიც ელოდება). ამ შემთხვევაში xTaskNotify() ყოველთვის აბრუნებს pdPASS-ს.</li>
<li>eSetValueWithoutOverwrite: თუ შეტყობინებაზე მიღებულ დავალებას უკვე არ ჰქონდა მოლოდინის რეჟიმში მყოფი შეტყობინება, მაშინ დავალების შეტყობინების მნიშვნელობა დაყენებულია ulValue-ზე და xTaskNotify() დააბრუნებს pdPASS-ს. თუ შეტყობინებაზე მიღებულ დავალებას უკვე ჰქონდა მოლოდინის რეჟიმში მყოფი შეტყობინება, მაშინ არანაირი მოქმედება არ შესრულდება და დაბრუნდება pdFAIL.</li>
<li>eNoAction: დავალება იღებს შეტყობინებას მისი შეტყობინების მნიშვნელობის განახლების გარეშე. ulValue არ გამოიყენება და xTaskNotify() ამ შემთხვევაში ყოველთვის აბრუნებს pdPASS-ს.</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>xTaskNotifyFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ შეტყობინების გაგზავნამ გამოიწვია დავალების, რომელზეც შეტყობინება გაიგზავნა, დაბლოკილი მდგომარეობიდან გასვლა და განბლოკილი დავალების პრიორიტეტი უფრო მაღალია, ვიდრე ამჟამად გაშვებული დავალება. თუ xTaskNotifyFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეფერხებიდან გასვლამდე უნდა მოითხოვონ კონტექსტური გადამრთველი. ISR-დან კონტექსტური გადამრთველის მოთხოვნის წესი დამოკიდებულია პორტზე - იხილეთ გამოყენებული პორტის დოკუმენტაციის გვერდი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t">
<span id="_CPPv315xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="_CPPv215xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t"></span><span id="xTaskNotifyWait__uint32_t.uint32_t.uint32_tP.TickType_t"></span><span class="target" id="task_8h_1a7cab914767933dc732f2c36e3915f6b0"></span>BaseType_t <code class="descname">xTaskNotifyWait</code><span class="sig-paren">(</span>uint32_t <em>ulBitsToClearOnEntry</em>, uint32_t <em>ulBitsToClearOnExit</em>, uint32_t *<em>pulNotificationValue</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415xTaskNotifyWait8uint32_t8uint32_tP8uint32_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაელოდეთ დავალების შეტყობინებას</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს ფუნქცია ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>დავალების შესასრულებლად გაგზავნილი შეტყობინება მოლოდინის რეჟიმში დარჩება მანამ, სანამ მას არ გაასუფთავებს დავალება xTaskNotifyWait() ან ulTaskNotifyTake() გამოძახებით. თუ დავალება უკვე დაბლოკილ მდგომარეობაში იყო და შეტყობინების მოსვლისას შეტყობინებას ელოდა, მაშინ დავალება ავტომატურად მოიხსნება დაბლოკილი მდგომარეობიდან (განიბლოკება) და შეტყობინება წაიშლება.</p>
<p>დავალებას შეუძლია გამოიყენოს xTaskNotifyWait() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მოლოდინის დასაწყებად, ან ulTaskNotifyTake() [არასავალდებულო] დაბლოკვისთვის და შეტყობინების მნიშვნელობის ნულოვანი მნიშვნელობის მიღების დასაწყებად. დაბლოკილი მდგომარეობაში ყოფნისას დავალება არ ხარჯავს CPU-ს დროს.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If a notification was received (including notifications that were already pending when xTaskNotifyWait was called) then pdPASS is returned. Otherwise pdFAIL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ulBitsToClearOnEntry</span></code>: ulBitsToClearOnEntry მნიშვნელობაში დაყენებული ბიტები წაიშლება გამომძახებელი დავალების შეტყობინების მნიშვნელობაში, სანამ დავალება შეამოწმებს, არის თუ არა რაიმე შეტყობინება მოლოდინში და სურვილისამებრ დაიბლოკება, თუ არცერთი შეტყობინება არ არის მოლოდინში. ulBitsToClearOnEntry-ს ULONG_MAX-ზე (თუ limits.h შედის) ან 0xffffffffUL-ზე (თუ limits.h არ შედის) დაყენება გამოიწვევს დავალების შეტყობინების მნიშვნელობის 0-ზე გადატვირთვას. ulBitsToClearOnEntry-ს 0-ზე დაყენება დავალების შეტყობინების მნიშვნელობას უცვლელს დატოვებს.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulBitsToClearOnExit</span></code>თუ შეტყობინება მოლოდინშია ან მიღებულია xTaskNotifyWait() ფუნქციის გამოძახებამდე, მაშინ დავალების შეტყობინების მნიშვნელობა (იხილეთ xTaskNotify() API ფუნქცია) გადაეცემა pulNotificationValue პარამეტრის გამოყენებით. შემდეგ ulBitsToClearOnExit-ში დაყენებული ნებისმიერი ბიტი წაიშლება დავალების შეტყობინების მნიშვნელობაში (გაითვალისწინეთ, რომ *pulNotificationValue დაყენებულია ნებისმიერი ბიტის წაშლამდე). ulBitsToClearOnExit-ის ULONG_MAX-ზე (თუ limits.h შედის) ან 0xffffffffUL-ზე (თუ limits.h არ შედის) დაყენება გამოიწვევს დავალების შეტყობინების მნიშვნელობის 0-ზე გადატვირთვას ფუნქციის გამოსვლამდე. ulBitsToClearOnExit-ის 0-ზე დაყენება ფუნქციის გამოსვლისას დავალების შეტყობინების მნიშვნელობას უცვლელს დატოვებს (ამ შემთხვევაში, pulNotificationValue-ში გადაცემული მნიშვნელობა დაემთხვევა დავალების შეტყობინების მნიშვნელობას).</li>
<li><code class="docutils literal notranslate"><span class="pre">pulNotificationValue</span></code>გამოიყენება დავალების შეტყობინების მნიშვნელობის ფუნქციიდან გასაგზავნად. გაითვალისწინეთ, რომ ulBitsToClearOnExit-ის ნულის ტოლობის არარსებობით გამოწვეული ბიტების გასუფთავება გავლენას არ მოახდენს გაცემულ მნიშვნელობაზე.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>მაქსიმალური დრო, რომლის განმავლობაშიც დავალებამ უნდა დაელოდოს შეტყობინების მიღებას დაბლოკილ მდგომარეობაში, იმ შემთხვევაში, თუ შეტყობინება უკვე არ იყო მოლოდინის რეჟიმში xTaskNotifyWait() გამოძახებისას. დავალება არ მოიხმარს დამუშავების დროს დაბლოკილ მდგომარეობაში ყოფნისას. ეს მითითებულია ბირთვის ტიკებში, მაკრო pdMS_TO_TICSK(value_in_ms) შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის ტიკებში მითითებულ დროდ გადასაყვანად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t">
<span id="_CPPv322vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t"></span><span id="_CPPv222vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t"></span><span id="vTaskNotifyGiveFromISR__TaskHandle_t.BaseType_tP"></span><span class="target" id="task_8h_1a0c31cb4be76285f05909de23ede05331"></span>void <code class="descname">vTaskNotifyGiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <em>xTaskToNotify</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422vTaskNotifyGiveFromISR12TaskHandle_tP10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ISR-დან დავალების შეტყობინების გასაგზავნად გამარტივებული მაკრო.</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს მაკრო ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>xTaskNotifyGive()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან (ISR).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>vTaskNotifyGiveFromISR() განკუთვნილია იმ შემთხვევაში, თუ დავალების შეტყობინებები გამოიყენება როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორების ეკვივალენტები. რეალური თავისუფალი RTOS სემაფორები მოცემულია ISR-დან xSemaphoreGiveFromISR() API ფუნქციის გამოყენებით, ეკვივალენტური მოქმედება, რომელიც იყენებს დავალების შეტყობინებას არის vTaskNotifyGiveFromISR().</p>
<p>როდესაც დავალების შეტყობინებები გამოიყენება როგორც ორობითი ან დათვლის სემაფორის ეკვივალენტი, მაშინ შეტყობინებაზე მიღებულმა დავალებამ შეტყობინებას უნდა დაელოდოს ulTaskNotificationTake() API ფუნქციის გამოყენებით და არა xTaskNotifyWait() API ფუნქციის გამოყენებით.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დამატებითი დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: შეტყობინების მიმღები დავალების სახელური. დავალების სახელურის დაბრუნება შესაძლებელია xTaskCreate() API ფუნქციიდან, რომელიც გამოიყენება დავალების შესაქმნელად, ხოლო ამჟამად შესრულებული დავალების სახელურის მიღება შესაძლებელია xTaskGetCurrentTaskHandle()-ის გამოძახებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>vTaskNotifyGiveFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ შეტყობინების გაგზავნამ გამოიწვია დავალების, რომელზეც შეტყობინება გაიგზავნა, დაბლოკილი მდგომარეობიდან გასვლა და განბლოკილი დავალების პრიორიტეტი უფრო მაღალია, ვიდრე ამჟამად გაშვებული დავალება. თუ vTaskNotifyGiveFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეფერხებიდან გასვლამდე უნდა მოითხოვდეს კონტექსტური გადამრთველს. ISR-დან კონტექსტური გადამრთველის მოთხოვნის წესი დამოკიდებულია პორტზე - იხილეთ გამოყენებული პორტის დოკუმენტაციის გვერდი. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416ulTaskNotifyTake10BaseType_t10TickType_t">
<span id="_CPPv316ulTaskNotifyTake10BaseType_t10TickType_t"></span><span id="_CPPv216ulTaskNotifyTake10BaseType_t10TickType_t"></span><span id="ulTaskNotifyTake__BaseType_t.TickType_t"></span><span class="target" id="task_8h_1a1dd29cf3d25f9968ac86b0ca35af8ada"></span>uint32_t <code class="descname">ulTaskNotifyTake</code><span class="sig-paren">(</span>BaseType_t <em>xClearCountOnExit</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv416ulTaskNotifyTake10BaseType_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შესახებ შეტყობინების მისაღებად გამარტივებული მაკრო.</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს ფუნქცია ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>ulTaskNotifyTake() განკუთვნილია იმ შემთხვევაში, თუ დავალების შეტყობინება გამოიყენება როგორც უფრო სწრაფი და მსუბუქი ორობითი ან დათვლის სემაფორის ალტერნატივა. რეალური თავისუფალი RTOS სემაფორები მიიღება xSemaphoreTake() API ფუნქციის გამოყენებით, ეკვივალენტური მოქმედება, რომელიც იყენებს დავალების შეტყობინებას, არის ulTaskNotifyTake().</p>
<p>როდესაც დავალება იყენებს შეტყობინების მნიშვნელობას ორობითი ან დამთვლელი სემაფორის სახით, სხვა დავალებებმა უნდა გაუგზავნონ მას შეტყობინებები xTaskNotifyGive() მაკროს ან xTaskNotify() ფუნქციის გამოყენებით, რომლის eAction პარამეტრიც eIncrement-ზეა დაყენებული.</p>
<p>ulTaskNotifyTake() ფუნქციას შეუძლია ან დავალების შეტყობინების მნიშვნელობის ნულამდე დაყვანა გასვლისას, ამ შემთხვევაში შეტყობინების მნიშვნელობა ბინარული სემაფორის მსგავსად მოქმედებს, ან დავალების შეტყობინების მნიშვნელობის შემცირება გასვლისას, ამ შემთხვევაში შეტყობინების მნიშვნელობა დათვლის სემაფორის მსგავსად მოქმედებს.</p>
<p>დავალებას შეუძლია გამოიყენოს ulTaskNotifyTake() [არასავალდებულო] დაბლოკვისთვის, რათა დაელოდოს დავალების შეტყობინების მნიშვნელობას ნულისგან განსხვავებული. დავალება არ მოიხმარს CPU-ს დროს, სანამ ის დაბლოკილ მდგომარეობაშია.</p>
<p>თუ xTaskNotifyWait() დააბრუნებს, როდესაც შეტყობინება მოლოდინშია, ulTaskNotifyTake() დააბრუნებს, როდესაც დავალების შეტყობინების მნიშვნელობა ნულის ტოლი არ არის.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The task’s notification count before it is either cleared to zero or decremented (see the xClearCountOnExit parameter). </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xClearCountOnExit</span></code>თუ xClearCountOnExit არის pdFALSE, მაშინ დავალების შეტყობინების მნიშვნელობა მცირდება ფუნქციის დასრულებისას. ამ გზით შეტყობინების მნიშვნელობა მოქმედებს როგორც დათვლის სემაფორი. თუ xClearCountOnExit არ არის pdFALSE, მაშინ დავალების შეტყობინების მნიშვნელობა ნულდება ფუნქციის დასრულებისას. ამ გზით შეტყობინების მნიშვნელობა მოქმედებს როგორც ბინარული სემაფორი.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>მაქსიმალური დრო, რომლის განმავლობაშიც დავალებამ უნდა დაელოდოს დაბლოკილ მდგომარეობაში დავალების შეტყობინების მნიშვნელობის ნულზე მეტის მიღწევას, თუ ulTaskNotifyTake() ფუნქციის გამოძახებისას რაოდენობა უკვე ნულზე მეტი არ იყო. დაბლოკილ მდგომარეობაში ყოფნისას დავალება დამუშავების დროს არ მოიხმარს. ეს მითითებულია ბირთვის ტიკებში, მაკრო pdMS_TO_TICSK(value_in_ms) შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის ტიკებში მითითებულ დროდ გადასაყვანად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="freertos.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv412xTASK_STATUS">
<span id="_CPPv312xTASK_STATUS"></span><span id="_CPPv212xTASK_STATUS"></span><span id="xTASK_STATUS"></span><span class="target" id="structxTASK__STATUS"></span><em class="property">სტრუქტურა </em><code class="descname">xTASK_STATUS</code><a class="headerlink" href="freertos.html#_CPPv412xTASK_STATUS" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება uxTaskGetSystemState() ფუნქციასთან ერთად სისტემაში თითოეული დავალების მდგომარეობის დასაბრუნებლად. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS7xHandleE">
<span id="_CPPv3N12xTASK_STATUS7xHandleE"></span><span id="_CPPv2N12xTASK_STATUS7xHandleE"></span><span id="xTASK_STATUS::xHandle__TaskHandle_t"></span><span class="target" id="structxTASK__STATUS_1ac57f825f365c3c64bba827285fe3c2a0"></span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xHandle</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS7xHandleE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების სახელური, რომელსაც სტრუქტურაში დანარჩენი ინფორმაცია ეხება. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS10pcTaskNameE">
<span id="_CPPv3N12xTASK_STATUS10pcTaskNameE"></span><span id="_CPPv2N12xTASK_STATUS10pcTaskNameE"></span><span id="xTASK_STATUS::pcTaskName__cCP"></span><span class="target" id="structxTASK__STATUS_1ad272663e2560bd9ea088384a39ba6192"></span><em class="property">კონსტ</em> char *<code class="descname">pcTaskName</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS10pcTaskNameE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების სახელზე მითითება. ეს მნიშვნელობა არასწორი იქნება, თუ დავალება წაიშალა სტრუქტურის შევსების შემდეგ! </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS11xTaskNumberE">
<span id="_CPPv3N12xTASK_STATUS11xTaskNumberE"></span><span id="_CPPv2N12xTASK_STATUS11xTaskNumberE"></span><span id="xTASK_STATUS::xTaskNumber__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1acd44468ba37270b04f83d0833c098057"></span>UBaseType_t <code class="descname">xTaskNumber</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS11xTaskNumberE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების უნიკალური რიცხვი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS13eCurrentStateE">
<span id="_CPPv3N12xTASK_STATUS13eCurrentStateE"></span><span id="_CPPv2N12xTASK_STATUS13eCurrentStateE"></span><span id="xTASK_STATUS::eCurrentState__eTaskState"></span><span class="target" id="structxTASK__STATUS_1a727e904e3afe49472b0fc6a4e96439cb"></span><a class="reference internal" href="freertos.html#_CPPv410eTaskState" title="eTaskState">eTaskState</a> <code class="descname">eCurrentState</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS13eCurrentStateE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მდგომარეობა, რომელშიც დავალება არსებობდა სტრუქტურის შევსებისას. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS17uxCurrentPriorityE">
<span id="_CPPv3N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="_CPPv2N12xTASK_STATUS17uxCurrentPriorityE"></span><span id="xTASK_STATUS::uxCurrentPriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a39df647234fc0d6de5852042a2741a94"></span>UBaseType_t <code class="descname">uxCurrentPriority</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS17uxCurrentPriorityE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პრიორიტეტი, რომლითაც დავალება სრულდებოდა (შესაძლოა მემკვიდრეობით მიღებული იყოს) სტრუქტურის შევსებისას. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS14uxBasePriorityE">
<span id="_CPPv3N12xTASK_STATUS14uxBasePriorityE"></span><span id="_CPPv2N12xTASK_STATUS14uxBasePriorityE"></span><span id="xTASK_STATUS::uxBasePriority__UBaseType_t"></span><span class="target" id="structxTASK__STATUS_1a692f4c8957b7270f1579cdee63ff287e"></span>UBaseType_t <code class="descname">uxBasePriority</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS14uxBasePriorityE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პრიორიტეტი, რომელსაც დავალება დაუბრუნდება, თუ დავალების მიმდინარე პრიორიტეტი მემკვიდრეობით იქნა მიღებული, რათა თავიდან იქნას აცილებული შეუზღუდავი პრიორიტეტის ინვერსია მუტექსის მიღებისას. ძალაშია მხოლოდ იმ შემთხვევაში, თუ configUSE_MUTEXES განსაზღვრულია, როგორც 1 Free RTOS Config.h-ში. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS16ulRunTimeCounterE">
<span id="_CPPv3N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="_CPPv2N12xTASK_STATUS16ulRunTimeCounterE"></span><span id="xTASK_STATUS::ulRunTimeCounter__uint32_t"></span><span class="target" id="structxTASK__STATUS_1a92ab83f4f376c255dedf8e06a78261f7"></span>uint32_t <code class="descname">ulRunTimeCounter</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS16ulRunTimeCounterE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შესრულების სტატისტიკის საათის მიხედვით განსაზღვრული დავალების შესრულების საერთო დრო. იხილეთ <a class="reference external" href="http://www.freertos.org/rtos-run-time-stats.html">http://www.freertos.org/rtos-run-time-stats.html</a>ძალაშია მხოლოდ მაშინ, როდესაც configGENERATE_RUN_TIME_STATS Free RTOS Config.h-ში განსაზღვრულია, როგორც 1. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS11pxStackBaseE">
<span id="_CPPv3N12xTASK_STATUS11pxStackBaseE"></span><span id="_CPPv2N12xTASK_STATUS11pxStackBaseE"></span><span id="xTASK_STATUS::pxStackBase__StackType_tP"></span><span class="target" id="structxTASK__STATUS_1a0ee59674d2cc57d3a5a29c777d5452ed"></span>StackType_t *<code class="descname">pxStackBase</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS11pxStackBaseE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითებს დავალების დასტის არეალის ყველაზე დაბალ მისამართზე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE">
<span id="_CPPv3N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="_CPPv2N12xTASK_STATUS20usStackHighWaterMarkE"></span><span id="xTASK_STATUS::usStackHighWaterMark__uint32_t"></span><span class="target" id="structxTASK__STATUS_1a847c7fd0baf85d88586341a5a219538a"></span>uint32_t <code class="descname">usStackHighWaterMark</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS20usStackHighWaterMarkE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დასტის მინიმალური რაოდენობა, რომელიც დარჩა დავალებისთვის დავალების შექმნის შემდეგ. რაც უფრო ახლოსაა ეს მნიშვნელობა ნულთან, მით უფრო ახლოსაა დავალების დასტა გადავსებასთან. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N12xTASK_STATUS7xCoreIDE">
<span id="_CPPv3N12xTASK_STATUS7xCoreIDE"></span><span id="_CPPv2N12xTASK_STATUS7xCoreIDE"></span><span id="xTASK_STATUS::xCoreID__BaseType_t"></span><span class="target" id="structxTASK__STATUS_1a43dafa875f1490a8adfa4d588ead2f31"></span>BaseType_t <code class="descname">xCoreID</code><a class="headerlink" href="freertos.html#_CPPv4N12xTASK_STATUS7xCoreIDE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ეს ამოცანა ბირთვზეა მიმაგრებული (0, 1 ან -1 tskNO_AFFINITY-სთვის). ეს ველი არსებობს, თუ დაყენებულია CONFIG_FREE RTOS _VTASKLIST_INCLUDE_COREID. </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv414xTASK_SNAPSHOT">
<span id="_CPPv314xTASK_SNAPSHOT"></span><span id="_CPPv214xTASK_SNAPSHOT"></span><span id="xTASK_SNAPSHOT"></span><span class="target" id="structxTASK__SNAPSHOT"></span><em class="property">სტრუქტურა </em><code class="descname">xTASK_SNAPSHOT</code><a class="headerlink" href="freertos.html#_CPPv414xTASK_SNAPSHOT" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება uxTaskGetSnapshotAll() ფუნქციასთან ერთად სისტემაში თითოეული დავალების მეხსიერების სნეპშოტის შესანახად. ეს სტრუქტურა გვჭირდება, რადგან TCB_t განსაზღვრულია (დამალულია) tasks.c-ში. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT5pxTCBE">
<span id="_CPPv3N14xTASK_SNAPSHOT5pxTCBE"></span><span id="_CPPv2N14xTASK_SNAPSHOT5pxTCBE"></span><span id="xTASK_SNAPSHOT::pxTCB__voidP"></span><span class="target" id="structxTASK__SNAPSHOT_1ae2941ec1a55d5f8ffb31b85a1a7c4503"></span>void *<code class="descname">pxTCB</code><a class="headerlink" href="freertos.html#_CPPv4N14xTASK_SNAPSHOT5pxTCBE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების მართვის ბლოკის მისამართი. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT12pxTopOfStackE">
<span id="_CPPv3N14xTASK_SNAPSHOT12pxTopOfStackE"></span><span id="_CPPv2N14xTASK_SNAPSHOT12pxTopOfStackE"></span><span id="xTASK_SNAPSHOT::pxTopOfStack__StackType_tP"></span><span class="target" id="structxTASK__SNAPSHOT_1a731e2dd7cd18a09a340fd5590450b9da"></span>StackType_t *<code class="descname">pxTopOfStack</code><a class="headerlink" href="freertos.html#_CPPv4N14xTASK_SNAPSHOT12pxTopOfStackE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითებს დავალებების დასტაში ბოლო განთავსებული ელემენტის ადგილმდებარეობაზე. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N14xTASK_SNAPSHOT12pxEndOfStackE">
<span id="_CPPv3N14xTASK_SNAPSHOT12pxEndOfStackE"></span><span id="_CPPv2N14xTASK_SNAPSHOT12pxEndOfStackE"></span><span id="xTASK_SNAPSHOT::pxEndOfStack__StackType_tP"></span><span class="target" id="structxTASK__SNAPSHOT_1a47be43ea65d03d703016e854032a87bc"></span>StackType_t *<code class="descname">pxEndOfStack</code><a class="headerlink" href="freertos.html#_CPPv4N14xTASK_SNAPSHOT12pxEndOfStackE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითებს დასტის ბოლოს. pxTopOfStack &amp;lt; pxEndOfStack, დასტა იზრდება hi2lo pxTopOfStack &amp;gt; pxEndOfStack, დასტა იზრდება lo2hi </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="freertos.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.tskKERNEL_VERSION_NUMBER">
<span class="target" id="task_8h_1a3de6ae5641d96a68aa027673b6588016"></span><code class="descname">tskKERNEL_VERSION_NUMBER</code><a class="headerlink" href="freertos.html#c.tskKERNEL_VERSION_NUMBER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tskKERNEL_VERSION_MAJOR">
<span class="target" id="task_8h_1a790e0e16f79e71d4791435a31d5b0fc7"></span><code class="descname">tskKERNEL_VERSION_MAJOR</code><a class="headerlink" href="freertos.html#c.tskKERNEL_VERSION_MAJOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tskKERNEL_VERSION_MINOR">
<span class="target" id="task_8h_1ab0b5ab04d8419227d0a5ac94af6b3639"></span><code class="descname">tskKERNEL_VERSION_MINOR</code><a class="headerlink" href="freertos.html#c.tskKERNEL_VERSION_MINOR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tskKERNEL_VERSION_BUILD">
<span class="target" id="task_8h_1a4cb001d5c86f4a8a5272f27227eb3247"></span><code class="descname">tskKERNEL_VERSION_BUILD</code><a class="headerlink" href="freertos.html#c.tskKERNEL_VERSION_BUILD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tskNO_AFFINITY">
<span class="target" id="task_8h_1aaef304a55bdc7162666e9bedcf9182a3"></span><code class="descname">tskNO_AFFINITY</code><a class="headerlink" href="freertos.html#c.tskNO_AFFINITY" title="Permalink to this definition">¶</a></dt>
<dd><p>xTaskCreatePinnedToCore-ის არგუმენტი, რომელიც მიუთითებს, რომ დავალებას არანაირი კავშირი არ აქვს. </p>
</dd></dl>
<dl class="macro">
<dt id="c.tskIDLE_PRIORITY">
<span class="target" id="task_8h_1a94ed0b9b3b4e8ccc859c322f18583e67"></span><code class="descname">tskIDLE_PRIORITY</code><a class="headerlink" href="freertos.html#c.tskIDLE_PRIORITY" title="Permalink to this definition">¶</a></dt>
<dd><p>განსაზღვრავს პრიორიტეტს, რომელსაც იყენებს უმოქმედო დავალება. ეს არ უნდა შეიცვალოს. </p>
</dd></dl>
<dl class="macro">
<dt id="c.taskYIELD">
<span class="target" id="task_8h_1a767e474430db1e60056e9678763f9202"></span><code class="descname">taskYIELD</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskYIELD" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალება. სთ</p>
<p>მაკრო კონტექსტის გადართვის იძულებითი გადართვისთვის. </p>
</dd></dl>
<dl class="macro">
<dt id="c.taskENTER_CRITICAL">
<span class="target" id="task_8h_1ad090b3b8b3d5ae61316bfacc9fcdae30"></span><code class="descname">taskENTER_CRITICAL</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskENTER_CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალება. სთ</p>
<p>მაკრო კრიტიკული კოდის რეგიონის დასაწყისის აღსანიშნავად. კრიტიკულ რეგიონში ყოფნისას პრეემპტიკური კონტექსტის გადართვა შეუძლებელია.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This may alter the stack (depending on the portable implementation) so must be used with care! </dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.taskENTER_CRITICAL_ISR">
<span class="target" id="task_8h_1adc0bf2970bce64b6b53b67d843530038"></span><code class="descname">taskENTER_CRITICAL_ISR</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskENTER_CRITICAL_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.taskEXIT_CRITICAL">
<span class="target" id="task_8h_1af092583ebd99ba0823e432c02a7923b4"></span><code class="descname">taskEXIT_CRITICAL</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskEXIT_CRITICAL" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალება. სთ</p>
<p>მაკრო კრიტიკული კოდის რეგიონის დასასრულის აღსანიშნავად. კრიტიკულ რეგიონში ყოფნისას პრეემპტიკური კონტექსტის გადართვა შეუძლებელია.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This may alter the stack (depending on the portable implementation) so must be used with care! </dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.taskEXIT_CRITICAL_ISR">
<span class="target" id="task_8h_1a616d3e63657279faa06fe6d935555b6a"></span><code class="descname">taskEXIT_CRITICAL_ISR</code><span class="sig-paren">(</span>mux<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskEXIT_CRITICAL_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.taskDISABLE_INTERRUPTS">
<span class="target" id="task_8h_1aa455a648c2224964ee57758b8794198e"></span><code class="descname">taskDISABLE_INTERRUPTS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskDISABLE_INTERRUPTS" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალება. სთ</p>
<p>მაკრო ყველა ნიღბიანი შეფერხების გამოსართავად. </p>
</dd></dl>
<dl class="macro">
<dt id="c.taskENABLE_INTERRUPTS">
<span class="target" id="task_8h_1a04361ba499e91eb35324e4cba6feea17"></span><code class="descname">taskENABLE_INTERRUPTS</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.taskENABLE_INTERRUPTS" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალება. სთ</p>
<p>მაკრო მიკროკონტროლერი შეფერხებების ჩასართავად. </p>
</dd></dl>
<dl class="macro">
<dt id="c.taskSCHEDULER_SUSPENDED">
<span class="target" id="task_8h_1a0cad071ca127a35df93166e9ed5b6ada"></span><code class="descname">taskSCHEDULER_SUSPENDED</code><a class="headerlink" href="freertos.html#c.taskSCHEDULER_SUSPENDED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.taskSCHEDULER_NOT_STARTED">
<span class="target" id="task_8h_1a0923fdaae1bfe42ac5cccd9e9ddca9ed"></span><code class="descname">taskSCHEDULER_NOT_STARTED</code><a class="headerlink" href="freertos.html#c.taskSCHEDULER_NOT_STARTED" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.taskSCHEDULER_RUNNING">
<span class="target" id="task_8h_1acbb675035741787d29da475b5a887545"></span><code class="descname">taskSCHEDULER_RUNNING</code><a class="headerlink" href="freertos.html#c.taskSCHEDULER_RUNNING" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.xTaskNotifyGive">
<span class="target" id="task_8h_1ac60cbd05577a3e4f3c3587dd9b213930"></span><code class="descname">xTaskNotifyGive</code><span class="sig-paren">(</span>xTaskToNotify<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTaskNotifyGive" title="Permalink to this definition">¶</a></dt>
<dd><p>დავალების შესახებ შეტყობინების გასაგზავნად გამარტივებული მაკრო.</p>
<p>configUSE_TASK_NOTIFICATIONS უნდა იყოს განუსაზღვრელი ან განისაზღვროს, როგორც 1, რათა ეს მაკრო ხელმისაწვდომი იყოს.</p>
<p>როდესაც configUSE_TASK_NOTIFICATIONS დაყენებულია ერთზე, თითოეულ დავალებას აქვს საკუთარი კერძო „შეტყობინების მნიშვნელობა“, რომელიც არის 32-ბიტიანი ხელმოუწერელი მთელი რიცხვი (uint32_t).</p>
<p>მოვლენების გაგზავნა დავალებაზე შუამავალი ობიექტის გამოყენებით შეიძლება. ასეთი ობიექტების მაგალითებია რიგები, სემაფორები, მუტექსები და მოვლენების ჯგუფები. დავალების შეტყობინებები არის მეთოდი, რომლითაც მოვლენა პირდაპირ დავალებაზე იგზავნება ასეთი შუამავალი ობიექტის საჭიროების გარეშე.</p>
<p>დავალებაზე გაგზავნილ შეტყობინებას სურვილისამებრ შეუძლია შეასრულოს მოქმედება, როგორიცაა დავალების შეტყობინების მნიშვნელობის განახლება, გადაწერა ან გაზრდა. ამ გზით დავალების შეტყობინებები შეიძლება გამოყენებულ იქნას დავალებაზე მონაცემების გასაგზავნად, ან გამოყენებულ იქნას როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორები.</p>
<p>xTaskNotifyGive() არის დამხმარე მაკრო, რომელიც განკუთვნილია იმ შემთხვევაში გამოსაყენებლად, როდესაც დავალებების შეტყობინებები გამოიყენება როგორც მსუბუქი და სწრაფი ორობითი ან დათვლის სემაფორების ეკვივალენტები. რეალური თავისუფალი RTOS სემაფორები მოცემულია xSemaphoreGive() API ფუნქციის გამოყენებით, ეკვივალენტური მოქმედება, რომელიც იყენებს დავალებების შეტყობინებას, არის xTaskNotifyGive().</p>
<p>როდესაც დავალების შეტყობინებები გამოიყენება როგორც ორობითი ან დათვლის სემაფორის ეკვივალენტი, მაშინ შეტყობინებაზე მიღებულმა დავალებამ შეტყობინებას უნდა დაელოდოს ulTaskNotificationTake() API ფუნქციის გამოყენებით და არა xTaskNotifyWait() API ფუნქციის გამოყენებით.</p>
<p>იხილეთ <a class="reference external" href="http://www.FreeRTOS.org/RTOS-task-notifications.html">http://www.Free RTOS .org/ RTOS -task-notifications.html</a> დამატებითი დეტალებისთვის.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement - so pdPASS is always returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTaskToNotify</span></code>: შეტყობინების მიმღები დავალების სახელური. დავალების სახელურის დაბრუნება შესაძლებელია xTaskCreate() API ფუნქციიდან, რომელიც გამოიყენება დავალების შესაქმნელად, ხოლო ამჟამად შესრულებული დავალების სახელურის მიღება შესაძლებელია xTaskGetCurrentTaskHandle()-ის გამოძახებით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="freertos.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv412TaskHandle_t">
<span id="_CPPv312TaskHandle_t"></span><span id="_CPPv212TaskHandle_t"></span><span id="TaskHandle_t"></span><span class="target" id="task_8h_1ae95f44d4cfeb4a599c6cc258d241cb6b"></span><em class="property">typedef </em>void *<code class="descname">TaskHandle_t</code><a class="headerlink" href="freertos.html#_CPPv412TaskHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალება. სთ</p>
<p>მიუთითეთ, თუ რომელი დავალებების მითითება ხდება. მაგალითად, xTaskCreate-ის გამოძახება (მაჩვენებლის პარამეტრის მეშვეობით) აბრუნებს TaskHandle_t ცვლადს, რომლის გამოყენებაც შემდეგ vTaskDelete-ის პარამეტრად შეიძლება დავალების წასაშლელად. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv418TaskHookFunction_t">
<span id="_CPPv318TaskHookFunction_t"></span><span id="_CPPv218TaskHookFunction_t"></span><span id="TaskHookFunction_t"></span><span class="target" id="task_8h_1af984026250bf8fece2e0068874d4661d"></span><em class="property">typedef </em>BaseType_t (*<code class="descname">TaskHookFunction_t</code>)<span class="sig-paren">(</span>void *<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv418TaskHookFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განსაზღვრავს პროტოტიპს, რომელსაც უნდა შეესაბამებოდეს აპლიკაციის დავალებების hook ფუნქცია. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv412TaskStatus_t">
<span id="_CPPv312TaskStatus_t"></span><span id="_CPPv212TaskStatus_t"></span><span id="TaskStatus_t"></span><span class="target" id="task_8h_1a34f88ef69814fb27d554e666e9868a9c"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="freertos.html#_CPPv412xTASK_STATUS" title="xTASK_STATUS">xTASK_STATUS</a> <code class="descname">TaskStatus_t</code><a class="headerlink" href="freertos.html#_CPPv412TaskStatus_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება uxTaskGetSystemState() ფუნქციასთან ერთად სისტემაში თითოეული დავალების მდგომარეობის დასაბრუნებლად. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv414TaskSnapshot_t">
<span id="_CPPv314TaskSnapshot_t"></span><span id="_CPPv214TaskSnapshot_t"></span><span id="TaskSnapshot_t"></span><span class="target" id="task_8h_1afa89adf9a3394cafc5ec51d62856af0e"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="freertos.html#_CPPv414xTASK_SNAPSHOT" title="xTASK_SNAPSHOT">xTASK_SNAPSHOT</a> <code class="descname">TaskSnapshot_t</code><a class="headerlink" href="freertos.html#_CPPv414TaskSnapshot_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება uxTaskGetSnapshotAll() ფუნქციასთან ერთად სისტემაში თითოეული დავალების მეხსიერების სნეპშოტის შესანახად. ეს სტრუქტურა გვჭირდება, რადგან TCB_t განსაზღვრულია (დამალულია) tasks.c-ში. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv427TlsDeleteCallbackFunction_t">
<span id="_CPPv327TlsDeleteCallbackFunction_t"></span><span id="_CPPv227TlsDeleteCallbackFunction_t"></span><span id="TlsDeleteCallbackFunction_t"></span><span class="target" id="task_8h_1aca1c0ef91ef0f8e2610e326e07747a49"></span><em class="property">typedef </em>void (*<code class="descname">TlsDeleteCallbackFunction_t</code>)<span class="sig-paren">(</span>int, void *<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv427TlsDeleteCallbackFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ლოკალური შენახვის მაჩვენებლის წაშლის უკუკავშირის პროტოტიპი. </p>
</dd></dl>
</div>
<div class="section" id="enumerations">
<h3>ჩამოთვლები<a class="headerlink" href="freertos.html#enumerations" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv410eTaskState">
<span id="_CPPv310eTaskState"></span><span id="_CPPv210eTaskState"></span><span id="eTaskState"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892c"></span><em class="property">ჩამოთვლა </em><code class="descname">eTaskState</code><a class="headerlink" href="freertos.html#_CPPv410eTaskState" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>eTaskGetState-ის მიერ დაბრუნებული დავალების მდგომარეობები. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv48eRunning">
<span id="_CPPv38eRunning"></span><span id="_CPPv28eRunning"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca83318c0d58e6b2bafaefa1be597fb8b6"></span><code class="descname">eRunning</code> = 0<a class="headerlink" href="freertos.html#_CPPv48eRunning" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალება საკუთარი თავის მდგომარეობის შესახებ ინფორმაციას ითხოვს, ამიტომ ის უნდა იყოს გაშვებული. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv46eReady">
<span id="_CPPv36eReady"></span><span id="_CPPv26eReady"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892ca8570b65f331057b2cf92c504f0a2bc83"></span><code class="descname">eReady</code><a class="headerlink" href="freertos.html#_CPPv46eReady" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოთხოვნილი დავალება წასაკითხი ან მზადყოფნის მოლოდინში მყოფი სიაშია. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv48eBlocked">
<span id="_CPPv38eBlocked"></span><span id="_CPPv28eBlocked"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cad23d72c68f43b6fff4962ad4154766af"></span><code class="descname">eBlocked</code><a class="headerlink" href="freertos.html#_CPPv48eBlocked" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოთხოვნილი დავალება დაბლოკილ მდგომარეობაშია. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv410eSuspended">
<span id="_CPPv310eSuspended"></span><span id="_CPPv210eSuspended"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892caf35a900d49fdfc2502eefc68fdb70f72"></span><code class="descname">eSuspended</code><a class="headerlink" href="freertos.html#_CPPv410eSuspended" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოთხოვნილი დავალება შეჩერებულია ან დაბლოკილია უსასრულო ვადით. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv48eDeleted">
<span id="_CPPv38eDeleted"></span><span id="_CPPv28eDeleted"></span><span class="target" id="task_8h_1a1749369458e2282a22e862a619a3892cacef5c6e771d3a07f656e07a13a20ba35"></span><code class="descname">eDeleted</code><a class="headerlink" href="freertos.html#_CPPv48eDeleted" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოთხოვნილი დავალება წაიშალა, მაგრამ მისი TCB ჯერ არ არის გათავისუფლებული. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv413eNotifyAction">
<span id="_CPPv313eNotifyAction"></span><span id="_CPPv213eNotifyAction"></span><span id="eNotifyAction"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233"></span><em class="property">ჩამოთვლა </em><code class="descname">eNotifyAction</code><a class="headerlink" href="freertos.html#_CPPv413eNotifyAction" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოქმედებები, რომელთა შესრულებაც შესაძლებელია vTaskNotify() გამოძახებისას. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv49eNoAction">
<span id="_CPPv39eNoAction"></span><span id="_CPPv29eNoAction"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233abac2b17ab15444724b6f35d47cd0a64a"></span><code class="descname">eNoAction</code> = 0<a class="headerlink" href="freertos.html#_CPPv49eNoAction" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შეტყობინება მისი შეტყობინების მნიშვნელობის განახლების გარეშე. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv48eSetBits">
<span id="_CPPv38eSetBits"></span><span id="_CPPv28eSetBits"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab7b1af2eeee53ae78eeff37c1cb6f79b"></span><code class="descname">eSetBits</code><a class="headerlink" href="freertos.html#_CPPv48eSetBits" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალების შეტყობინების მნიშვნელობაში ბიტების დაყენება. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv410eIncrement">
<span id="_CPPv310eIncrement"></span><span id="_CPPv210eIncrement"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233a04fb0e98d2400e4cd28f1593bc868822"></span><code class="descname">eIncrement</code><a class="headerlink" href="freertos.html#_CPPv410eIncrement" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გაზარდეთ დავალების შეტყობინების მნიშვნელობა. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv422eSetValueWithOverwrite">
<span id="_CPPv322eSetValueWithOverwrite"></span><span id="_CPPv222eSetValueWithOverwrite"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233ab61fc296ef909186b5824c823b33e130"></span><code class="descname">eSetValueWithOverwrite</code><a class="headerlink" href="freertos.html#_CPPv422eSetValueWithOverwrite" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააყენეთ დავალების შეტყობინების მნიშვნელობა კონკრეტულ მნიშვნელობაზე, მაშინაც კი, თუ წინა მნიშვნელობა დავალების მიერ ჯერ არ არის წაკითხული. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv425eSetValueWithoutOverwrite">
<span id="_CPPv325eSetValueWithoutOverwrite"></span><span id="_CPPv225eSetValueWithoutOverwrite"></span><span class="target" id="task_8h_1ae8abc4f7da5b6880467daafbf19cd233acc4dd3fe71b62c751187a2c4c515abac"></span><code class="descname">eSetValueWithoutOverwrite</code><a class="headerlink" href="freertos.html#_CPPv425eSetValueWithoutOverwrite" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააყენეთ დავალების შეტყობინების მნიშვნელობა, თუ წინა მნიშვნელობა წაკითხულია დავალების მიერ. </p>
</dd></dl>
</dd></dl>
<dl class="type">
<dt id="_CPPv416eSleepModeStatus">
<span id="_CPPv316eSleepModeStatus"></span><span id="_CPPv216eSleepModeStatus"></span><span id="eSleepModeStatus"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178e"></span><em class="property">ჩამოთვლა </em><code class="descname">eSleepModeStatus</code><a class="headerlink" href="freertos.html#_CPPv416eSleepModeStatus" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>eTaskConfirmSleepModeStatus()-ის შესაძლო დაბრუნების მნიშვნელობები. </p>
<p><em>ღირებულებები:</em></p>
<dl class="enumerator">
<dt id="_CPPv411eAbortSleep">
<span id="_CPPv311eAbortSleep"></span><span id="_CPPv211eAbortSleep"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178eaba7b1a394c63faa14a85dbb191f1c6f9"></span><code class="descname">eAbortSleep</code> = 0<a class="headerlink" href="freertos.html#_CPPv411eAbortSleep" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დავალება მზადაა ან კონტექსტის შეცვლა მოლოდინის რეჟიმშია portSUPPORESS_TICKS_AND_SLEEP() გამოძახების შემდეგ - შეწყვიტეთ ძილის რეჟიმში გადასვლა. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv414eStandardSleep">
<span id="_CPPv314eStandardSleep"></span><span id="_CPPv214eStandardSleep"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178ea2c539add8104402c6336bc33a660d1d1"></span><code class="descname">eStandardSleep</code><a class="headerlink" href="freertos.html#_CPPv414eStandardSleep" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შეიყვანეთ ძილის რეჟიმი, რომელიც მოსალოდნელ უმოქმედო დროზე მეტხანს არ გაგრძელდება. </p>
</dd></dl>
<dl class="enumerator">
<dt id="_CPPv422eNoTasksWaitingTimeout">
<span id="_CPPv322eNoTasksWaitingTimeout"></span><span id="_CPPv222eNoTasksWaitingTimeout"></span><span class="target" id="task_8h_1afd168a210ae0f2fb0fca242860a8178ea004c4d9f1a2619193750d0e2f18f6046"></span><code class="descname">eNoTasksWaitingTimeout</code><a class="headerlink" href="freertos.html#_CPPv422eNoTasksWaitingTimeout" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>არცერთი დავალება არ ელოდება ტაიმაუტს, ამიტომ უსაფრთხოა ძილის რეჟიმში გადასვლა, საიდანაც გამოსვლა მხოლოდ გარე შეფერხებით არის შესაძლებელი. </p>
</dd></dl>
</dd></dl>
</div>
</div>
<div class="section" id="queue-api">
<h2>რიგის API<a class="headerlink" href="freertos.html#queue-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>სათაურის ფაილი<a class="headerlink" href="freertos.html#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/queue.h">freertos/include/freertos/queue.h</a></li>
</ul>
</div>
<div class="section" id="id2">
<h3>ფუნქციები<a class="headerlink" href="freertos.html#id2" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t">
<span id="_CPPv324xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="_CPPv224xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t"></span><span id="xQueueGenericSendFromISR__QueueHandle_t.voidCPC.BaseType_tPC.BaseType_tC"></span><span class="target" id="queue_8h_1a263711eb0124112e828a18fd4b8ab29d"></span>BaseType_t <code class="descname">xQueueGenericSendFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, <em class="property">კონსტ</em> void *<em class="property">კონსტ</em> <em>pvItemToQueue</em>, BaseType_t *<em class="property">კონსტ</em> <em>pxHigherPriorityTaskWoken</em>, <em class="property">კონსტ</em> BaseType_t <em>xCopyPosition</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv424xQueueGenericSendFromISR13QueueHandle_tPCKvPC10BaseType_tK10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სასურველია, რომ ამ ფუნქციის პირდაპირი გამოძახების ნაცვლად გამოყენებული იქნას xQueueSendFromISR(), xQueueSendToFrontFromISR() და xQueueSendToBackFromISR() მაკროები. xQueueGiveFromISR() არის ეკვივალენტი სემაფორების მიერ გამოსაყენებლად, რომლებიც რეალურად არ აკოპირებენ მონაცემებს.</p>
<p>ელემენტის რიგში განთავსება. ამ ფუნქციის გამოყენება უსაფრთხოა შეფერხების სერვისის რუტინიდან.</p>
<p>ელემენტები რიგში ასლის და არა მითითების მიხედვითაა, ამიტომ სასურველია რიგში მხოლოდ მცირე ზომის ელემენტების განთავსება, განსაკუთრებით მაშინ, როდესაც ისინი ISR-დან იძახება. უმეტეს შემთხვევაში, სასურველია რიგში მყოფი ელემენტის მითითების შენახვა.</p>
<p><p>ბუფერული IO-ს გამოყენების მაგალითი (სადაც ISR-ს შეუძლია ერთზე მეტი მნიშვნელობის მიღება თითო გამოძახებაზე): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWokenByPost</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">each</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueGenericSendFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWokenByPost</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">required</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWokenByPost</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">taskYIELD_YIELD_FROM_ISR</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>xQueueGenericSendFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ რიგში გაგზავნამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებულ დავალებაზე მაღალი პრიორიტეტი აქვს. თუ xQueueGenericSendFromISR() ფუნქცია ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCopyPosition</span></code>შეგიძლიათ მიიღოთ მნიშვნელობა queueSEND_TO_BACK ელემენტის რიგის ბოლოში განსათავსებლად, ან queueSEND_TO_FRONT ელემენტის რიგის წინა ნაწილში განსათავსებლად (მაღალი პრიორიტეტული შეტყობინებებისთვის).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t">
<span id="_CPPv317xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="_CPPv217xQueueGiveFromISR13QueueHandle_tPC10BaseType_t"></span><span id="xQueueGiveFromISR__QueueHandle_t.BaseType_tPC"></span><span class="target" id="queue_8h_1ad14ae1174c2772cffc9e0c2c45dc55a6"></span>BaseType_t <code class="descname">xQueueGiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, BaseType_t *<em class="property">კონსტ</em> <em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xQueueGiveFromISR13QueueHandle_tPC10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t">
<span id="_CPPv325xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="_CPPv225xQueueIsQueueEmptyFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueEmptyFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1aa11139c58f4eecaa0c50078f2976d010"></span>BaseType_t <code class="descname">xQueueIsQueueEmptyFromISR</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv425xQueueIsQueueEmptyFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ISR-დან უსაფრთხო რიგების შეკითხვის უტილიტები. ეს უტილიტები უნდა იქნას გამოყენებული მხოლოდ ISR-ის შიგნიდან ან კრიტიკული სექციიდან. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t">
<span id="_CPPv324xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="_CPPv224xQueueIsQueueFullFromISRK13QueueHandle_t"></span><span id="xQueueIsQueueFullFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a81319b3aa562733957c5a12a088516d3"></span>BaseType_t <code class="descname">xQueueIsQueueFullFromISR</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv424xQueueIsQueueFullFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t">
<span id="_CPPv329uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="_CPPv229uxQueueMessagesWaitingFromISRK13QueueHandle_t"></span><span id="uxQueueMessagesWaitingFromISR__QueueHandle_tC"></span><span class="target" id="queue_8h_1a3e89b6189166f9544f283435e2732f9a"></span>UBaseType_t <code class="descname">uxQueueMessagesWaitingFromISR</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv429uxQueueMessagesWaitingFromISRK13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="function">
<dt id="_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t">
<span id="_CPPv317xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="_CPPv217xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t"></span><span id="xQueueGenericSend__QueueHandle_t.voidCPC.TickType_t.BaseType_tC"></span><span class="target" id="queue_8h_1a7ce86d1026e0c3055a523935bf53c0b3"></span>BaseType_t <code class="descname">xQueueGenericSend</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, <em class="property">კონსტ</em> void *<em class="property">კონსტ</em> <em>pvItemToQueue</em>, TickType_t <em>xTicksToWait</em>, <em class="property">კონსტ</em> BaseType_t <em>xCopyPosition</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xQueueGenericSend13QueueHandle_tPCKv10TickType_tK10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სასურველია, რომ ამ ფუნქციის პირდაპირი გამოძახების ნაცვლად გამოყენებული იქნას xQueueSend(), xQueueSendToFront() და xQueueSendToBack() მაკროები.</p>
<p>ელემენტის რიგში განთავსება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით. ეს ფუნქცია არ უნდა გამოიძახონ შეწყვეტის სერვისის რუტინიდან. იხილეთ xQueueSendFromISR () ალტერნატივისთვის, რომელიც შეიძლება გამოყენებულ იქნას ISR-ში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueGenericSend</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueGenericSend</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queueSEND_TO_BACK</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო, რომლის განმავლობაშიც დავალება უნდა დაბლოკოს რიგში ადგილის გამოთავისუფლების მოლოდინში, თუ ის უკვე სავსეა. ზარი დაუყოვნებლივ დაბრუნდება, თუ ეს დაყენებულია 0-ზე და რიგი სავსეა. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული მუდმივი portTICK_PERIOD_MS.</li>
<li><code class="docutils literal notranslate"><span class="pre">xCopyPosition</span></code>შეგიძლიათ მიიღოთ მნიშვნელობა queueSEND_TO_BACK ელემენტის რიგის ბოლოში განსათავსებლად, ან queueSEND_TO_FRONT ელემენტის რიგის წინა ნაწილში განსათავსებლად (მაღალი პრიორიტეტული შეტყობინებებისთვის).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417xQueuePeekFromISR13QueueHandle_tPCv">
<span id="_CPPv317xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="_CPPv217xQueuePeekFromISR13QueueHandle_tPCv"></span><span id="xQueuePeekFromISR__QueueHandle_t.voidPC"></span><span class="target" id="queue_8h_1ac402adf98be1fb8ca0345f30dc11a9dc"></span>BaseType_t <code class="descname">xQueuePeekFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, void *<em class="property">კონსტ</em> <em>pvBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xQueuePeekFromISR13QueueHandle_tPCv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>xQueuePeek()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან (ISR).</p>
<p>რიგიდან ელემენტის მიღება რიგიდან მისი ამოღების გარეშე. ელემენტი მიიღება კოპირებით, ამიტომ უნდა იყოს უზრუნველყოფილი შესაბამისი ზომის ბუფერი. ბუფერში კოპირებული ბაიტების რაოდენობა განისაზღვრა რიგის შექმნისას.</p>
<p>წარმატებით მიღებული ერთეულები რიგში რჩება, ამიტომ ისინი კვლავ დაბრუნდება შემდეგი ზარის დროს ან xQueueReceive()-ის ზარის დროს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, საიდანაც უნდა იქნას მიღებული ნივთი.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: ბუფერის მაჩვენებელი, რომელშიც მიღებული ელემენტი დაკოპირდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t">
<span id="_CPPv320xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t"></span><span id="_CPPv220xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t"></span><span id="xQueueGenericReceive__QueueHandle_t.voidPC.TickType_t.BaseType_tC"></span><span class="target" id="queue_8h_1a6a0c9135edf180d270ac0ffb17ec21b4"></span>BaseType_t <code class="descname">xQueueGenericReceive</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, void *<em class="property">კონსტ</em> <em>pvBuffer</em>, TickType_t <em>xTicksToWait</em>, <em class="property">კონსტ</em> BaseType_t <em>xJustPeek</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv420xQueueGenericReceive13QueueHandle_tPCv10TickType_tK10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სასურველია, რომ ამ ფუნქციის პირდაპირ გამოძახების ნაცვლად გამოყენებული იქნას xQueueReceive() მაკრო.</p>
<p>რიგიდან ელემენტის მიღება. ელემენტი მიიღება კოპირებით, ამიტომ უნდა იყოს უზრუნველყოფილი შესაბამისი ზომის ბუფერი. ბუფერში კოპირებული ბაიტების რაოდენობა განისაზღვრა რიგის შექმნისას.</p>
<p>ეს ფუნქცია არ უნდა იქნას გამოყენებული შეფერხების სერვისის რუტინაში. ალტერნატივისთვის იხილეთ xQueueReceiveFromISR.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
   <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
   <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
   <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span>

   <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
   <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
   <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">receive</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Receive</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
       <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xQueueGenericReceive</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
           <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, საიდანაც უნდა იქნას მიღებული ნივთი.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: ბუფერის მაჩვენებელი, რომელშიც მიღებული ელემენტი დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>მაქსიმალური დრო, რომელიც დავალებამ უნდა დაბლოკოს ელემენტის მიღების მოლოდინში, თუ რიგი გამოძახების დროს ცარიელია. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული portTICK_PERIOD_MS კონსტანტა. xQueueGenericReceive() დაუყოვნებლივ დააბრუნებს, თუ რიგი ცარიელია და xTicksToWait 0-ის ტოლია.</li>
<li><code class="docutils literal notranslate"><span class="pre">xJustPeek</span></code>: როდესაც დაყენებულია true-ზე, რიგიდან მიღებული ელემენტი რეალურად არ იშლება რიგიდან - რაც ნიშნავს, რომ xQueueReceive()-ის შემდგომი გამოძახება დააბრუნებს იგივე ელემენტს. როდესაც დაყენებულია false-ზე, რიგიდან მიღებული ელემენტიც იშლება რიგიდან.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422uxQueueMessagesWaitingK13QueueHandle_t">
<span id="_CPPv322uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="_CPPv222uxQueueMessagesWaitingK13QueueHandle_t"></span><span id="uxQueueMessagesWaiting__QueueHandle_tC"></span><span class="target" id="queue_8h_1add7ee0701ba35904d190811b9e5a4eda"></span>UBaseType_t <code class="descname">uxQueueMessagesWaiting</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422uxQueueMessagesWaitingK13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ რიგში შენახული შეტყობინებების რაოდენობა.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The number of messages available in the queue. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: მოთხოვნის შესატანი რიგის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422uxQueueSpacesAvailableK13QueueHandle_t">
<span id="_CPPv322uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="_CPPv222uxQueueSpacesAvailableK13QueueHandle_t"></span><span id="uxQueueSpacesAvailable__QueueHandle_tC"></span><span class="target" id="queue_8h_1aae75791e91707c1e0bb31d761921531c"></span>UBaseType_t <code class="descname">uxQueueSpacesAvailable</code><span class="sig-paren">(</span><em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422uxQueueSpacesAvailableK13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დააბრუნეთ რიგში არსებული თავისუფალი ადგილების რაოდენობა. ეს უდრის იმ ერთეულების რაოდენობას, რომელთა გაგზავნაც შესაძლებელია რიგში, სანამ რიგი შეივსება, თუ არცერთი ერთეული არ წაიშლება.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The number of spaces available in the queue. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: მოთხოვნის შესატანი რიგის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv412vQueueDelete13QueueHandle_t">
<span id="_CPPv312vQueueDelete13QueueHandle_t"></span><span id="_CPPv212vQueueDelete13QueueHandle_t"></span><span id="vQueueDelete__QueueHandle_t"></span><span class="target" id="queue_8h_1a707cbcfe3aed6b877b6aa6d9d75a3f22"></span>void <code class="descname">vQueueDelete</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv412vQueueDelete13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რიგის წაშლა - რიგში განთავსებული ელემენტების შესანახად გამოყოფილი მთელი მეხსიერების გათავისუფლება.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: წასაშლელი რიგის სახელური. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t">
<span id="_CPPv320xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="_CPPv220xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t"></span><span id="xQueueReceiveFromISR__QueueHandle_t.voidPC.BaseType_tPC"></span><span class="target" id="queue_8h_1acdf528f5c91131ae2f31c669cfd65758"></span>BaseType_t <code class="descname">xQueueReceiveFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, void *<em class="property">კონსტ</em> <em>pvBuffer</em>, BaseType_t *<em class="property">კონსტ</em> <em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv420xQueueReceiveFromISR13QueueHandle_tPCvPC10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიიღეთ ელემენტი რიგიდან. ამ ფუნქციის გამოყენება უსაფრთხოა შეფერხების სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Function</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cValueToPost</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span><span class="mh">0xff</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">characters</span><span class="o">.</span>
   <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">char</span> <span class="p">)</span> <span class="p">);</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="o">//</span> <span class="o">...</span>

   <span class="o">//</span> <span class="n">Post</span> <span class="n">some</span> <span class="n">characters</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="n">within</span> <span class="n">an</span> <span class="n">ISR</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">queue</span>
   <span class="o">//</span> <span class="ow">is</span> <span class="n">full</span> <span class="n">then</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">block</span> <span class="k">for</span> <span class="n">xTicksToWait</span> <span class="n">ticks</span><span class="o">.</span>
   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">'a'</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>
   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">'b'</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>

   <span class="o">//</span> <span class="o">...</span> <span class="n">keep</span> <span class="n">posting</span> <span class="n">characters</span> <span class="o">...</span> <span class="n">this</span> <span class="n">task</span> <span class="n">may</span> <span class="n">block</span> <span class="n">when</span> <span class="n">the</span> <span class="n">queue</span>
   <span class="o">//</span> <span class="n">becomes</span> <span class="n">full</span><span class="o">.</span>

   <span class="n">cValueToPost</span> <span class="o">=</span> <span class="s1">'c'</span><span class="p">;</span>
   <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cValueToPost</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">ISR</span> <span class="n">that</span> <span class="n">outputs</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">characters</span> <span class="n">received</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vISR_Routine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xTaskWokenByReceive</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">char</span> <span class="n">cRxedChar</span><span class="p">;</span>

   <span class="k">while</span><span class="p">(</span> <span class="n">xQueueReceiveFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">cRxedChar</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xTaskWokenByReceive</span><span class="p">)</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">A</span> <span class="n">character</span> <span class="n">was</span> <span class="n">received</span><span class="o">.</span>  <span class="n">Output</span> <span class="n">the</span> <span class="n">character</span> <span class="n">now</span><span class="o">.</span>
       <span class="n">vOutputCharacter</span><span class="p">(</span> <span class="n">cRxedChar</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">If</span> <span class="n">removing</span> <span class="n">the</span> <span class="n">character</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span> <span class="n">woke</span> <span class="n">the</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span>
       <span class="o">//</span> <span class="n">posting</span> <span class="n">onto</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">cTaskWokenByReceive</span> <span class="n">will</span> <span class="n">have</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">to</span>
       <span class="o">//</span> <span class="n">pdTRUE</span><span class="o">.</span>  <span class="n">No</span> <span class="n">matter</span> <span class="n">how</span> <span class="n">many</span> <span class="n">times</span> <span class="n">this</span> <span class="n">loop</span> <span class="n">iterates</span> <span class="n">only</span> <span class="n">one</span>
       <span class="o">//</span> <span class="n">task</span> <span class="n">will</span> <span class="n">be</span> <span class="n">woken</span><span class="o">.</span>
   <span class="p">}</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">cTaskWokenByPost</span> <span class="o">!=</span> <span class="p">(</span> <span class="n">char</span> <span class="p">)</span> <span class="n">pdFALSE</span><span class="p">;</span>
   <span class="p">{</span>
       <span class="n">taskYIELD</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, საიდანაც უნდა იქნას მიღებული ნივთი.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: ბუფერის მაჩვენებელი, რომელშიც მიღებული ელემენტი დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>შესაძლოა, დავალება დაბლოკილი იყოს რიგში თავისუფალი ადგილის გამოჩენის მოლოდინში. თუ xQueueReceiveFromISR იწვევს ასეთი დავალების განბლოკვას, *pxTaskWoken დაყენდება pdTRUE-ზე, წინააღმდეგ შემთხვევაში *pxTaskWoken უცვლელი დარჩება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419vQueueAddToRegistry13QueueHandle_tPKc">
<span id="_CPPv319vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="_CPPv219vQueueAddToRegistry13QueueHandle_tPKc"></span><span id="vQueueAddToRegistry__QueueHandle_t.cCP"></span><span class="target" id="queue_8h_1a5279f7129bc36be6ec3eb6fa043e8e40"></span>void <code class="descname">vQueueAddToRegistry</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em>, <em class="property">კონსტ</em> char *<em>კომპიუტერის სახელი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419vQueueAddToRegistry13QueueHandle_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რეესტრი მოცემულია ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერებს რიგების, სემაფორების და მუტექსების მოსაძებნად. თუ გსურთ, რომ სახელური ხელმისაწვდომი იყოს ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერს, გამოიძახეთ vQueueAddToRegistry() და დაამატეთ რიგის, სემაფორის ან მუტექსის სახელური რეესტრში. თუ არ იყენებთ ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერს, მაშინ ეს ფუნქცია შეიძლება იგნორირებული იყოს.</p>
<p>configQUEUE_REGISTRY_SIZE განსაზღვრავს რეესტრის მიერ დაშვებული სახელურების მაქსიმალურ რაოდენობას. იმისათვის, რომ რეესტრი ხელმისაწვდომი იყოს, configQUEUE_REGISTRY_SIZE Free RTOS Config.h-ში 0-ზე მეტი უნდა იყოს. მისი მნიშვნელობა გავლენას არ ახდენს რიგების, სემაფორების და მუტექსების რაოდენობაზე, რომელთა შექმნაც შესაძლებელია - მხოლოდ იმ რაოდენობაზე, რომლის დაკავებაც რეესტრს შეუძლია.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>რეესტრში დამატებული რიგის სახელური. ეს არის სახელური, რომელიც დაბრუნებულია xQueueCreate()-ის გამოძახებით. აქ ასევე შესაძლებელია სემაფორის და mutex-ის სახელურების გადაცემა.</li>
<li><code class="docutils literal notranslate"><span class="pre">pcName</span></code>: სახელთან ასოცირებული სახელი. ეს არის სახელი, რომელსაც kernel aware გამართვა ger აჩვენებს. რიგის რეესტრი მხოლოდ სტრიქონზე მითითებას ინახავს - ამიტომ სტრიქონი მუდმივი უნდა იყოს (გლობალური ან სასურველია ROM/Flash-ში) და არა სტეკზე. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv421vQueueUnregisterQueue13QueueHandle_t">
<span id="_CPPv321vQueueUnregisterQueue13QueueHandle_t"></span><span id="_CPPv221vQueueUnregisterQueue13QueueHandle_t"></span><span id="vQueueUnregisterQueue__QueueHandle_t"></span><span class="target" id="queue_8h_1a193c170b0241e93d364c1f588c9a1f0c"></span>void <code class="descname">vQueueUnregisterQueue</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv421vQueueUnregisterQueue13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რეესტრი უზრუნველყოფილია, როგორც საშუალება ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერებისთვის რიგების, სემაფორების და მუტექსების მოსაძებნად. თუ გსურთ, რომ სახელური ხელმისაწვდომი იყოს ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერისთვის, გამოიძახეთ vQueueAddToRegistry() ბრძანება, რათა დაამატოთ რიგის, სემაფორის ან მუტექსის სახელური რეესტრში, ხოლო vQueueUnregisterQueue() ბრძანება რიგის, სემაფორის ან მუტექსის რეგისტრიდან მოსაშორებლად. თუ არ იყენებთ ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერს, მაშინ ეს ფუნქცია შეიძლება იგნორირებული იყოს.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>რეესტრიდან წაშლილი რიგის სახელური. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414pcQueueGetName13QueueHandle_t">
<span id="_CPPv314pcQueueGetName13QueueHandle_t"></span><span id="_CPPv214pcQueueGetName13QueueHandle_t"></span><span id="pcQueueGetName__QueueHandle_t"></span><span class="target" id="queue_8h_1ad47e5fd126c81a5849aa945d3b1a26e2"></span><em class="property">კონსტ</em> char *<code class="descname">pcQueueGetName</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <em>xQueue</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv414pcQueueGetName13QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><p>რიგის რეესტრი მოცემულია ბირთვის შესახებ ინფორმაციის მქონე გამართვა გერებისთვის რიგების, სემაფორების და მუტექსების მოსაძებნად. რიგის სახელურიდან რიგის რეესტრში რიგის სახელის მოსაძებნად და დასაბრუნებლად გამოიძახეთ pcQueueGetName().</p>
<dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This function has been back ported from FreeRTOS v9.0.0</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue is in the registry then a pointer to the name of the queue is returned. If the queue is not in the registry then NULL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომლის სახელიც დაბრუნდება. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t">
<span id="_CPPv319xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t"></span><span id="_CPPv219xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t"></span><span id="xQueueGenericCreate__UBaseType_tC.UBaseType_tC.uint8_tC"></span><span class="target" id="queue_8h_1a74fb40ea6a869143597ca91ce90c99c2"></span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <code class="descname">xQueueGenericCreate</code><span class="sig-paren">(</span><em class="property">კონსტ</em> UBaseType_t <em>uxQueueLength</em>, <em class="property">კონსტ</em> UBaseType_t <em>uxItemSize</em>, <em class="property">კონსტ</em> uint8_t <em>ucQueueType</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xQueueGenericCreateK11UBaseType_tK11UBaseType_tK7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფუნქციის ზოგადი ვერსია, რომელიც გამოიყენება რიგის შესაქმნელად დინამიური მეხსიერების განაწილების გამოყენებით. ეს გამოიძახება სხვა ფუნქციებისა და მაკროების მიერ, რომლებიც ქმნიან სხვა RTOS ობიექტებს, რომლებიც იყენებენ რიგის სტრუქტურას, როგორც მათ ბაზას. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t">
<span id="_CPPv325xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t"></span><span id="_CPPv225xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t"></span><span id="xQueueGenericCreateStatic__UBaseType_tC.UBaseType_tC.uint8_tP.StaticQueue_tP.uint8_tC"></span><span class="target" id="queue_8h_1a5b2efe04da1dd893134938188aebc8e1"></span><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <code class="descname">xQueueGenericCreateStatic</code><span class="sig-paren">(</span><em class="property">კონსტ</em> UBaseType_t <em>uxQueueLength</em>, <em class="property">კონსტ</em> UBaseType_t <em>uxItemSize</em>, uint8_t *<em>pucQueueStorage</em>, StaticQueue_t *<em>pxStaticQueue</em>, <em class="property">კონსტ</em> uint8_t <em>ucQueueType</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv425xQueueGenericCreateStaticK11UBaseType_tK11UBaseType_tP7uint8_tP13StaticQueue_tK7uint8_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფუნქციის ზოგადი ვერსია, რომელიც გამოიყენება რიგის შესაქმნელად დინამიური მეხსიერების განაწილების გამოყენებით. ეს გამოიძახება სხვა ფუნქციებისა და მაკროების მიერ, რომლებიც ქმნიან სხვა RTOS ობიექტებს, რომლებიც იყენებენ რიგის სტრუქტურას, როგორც მათ ბაზას. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415xQueueCreateSetK11UBaseType_t">
<span id="_CPPv315xQueueCreateSetK11UBaseType_t"></span><span id="_CPPv215xQueueCreateSetK11UBaseType_t"></span><span id="xQueueCreateSet__UBaseType_tC"></span><span class="target" id="queue_8h_1ad4208ad97f737af942a13e64b45e83e8"></span><a class="reference internal" href="freertos.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <code class="descname">xQueueCreateSet</code><span class="sig-paren">(</span><em class="property">კონსტ</em> UBaseType_t <em>uxEventQueueLength</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415xQueueCreateSetK11UBaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რიგის ნაკრებები უზრუნველყოფს მექანიზმს, რომელიც დავალებას საშუალებას აძლევს ერთდროულად დაბლოკოს (შეჩერდეს) წაკითხვის ოპერაცია მრავალი რიგიდან ან სემაფორიდან.</p>
<p>ამ ფუნქციის გამოყენების მაგალითისთვის იხილეთ Free RTOS /Source/Demo/Common/Minimal/QueueSet.c.</p>
<p>რიგის ნაკრები უნდა შეიქმნას xQueueCreateSet()-ის გამოძახების გამოყენებით, სანამ ის გამოყენებული იქნება. შექმნის შემდეგ, სტანდარტული Free RTOS რიგები და სემაფორები შეიძლება დაემატოს ნაკრებში xQueueAddToSet()-ის გამოძახების გამოყენებით. შემდეგ xQueueSelectFromSet() გამოიყენება იმის დასადგენად, თუ ნაკრებში შემავალი რომელი რიგები ან სემაფორებია ისეთ მდგომარეობაში, სადაც რიგის წაკითხვის ან სემაფორის აღების ოპერაცია წარმატებული იქნება.</p>
<p>შენიშვნა 1: იხილეთ დოკუმენტაცია <a class="reference external" href="http://wwwFreeRTOS.org/RTOS-queue-sets.html">http://wwwუფასო RTOS .org/ RTOS -queue-sets.html</a> რის გამოც რიგების ნაკრები პრაქტიკაში ძალიან იშვიათად არის საჭირო, რადგან არსებობს მრავალი ობიექტის დაბლოკვის უფრო მარტივი მეთოდები.</p>
<p>შენიშვნა 2: მუტექსის შემცველი რიგის ნაკრებზე ბლოკირება არ გამოიწვევს მუტექსის მფლობელის მიერ დაბლოკილი დავალების პრიორიტეტის მემკვიდრეობით მიღებას.</p>
<p>შენიშვნა 3: რიგის ნაკრებში დამატებული თითოეული რიგის თითოეული სივრცისთვის საჭიროა დამატებით 4 ბაიტი ოპერატიული მეხსიერება. ამიტომ, რიგის ნაკრებში არ უნდა დაემატოს ისეთი დათვლის სემაფორები, რომლებსაც აქვთ მაღალი მაქსიმალური დათვლის მნიშვნელობა.</p>
<p>შენიშვნა 4: რიგის წევრზე არ უნდა შესრულდეს მიღების (რიგის შემთხვევაში) ან აღების (სემფორის შემთხვევაში) ოპერაცია, თუ xQueueSelectFromSet()-ის გამოძახება ჯერ არ დააბრუნებს სახელურს ამ ნაკრების წევრზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxEventQueueLength</span></code>რიგის ნაკრები ინახავს მოვლენებს, რომლებიც ხდება ნაკრებში შემავალ რიგებსა და სემაფორებზე. uxEventQueueLength განსაზღვრავს ერთდროულად რიგში ჩასადგმელი მოვლენების მაქსიმალურ რაოდენობას. იმისათვის, რომ აბსოლუტურად დარწმუნებული იყოთ, რომ მოვლენები არ დაიკარგება, uxEventQueueLength უნდა დაყენდეს ნაკრებში დამატებული რიგების სიგრძის ჯამურ ჯამად, სადაც ბინარულ სემაფორებსა და მუტექსებს აქვთ 1-ის სიგრძე, ხოლო დამთვლელ სემაფორებს აქვთ სიგრძე, რომელიც განისაზღვრება მათი მაქსიმალური დათვლის მნიშვნელობით. მაგალითები:<ul>
<li>თუ რიგის ნაკრები შეიცავს 5 სიგრძის რიგს, 12 სიგრძის კიდევ ერთ რიგს და ორობით სემაფორს, მაშინ uxEventQueueLength უნდა იყოს დაყენებული (5 + 12 + 1)-ზე, ანუ 18-ზე.</li>
<li>თუ რიგის ნაკრები სამ ბინარულ სემაფორას შეიცავს, მაშინ uxEventQueueLength უნდა იყოს დაყენებული (1 + 1 + 1)-ზე, ანუ 3-ზე.</li>
<li>თუ რიგი უნდა შეიცავდეს დამთვლელ სემაფორას, რომლის მაქსიმალური რაოდენობაა 5 და დამთვლელი სემაფორას, რომლის მაქსიმალური რაოდენობაა 3, მაშინ uxEventQueueLength უნდა იყოს დაყენებული (5 + 3)-ზე, ანუ 8-ზე.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv314xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv214xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueAddToSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1ae07b563e6bbe42a977f7c46853aa11eb"></span>BaseType_t <code class="descname">xQueueAddToSet</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">რიგის ნაკრები წევრის სახელური_t</a> <em>xQueueOrSemaphore</em>, <a class="reference internal" href="freertos.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv414xQueueAddToSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რიგს ან სემაფორას უმატებს რიგების ნაკრებებს, რომლებიც ადრე შეიქმნა xQueueCreateSet() ფუნქციის გამოძახებით.</p>
<p>ამ ფუნქციის გამოყენების მაგალითისთვის იხილეთ Free RTOS /Source/Demo/Common/Minimal/QueueSet.c.</p>
<p>შენიშვნა 1: რიგის წევრზე არ უნდა შესრულდეს მიღების (რიგის შემთხვევაში) ან აღების (სემფორის შემთხვევაში) ოპერაცია, თუ xQueueSelectFromSet()-ის გამოძახება ჯერ არ დააბრუნებს სახელურს ამ ნაკრების წევრზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueOrSemaphore</span></code>რიგის ნაკრებში დამატებული რიგის ან სემაფორის სახელური (QueueSetMemberHandle_t ტიპის მიხედვით).</li>
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>რიგის ან სემაფორის დამატების რიგის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t">
<span id="_CPPv319xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="_CPPv219xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t"></span><span id="xQueueRemoveFromSet__QueueSetMemberHandle_t.QueueSetHandle_t"></span><span class="target" id="queue_8h_1ab16fdd17b9b6d74a82c8366f47cda162"></span>BaseType_t <code class="descname">xQueueRemoveFromSet</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">რიგის ნაკრები წევრის სახელური_t</a> <em>xQueueOrSemaphore</em>, <a class="reference internal" href="freertos.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xQueueRemoveFromSet22QueueSetMemberHandle_t16QueueSetHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რიგის ნაკრებიდან რიგს ან სემაფორს შლის. რიგის ან სემაფორის ნაკრებიდან ამოღება მხოლოდ იმ შემთხვევაშია შესაძლებელი, თუ რიგი ან სემაფორი ცარიელია.</p>
<p>ამ ფუნქციის გამოყენების მაგალითისთვის იხილეთ Free RTOS /Source/Demo/Common/Minimal/QueueSet.c.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue or semaphore was successfully removed from the queue set then pdPASS is returned. If the queue was not in the queue set, or the queue (or semaphore) was not empty, then pdFAIL is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueOrSemaphore</span></code>რიგის ნაკრებიდან ამოღებული რიგის ან სემაფორის სახელური (QueueSetMemberHandle_t ტიპის მიხედვით).</li>
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>რიგის ან სემაფორის ნაკრების სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t">
<span id="_CPPv319xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="_CPPv219xQueueSelectFromSet16QueueSetHandle_tK10TickType_t"></span><span id="xQueueSelectFromSet__QueueSetHandle_t.TickType_tC"></span><span class="target" id="queue_8h_1a71f56e6277ed4e419c707c8d0c785065"></span><a class="reference internal" href="freertos.html#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">რიგის ნაკრები წევრის სახელური_t</a> <code class="descname">xQueueSelectFromSet</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em>, <em class="property">კონსტ</em> TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xQueueSelectFromSet16QueueSetHandle_tK10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>xQueueSelectFromSet() რიგის ნაკრების წევრებიდან ირჩევს რიგს ან სემაფორას, რომელიც ან შეიცავს მონაცემებს (რიგის შემთხვევაში) ან ხელმისაწვდომია აღებისთვის (სემფორის შემთხვევაში). xQueueSelectFromSet() ეფექტურად საშუალებას აძლევს დავალებას ერთდროულად დაბლოკოს (შეყოვნდეს) წაკითხვის ოპერაცია რიგის ნაკრების ყველა რიგში და სემაფორზე.</p>
<p>ამ ფუნქციის გამოყენების მაგალითისთვის იხილეთ Free RTOS /Source/Demo/Common/Minimal/QueueSet.c.</p>
<p>შენიშვნა 1: იხილეთ დოკუმენტაცია <a class="reference external" href="http://wwwFreeRTOS.org/RTOS-queue-sets.html">http://wwwუფასო RTOS .org/ RTOS -queue-sets.html</a> რის გამოც რიგების ნაკრები პრაქტიკაში ძალიან იშვიათად არის საჭირო, რადგან არსებობს მრავალი ობიექტის დაბლოკვის უფრო მარტივი მეთოდები.</p>
<p>შენიშვნა 2: მუტექსის შემცველი რიგის ნაკრებზე ბლოკირება არ გამოიწვევს მუტექსის მფლობელის მიერ დაბლოკილი დავალების პრიორიტეტის მემკვიდრეობით მიღებას.</p>
<p>შენიშვნა 3: რიგის წევრზე არ უნდა შესრულდეს მიღების (რიგის შემთხვევაში) ან აღების (სემფორის შემთხვევაში) ოპერაცია, თუ xQueueSelectFromSet()-ის გამოძახება ჯერ არ დააბრუნებს სახელურს ამ ნაკრების წევრზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>xQueueSelectFromSet() will return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data, or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueueSet</span></code>რიგი, რომელზეც დავალება (პოტენციურად) დაიბლოკება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>მაქსიმალური დრო, ტიკებში, რომლის განმავლობაშიც გამომძახებელი დავალება დარჩება დაბლოკილ მდგომარეობაში (სხვა დავალებების შესრულებისას) რიგის წევრის მზადყოფნის დასალოდებლად რიგის წარმატებული წაკითხვის ან სემაფორის აღების ოპერაციისთვის.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t">
<span id="_CPPv326xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="_CPPv226xQueueSelectFromSetFromISR16QueueSetHandle_t"></span><span id="xQueueSelectFromSetFromISR__QueueSetHandle_t"></span><span class="target" id="queue_8h_1ac58b34fd733cf460cddab1abb9a899b3"></span><a class="reference internal" href="freertos.html#_CPPv422QueueSetMemberHandle_t" title="QueueSetMemberHandle_t">რიგის ნაკრები წევრის სახელური_t</a> <code class="descname">xQueueSelectFromSetFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv416QueueSetHandle_t" title="QueueSetHandle_t">QueueSetHandle_t</a> <em>xQueueSet</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv426xQueueSelectFromSetFromISR16QueueSetHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>xQueueSelectFromSet()-ის ვერსია, რომლის გამოყენებაც შესაძლებელია ISR-დან. </p>
</dd></dl>
</div>
<div class="section" id="id3">
<h3>მაკროები<a class="headerlink" href="freertos.html#id3" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.xQueueCreate">
<span class="target" id="queue_8h_1aeb858b824bd74a934ea7ebb81af2a6bb"></span><code class="descname">xQueueCreate</code><span class="sig-paren">(</span>uxQueueLength, uxItemSize<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueCreate" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის რიგის ახალ ეგზემპლარს. ეს გამოყოფს ახალი რიგისთვის საჭირო მეხსიერებას და აბრუნებს რიგისთვის სახელურს.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">};</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Queue</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Queue</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue is successfully create then a handle to the newly created queue is returned. If the queue cannot be created then 0 is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxQueueLength</span></code>: რიგში შეიძლება განთავსდეს ელემენტების მაქსიმალური რაოდენობა.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxItemSize</span></code>რიგში თითოეული ელემენტისთვის საჭირო ბაიტების რაოდენობა. ელემენტები რიგშია კოპირებული და არა მითითებით, ამიტომ ეს არის ბაიტების რაოდენობა, რომელიც კოპირდება თითოეული გამოქვეყნებული ელემენტისთვის. რიგში თითოეული ელემენტი ერთი და იგივე ზომის უნდა იყოს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueCreateStatic">
<span class="target" id="queue_8h_1a867bd68852e9eea7206d364a7e165e57"></span><code class="descname">xQueueCreateStatic</code><span class="sig-paren">(</span>uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueCreateStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის რიგის ახალ ინსტანციას და აბრუნებს სახელურს, რომლის მეშვეობითაც შესაძლებელია ახალი რიგის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, რიგები იყენებენ მეხსიერების ორ ბლოკს. პირველი ბლოკი გამოიყენება რიგის მონაცემთა სტრუქტურების შესანახად. მეორე ბლოკი გამოიყენება რიგში განთავსებული ელემენტების შესანახად. თუ რიგი იქმნება xQueueCreate() ფუნქციის გამოყენებით, მაშინ მეხსიერების ორივე ბლოკი ავტომატურად დინამიურად გამოიყოფა xQueueCreate() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ რიგი იქმნება xQueueCreateStatic()-ის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს რიგის მიერ გამოყენებული მეხსიერება. შესაბამისად, xQueueCreateStatic() საშუალებას იძლევა რიგი შეიქმნას დინამიური მეხსიერების განაწილების გარეშე.</p>
<p><a class="reference external" href="http://www.FreeRTOS.org/Embedded-RTOS-Queues.html">http://www.Free RTOS .org/Embedded RTOS -Queues.html</a></p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
 <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
 <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">};</span>

<span class="c1">#define QUEUE_LENGTH 10</span>
<span class="c1">#define ITEM_SIZE sizeof( uint32_t )</span>

<span class="o">//</span> <span class="n">xQueueBuffer</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">structure</span><span class="o">.</span>
<span class="n">StaticQueue_t</span> <span class="n">xQueueBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">ucQueueStorage</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">items</span> <span class="n">posted</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Must</span> <span class="n">be</span> <span class="n">at</span> <span class="n">least</span>
<span class="o">//</span> <span class="p">[(</span><span class="n">queue</span> <span class="n">length</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="n">queue</span> <span class="n">item</span> <span class="n">size</span><span class="p">)]</span> <span class="nb">bytes</span> <span class="n">long</span><span class="o">.</span>
<span class="n">uint8_t</span> <span class="n">ucQueueStorage</span><span class="p">[</span> <span class="n">QUEUE_LENGTH</span> <span class="o">*</span> <span class="n">ITEM_SIZE</span> <span class="p">];</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
 <span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
 <span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="n">QUEUE_LENGTH</span><span class="p">,</span> <span class="o">//</span> <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">items</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">can</span> <span class="n">hold</span><span class="o">.</span>
                         <span class="n">ITEM_SIZE</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">size</span> <span class="n">of</span> <span class="n">each</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span>
                         <span class="o">&amp;</span><span class="p">(</span> <span class="n">ucQueueStorage</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">),</span> <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
                         <span class="o">&amp;</span><span class="n">xQueueBuffer</span> <span class="p">);</span> <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">structure</span><span class="o">.</span>

 <span class="o">//</span> <span class="n">The</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">guaranteed</span> <span class="n">to</span> <span class="n">be</span> <span class="n">created</span> <span class="n">successfully</span> <span class="k">as</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span>
 <span class="o">//</span> <span class="n">allocation</span> <span class="ow">is</span> <span class="n">used</span><span class="o">.</span>  <span class="n">Therefore</span> <span class="n">xQueue1</span> <span class="ow">is</span> <span class="n">now</span> <span class="n">a</span> <span class="n">handle</span> <span class="n">to</span> <span class="n">a</span> <span class="n">valid</span> <span class="n">queue</span><span class="o">.</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the queue is created then a handle to the created queue is returned. If pxQueueBuffer is NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxQueueLength</span></code>: რიგში შეიძლება განთავსდეს ელემენტების მაქსიმალური რაოდენობა.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxItemSize</span></code>რიგში თითოეული ელემენტისთვის საჭირო ბაიტების რაოდენობა. ელემენტები რიგშია კოპირებული და არა მითითებით, ამიტომ ეს არის ბაიტების რაოდენობა, რომელიც კოპირდება თითოეული გამოქვეყნებული ელემენტისთვის. რიგში თითოეული ელემენტი ერთი და იგივე ზომის უნდა იყოს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pucQueueStorage</span></code>თუ uxItemSize ნულის ტოლი არ არის, მაშინ pucQueueStorageBuffer უნდა მიუთითებდეს uint8_t მასივზე, რომელიც სულ მცირე საკმარისად დიდია იმისათვის, რომ ერთდროულად რიგში მყოფი ელემენტების მაქსიმალური რაოდენობა შეინახოს - რაც (uxQueueLength * uxItemsSize) ბაიტებს შეადგენს. თუ uxItemSize ნულის ტოლია, მაშინ pucQueueStorageBuffer შეიძლება იყოს NULL.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxQueueBuffer</span></code>უნდა მიუთითებდეს StaticQueue_t ტიპის ცვლადზე, რომელიც გამოყენებული იქნება რიგის მონაცემთა სტრუქტურის შესანახად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSendToFront">
<span class="target" id="queue_8h_1aa612fcc2b1ceee0200f34b942e300b41"></span><code class="descname">xQueueSendToFront</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSendToFront" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSend() ფუნქციას.</p>
<p>ელემენტის რიგის თავში განთავსება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით. ეს ფუნქცია არ უნდა გამოიძახონ შეწყვეტის სერვისის რუტინიდან. იხილეთ xQueueSendFromISR () ალტერნატივისთვის, რომელიც შეიძლება გამოყენებულ იქნას ISR-ში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSendToFront</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSendToFront</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო, რომლის განმავლობაშიც დავალება უნდა დაბლოკოს რიგში ადგილის გამოთავისუფლების მოლოდინში, თუ ის უკვე სავსეა. ზარი დაუყოვნებლივ დაბრუნდება, თუ ეს დაყენებულია 0-ზე და რიგი სავსეა. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული მუდმივი portTICK_PERIOD_MS.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSendToBack">
<span class="target" id="queue_8h_1a81d24a2c1199d58efb76fbee15853112"></span><code class="descname">xQueueSendToBack</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSendToBack" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSend() ფუნქციას.</p>
<p>ელემენტის რიგის ბოლოში განთავსება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით. ეს ფუნქცია არ უნდა გამოიძახონ შეწყვეტის სერვისის რუტინიდან. იხილეთ xQueueSendFromISR () ალტერნატივისთვის, რომელიც შეიძლება გამოყენებულ იქნას ISR-ში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSendToBack</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSendToBack</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო, რომლის განმავლობაშიც დავალება უნდა დაბლოკოს რიგში ადგილის გამოთავისუფლების მოლოდინში, თუ ის უკვე სავსეა. ზარი დაუყოვნებლივ დაბრუნდება, თუ ეს დაყენებულია 0-ზე და რიგი სავსეა. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული მუდმივი portTICK_PERIOD_MS.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSend">
<span class="target" id="queue_8h_1af7eb49d3249351176992950d9185abe9"></span><code class="descname">xQueueSend</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSend" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSend() ფუნქციას. ის ჩართულია Free RTOS .org-ის იმ ვერსიებთან უკუთავსებადობისთვის, რომლებიც არ შეიცავდნენ xQueueSendToFront() და xQueueSendToBack() მაკროებს. ის xQueueSendToBack()-ის ეკვივალენტურია.</p>
<p>ელემენტის რიგში განთავსება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით. ეს ფუნქცია არ უნდა გამოიძახონ შეწყვეტის სერვისის რუტინიდან. იხილეთ xQueueSendFromISR () ალტერნატივისთვის, რომელიც შეიძლება გამოყენებულ იქნას ISR-ში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">uint32_t</span> <span class="n">ulVar</span> <span class="o">=</span> <span class="mi">10</span><span class="n">UL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">QueueHandle_t</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="n">xQueue2</span><span class="p">;</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">uint32_t</span> <span class="n">values</span><span class="o">.</span>
<span class="n">xQueue1</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue2</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">an</span> <span class="n">uint32_t</span><span class="o">.</span>  <span class="n">Wait</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">space</span> <span class="n">to</span> <span class="n">become</span>
    <span class="o">//</span> <span class="n">available</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue1</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">ulVar</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">post</span> <span class="n">the</span> <span class="n">message</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="mi">10</span> <span class="n">ticks</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue2</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
    <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
    <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
    <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue2</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო, რომლის განმავლობაშიც დავალება უნდა დაბლოკოს რიგში ადგილის გამოთავისუფლების მოლოდინში, თუ ის უკვე სავსეა. ზარი დაუყოვნებლივ დაბრუნდება, თუ ეს დაყენებულია 0-ზე და რიგი სავსეა. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული მუდმივი portTICK_PERIOD_MS.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueOverwrite">
<span class="target" id="queue_8h_1a8e9ced123b5a0e37a36d3bbdb2e56b4e"></span><code class="descname">xQueueOverwrite</code><span class="sig-paren">(</span>xQueue, pvItemToQueue<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueOverwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>გამოიყენება მხოლოდ ერთი სიგრძის რიგებისთვის - ამგვარად, რიგი ან ცარიელია, ან სავსე.</p>
<p>ელემენტის რიგში განთავსება. თუ რიგი უკვე სავსეა, მაშინ რიგში შენახული მნიშვნელობა გადაიწერება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით.</p>
<p>ეს ფუნქცია არ უნდა გამოიძახონ შეწყვეტის სერვისის რუტინიდან. იხილეთ xQueueOverwriteFromISR () ალტერნატივისთვის, რომელიც შეიძლება გამოყენებულ იქნას ISR-ში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> void vFunction( void *pvParameters )
 {
 QueueHandle_t xQueue;
 uint32_t ulVarToSend, ulValReceived;

 // Create a queue to hold one uint32_t value.  It is strongly
 // recommended *not* to use xQueueOverwrite() on queues that can
 // contain more than one value, and doing so will trigger an assertion
 // if configASSERT() is defined.
 xQueue = xQueueCreate( 1, sizeof( uint32_t ) );

 // Write the value 10 to the queue using xQueueOverwrite().
 ulVarToSend = 10;
 xQueueOverwrite( xQueue, &amp;ulVarToSend );

 // Peeking the queue should now return 10, but leave the value 10 in
 // the queue.  A block time of zero is used as it is known that the
 // queue holds a value.
 ulValReceived = 0;
 xQueuePeek( xQueue, &amp;ulValReceived, 0 );

 if( ulValReceived != 10 )
 {
     // Error unless the item was removed by a different task.
 }

 // The queue is still full.  Use xQueueOverwrite() to overwrite the
 // value held in the queue with 100.
 ulVarToSend = 100;
 xQueueOverwrite( xQueue, &amp;ulVarToSend );

 // This time read from the queue, leaving the queue empty once more.
 // A block time of 0 is used again.
 xQueueReceive( xQueue, &amp;ulValReceived, 0 );

 // The value read should be the last value written, even though the
 // queue was already full when the value was written.
 if( ulValReceived != 100 )
 {
     // Error!
 }

 // ...
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>xQueueOverwrite() is a macro that calls xQueueGenericSend(), and therefore has the same return values as xQueueSendToFront(). However, pdPASS is the only value that can be returned because xQueueOverwrite() will write to the queue even when the queue is already full.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც მონაცემები იგზავნება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueuePeek">
<span class="target" id="queue_8h_1a2df70733bb875477cd9614c5b3446257"></span><code class="descname">xQueuePeek</code><span class="sig-paren">(</span>xQueue, pvBuffer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueuePeek" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც იძახებს xQueueGenericReceive() ფუნქციას.</p>
<p>რიგიდან ელემენტის მიღება რიგიდან მისი ამოღების გარეშე. ელემენტი მიიღება კოპირებით, ამიტომ უნდა იყოს უზრუნველყოფილი შესაბამისი ზომის ბუფერი. ბუფერში კოპირებული ბაიტების რაოდენობა განისაზღვრა რიგის შექმნისას.</p>
<p>წარმატებით მიღებული ერთეულები რიგში რჩება, ამიტომ ისინი კვლავ დაბრუნდება შემდეგი ზარის დროს ან xQueueReceive()-ის ზარის დროს.</p>
<p>ეს მაკრო არ უნდა იქნას გამოყენებული შეწყვეტის სერვისის რუტინაში. იხილეთ xQueuePeekFromISR() ალტერნატივისთვის, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
<span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
<span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
<span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
<span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span>

<span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
<span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
<span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
<span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">peek</span> <span class="n">the</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

<span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Peek</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
    <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xQueuePeek</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
        <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="p">,</span> <span class="n">but</span> <span class="n">the</span> <span class="n">item</span> <span class="n">still</span> <span class="n">remains</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, საიდანაც უნდა იქნას მიღებული ნივთი.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: ბუფერის მაჩვენებელი, რომელშიც მიღებული ელემენტი დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>მაქსიმალური დრო, რომელიც დავალებამ უნდა დაბლოკოს ელემენტის მიღების მოლოდინში, თუ რიგი გამოძახების დროს ცარიელია. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული portTICK_PERIOD_MS კონსტანტა. xQueuePeek() დაუყოვნებლივ დააბრუნებს, თუ xTicksToWait 0-ის ტოლია და რიგი ცარიელია.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueReceive">
<span class="target" id="queue_8h_1af1549eac0e7f05694a59a0b967c80be3"></span><code class="descname">xQueueReceive</code><span class="sig-paren">(</span>xQueue, pvBuffer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueReceive" title="Permalink to this definition">¶</a></dt>
<dd><p>რიგი. სთ </p>
<p>ეს არის მაკრო, რომელიც იძახებს xQueueGenericReceive() ფუნქციას.</p>
<p>რიგიდან ელემენტის მიღება. ელემენტი მიიღება კოპირებით, ამიტომ უნდა იყოს უზრუნველყოფილი შესაბამისი ზომის ბუფერი. ბუფერში კოპირებული ბაიტების რაოდენობა განისაზღვრა რიგის შექმნისას.</p>
<p>წარმატებით მიღებული ნივთები ამოღებულია რიგიდან.</p>
<p>ეს ფუნქცია არ უნდა იქნას გამოყენებული შეფერხების სერვისის რუტინაში. ალტერნატივისთვის იხილეთ xQueueReceiveFromISR.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">AMessage</span>
<span class="p">{</span>
 <span class="n">char</span> <span class="n">ucMessageID</span><span class="p">;</span>
 <span class="n">char</span> <span class="n">ucData</span><span class="p">[</span> <span class="mi">20</span> <span class="p">];</span>
<span class="p">}</span> <span class="n">xMessage</span><span class="p">;</span>

<span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">create</span> <span class="n">a</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">post</span> <span class="n">a</span> <span class="n">value</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxMessage</span><span class="p">;</span>

 <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">capable</span> <span class="n">of</span> <span class="n">containing</span> <span class="mi">10</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">AMessage</span> <span class="n">structures</span><span class="o">.</span>
 <span class="o">//</span> <span class="n">These</span> <span class="n">should</span> <span class="n">be</span> <span class="n">passed</span> <span class="n">by</span> <span class="n">pointer</span> <span class="k">as</span> <span class="n">they</span> <span class="n">contain</span> <span class="n">a</span> <span class="n">lot</span> <span class="n">of</span> <span class="n">data</span><span class="o">.</span>
 <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span> <span class="p">)</span> <span class="p">);</span>
 <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Failed</span> <span class="n">to</span> <span class="n">create</span> <span class="n">the</span> <span class="n">queue</span><span class="o">.</span>
 <span class="p">}</span>

 <span class="o">//</span> <span class="o">...</span>

 <span class="o">//</span> <span class="n">Send</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="nb">object</span><span class="o">.</span>  <span class="n">Don</span><span class="s1">'t block if the</span>
 <span class="o">//</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">full</span><span class="o">.</span>
 <span class="n">pxMessage</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="n">xMessage</span><span class="p">;</span>
 <span class="n">xQueueSend</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">pxMessage</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">0</span> <span class="p">);</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">Task</span> <span class="n">to</span> <span class="n">receive</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vADifferentTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">struct</span> <span class="n">AMessage</span> <span class="o">*</span><span class="n">pxRxedMessage</span><span class="p">;</span>

 <span class="k">if</span><span class="p">(</span> <span class="n">xQueue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
 <span class="p">{</span>
     <span class="o">//</span> <span class="n">Receive</span> <span class="n">a</span> <span class="n">message</span> <span class="n">on</span> <span class="n">the</span> <span class="n">created</span> <span class="n">queue</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">a</span>
     <span class="o">//</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">immediately</span> <span class="n">available</span><span class="o">.</span>
     <span class="k">if</span><span class="p">(</span> <span class="n">xQueueReceive</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">pxRxedMessage</span> <span class="p">),</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">pcRxedMessage</span> <span class="n">now</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="n">struct</span> <span class="n">AMessage</span> <span class="n">variable</span> <span class="n">posted</span>
         <span class="o">//</span> <span class="n">by</span> <span class="n">vATask</span><span class="o">.</span>
     <span class="p">}</span>
 <span class="p">}</span>

 <span class="o">//</span> <span class="o">...</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if an item was successfully received from the queue, otherwise pdFALSE.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, საიდანაც უნდა იქნას მიღებული ნივთი.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvBuffer</span></code>: ბუფერის მაჩვენებელი, რომელშიც მიღებული ელემენტი დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო, რომელიც დავალებამ უნდა დაბლოკოს ელემენტის მიღების მოლოდინში, თუ რიგი გამოძახების დროს ცარიელია. xQueueReceive() დაუყოვნებლივ დააბრუნებს, თუ xTicksToWait ნულის ტოლია და რიგი ცარიელია. დრო განისაზღვრება ტიკ პერიოდებით, ამიტომ, საჭიროების შემთხვევაში, რეალურ დროში გადასაყვანად უნდა იქნას გამოყენებული მუდმივი portTICK_PERIOD_MS.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSendToFrontFromISR">
<span class="target" id="queue_8h_1af03b83396462affe9e28302660e7b9c6"></span><code class="descname">xQueueSendToFrontFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSendToFrontFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSendFromISR() ფუნქციას.</p>
<p>ელემენტის რიგის თავში განთავსება. ამ მაკროს გამოყენება უსაფრთხოა შეფერხების სერვისის რუტინიდან.</p>
<p>ელემენტები რიგში ასლის და არა მითითების მიხედვითაა, ამიტომ სასურველია რიგში მხოლოდ მცირე ზომის ელემენტების განთავსება, განსაკუთრებით მაშინ, როდესაც ისინი ISR-დან იძახება. უმეტეს შემთხვევაში, სასურველია რიგში მყოფი ელემენტის მითითების შენახვა.</p>
<p><p>ბუფერული IO-ს გამოყენების მაგალითი (სადაც ISR-ს შეუძლია ერთზე მეტი მნიშვნელობის მიღება თითო გამოძახებაზე): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPrioritTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendToFrontFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>თუ რიგში გაგზავნამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებული დავალების პრიორიტეტი უფრო მაღალი აქვს, xQueueSendToFromISR() ფუნქცია ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეფერხებიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSendToBackFromISR">
<span class="target" id="queue_8h_1a51e9f73417b11441a181cdc4f33a68e9"></span><code class="descname">xQueueSendToBackFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSendToBackFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSendFromISR() ფუნქციას.</p>
<p>ელემენტის განთავსება რიგის ბოლოში. ამ მაკროს გამოყენება უსაფრთხოა შეფერხების სერვისის რუტინიდან.</p>
<p>ელემენტები რიგში ასლის და არა მითითების მიხედვითაა, ამიტომ სასურველია რიგში მხოლოდ მცირე ზომის ელემენტების განთავსება, განსაკუთრებით მაშინ, როდესაც ისინი ISR-დან იძახება. უმეტეს შემთხვევაში, სასურველია რიგში მყოფი ელემენტის მითითების შენახვა.</p>
<p><p>ბუფერული IO-ს გამოყენების მაგალითი (სადაც ISR-ს შეუძლია ერთზე მეტი მნიშვნელობის მიღება თითო გამოძახებაზე): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendToBackFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>xQueueSendToBackFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ რიგში გაგზავნამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებულ დავალებაზე მაღალი პრიორიტეტი აქვს. თუ xQueueSendToBackFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueOverwriteFromISR">
<span class="target" id="queue_8h_1abdcd6a86ef82034d002193e79cfd3ce8"></span><code class="descname">xQueueOverwriteFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueOverwriteFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xQueueOverwrite()-ის ვერსია, რომლის გამოყენებაც შესაძლებელია შეწყვეტის სერვისის რუტინაში (ISR).</p>
<p>მხოლოდ იმ რიგებთან გამოსაყენებლად, რომლებსაც შეუძლიათ ერთი ერთეულის განთავსება - ამგვარად, რიგი ან ცარიელია, ან სავსე.</p>
<p>ელემენტის რიგში განთავსება. თუ რიგი უკვე სავსეა, მაშინ რიგში შენახული მნიშვნელობა გადაიწერება. ელემენტი რიგშია ასლის მიხედვით და არა მითითებით.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="n">QueueHandle_t</span> <span class="n">xQueue</span><span class="p">;</span>

 <span class="n">void</span> <span class="n">vFunction</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
 <span class="p">{</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">queue</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">one</span> <span class="n">uint32_t</span> <span class="n">value</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">strongly</span>
    <span class="o">//</span> <span class="n">recommended</span> <span class="o">*</span><span class="ow">not</span><span class="o">*</span> <span class="n">to</span> <span class="n">use</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span> <span class="n">on</span> <span class="n">queues</span> <span class="n">that</span> <span class="n">can</span>
    <span class="o">//</span> <span class="n">contain</span> <span class="n">more</span> <span class="n">than</span> <span class="n">one</span> <span class="n">value</span><span class="p">,</span> <span class="ow">and</span> <span class="n">doing</span> <span class="n">so</span> <span class="n">will</span> <span class="n">trigger</span> <span class="n">an</span> <span class="n">assertion</span>
    <span class="o">//</span> <span class="k">if</span> <span class="n">configASSERT</span><span class="p">()</span> <span class="ow">is</span> <span class="n">defined</span><span class="o">.</span>
    <span class="n">xQueue</span> <span class="o">=</span> <span class="n">xQueueCreate</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vAnInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">must</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">before</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">used</span><span class="o">.</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
<span class="n">uint32_t</span> <span class="n">ulVarToSend</span><span class="p">,</span> <span class="n">ulValReceived</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Write</span> <span class="n">the</span> <span class="n">value</span> <span class="mi">10</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">using</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span><span class="o">.</span>
    <span class="n">ulVarToSend</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">xQueueOverwriteFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">queue</span> <span class="ow">is</span> <span class="n">full</span><span class="p">,</span> <span class="n">but</span> <span class="n">calling</span> <span class="n">xQueueOverwriteFromISR</span><span class="p">()</span> <span class="n">again</span> <span class="n">will</span> <span class="n">still</span>
    <span class="o">//</span> <span class="k">pass</span> <span class="n">because</span> <span class="n">the</span> <span class="n">value</span> <span class="n">held</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">will</span> <span class="n">be</span> <span class="n">overwritten</span> <span class="k">with</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">new</span> <span class="n">value</span><span class="o">.</span>
    <span class="n">ulVarToSend</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">xQueueOverwriteFromISR</span><span class="p">(</span> <span class="n">xQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ulVarToSend</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Reading</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">queue</span> <span class="n">will</span> <span class="n">now</span> <span class="k">return</span> <span class="mf">100.</span>

    <span class="o">//</span> <span class="o">...</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPrioritytaskWoken</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Writing</span> <span class="n">to</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">caused</span> <span class="n">a</span> <span class="n">task</span> <span class="n">to</span> <span class="n">unblock</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">unblocked</span> <span class="n">task</span>
        <span class="o">//</span> <span class="n">has</span> <span class="n">a</span> <span class="n">priority</span> <span class="n">higher</span> <span class="n">than</span> <span class="ow">or</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">priority</span> <span class="n">of</span> <span class="n">the</span> <span class="n">currently</span>
        <span class="o">//</span> <span class="n">executing</span> <span class="n">task</span> <span class="p">(</span><span class="n">the</span> <span class="n">task</span> <span class="n">this</span> <span class="n">interrupt</span> <span class="n">interrupted</span><span class="p">)</span><span class="o">.</span>  <span class="n">Perform</span> <span class="n">a</span> <span class="n">context</span>
        <span class="o">//</span> <span class="n">switch</span> <span class="n">so</span> <span class="n">this</span> <span class="n">interrupt</span> <span class="n">returns</span> <span class="n">directly</span> <span class="n">to</span> <span class="n">the</span> <span class="n">unblocked</span> <span class="n">task</span><span class="o">.</span>
        <span class="n">portYIELD_FROM_ISR</span><span class="p">();</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">portEND_SWITCHING_ISR</span><span class="p">()</span> <span class="n">depending</span> <span class="n">on</span> <span class="n">the</span> <span class="n">port</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>xQueueOverwriteFromISR() is a macro that calls xQueueGenericSendFromISR(), and therefore has the same return values as xQueueSendToFrontFromISR(). However, pdPASS is the only value that can be returned because xQueueOverwriteFromISR() will write to the queue even when the queue is already full.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>თუ რიგში გაგზავნამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებული დავალების პრიორიტეტი უფრო მაღალი აქვს, xQueueOverwriteFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტის დასრულებამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueSendFromISR">
<span class="target" id="queue_8h_1a21d5919ed26c21d121df4a4debeb643c"></span><code class="descname">xQueueSendFromISR</code><span class="sig-paren">(</span>xQueue, pvItemToQueue, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueSendFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>ეს არის მაკრო, რომელიც გამოიძახებს xQueueGenericSendFromISR() ფუნქციას. ის ჩართულია Free RTOS .org-ის იმ ვერსიებთან უკუთავსებადობისთვის, რომლებიც არ შეიცავდნენ xQueueSendToBackFromISR() და xQueueSendToFrontFromISR() მაკროებს.</p>
<p>ელემენტის განთავსება რიგის ბოლოში. ამ ფუნქციის გამოყენება უსაფრთხოა შეფერხების სერვისის რუტინიდან.</p>
<p>ელემენტები რიგში ასლის და არა მითითების მიხედვითაა, ამიტომ სასურველია რიგში მხოლოდ მცირე ზომის ელემენტების განთავსება, განსაკუთრებით მაშინ, როდესაც ისინი ISR-დან იძახება. უმეტეს შემთხვევაში, სასურველია რიგში მყოფი ელემენტის მითითების შენახვა.</p>
<p><p>ბუფერული IO-ს გამოყენების მაგალითი (სადაც ISR-ს შეუძლია ერთზე მეტი მნიშვნელობის მიღება თითო გამოძახებაზე): </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">vBufferISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">char</span> <span class="n">cIn</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="ow">not</span> <span class="n">woken</span> <span class="n">a</span> <span class="n">task</span> <span class="n">at</span> <span class="n">the</span> <span class="n">start</span> <span class="n">of</span> <span class="n">the</span> <span class="n">ISR</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Loop</span> <span class="n">until</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span><span class="o">.</span>
   <span class="n">do</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Obtain</span> <span class="n">a</span> <span class="n">byte</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">buffer</span><span class="o">.</span>
       <span class="n">cIn</span> <span class="o">=</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">RX_REGISTER_ADDRESS</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">Post</span> <span class="n">the</span> <span class="n">byte</span><span class="o">.</span>
       <span class="n">xQueueSendFromISR</span><span class="p">(</span> <span class="n">xRxQueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cIn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">portINPUT_BYTE</span><span class="p">(</span> <span class="n">BUFFER_COUNT</span> <span class="p">)</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="n">empty</span> <span class="n">we</span> <span class="n">can</span> <span class="n">switch</span> <span class="n">context</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">Actual</span> <span class="n">macro</span> <span class="n">used</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span><span class="o">.</span>
       <span class="n">portYIELD_FROM_ISR</span> <span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: იმ რიგის სახელური, რომელზეც უნდა განთავსდეს ერთეული.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvItemToQueue</span></code>რიგში განსათავსებელი ელემენტის მაჩვენებელი. რიგის შექმნისას განისაზღვრა რიგის შესანახი ელემენტების ზომა, ამიტომ ამ რაოდენობის ბაიტები pvItemToQueue-დან რიგის შენახვის არეალში დაკოპირდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>თუ რიგში გაგზავნამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებული დავალების პრიორიტეტი უფრო მაღალი აქვს, xQueueSendFromISR() ფუნქცია ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეფერხებიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xQueueReset">
<span class="target" id="queue_8h_1a94df8d8bc938424151f8196db2f1177b"></span><code class="descname">xQueueReset</code><span class="sig-paren">(</span>xQueue<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xQueueReset" title="Permalink to this definition">¶</a></dt>
<dd><p>რიგის საწყის ცარიელ მდგომარეობაში დაბრუნება. pdPASS ბრუნდება, თუ რიგი წარმატებით გადატვირთულია. pdFAIL ბრუნდება, თუ რიგის გადატვირთვა შეუძლებელია, რადგან რიგში არის დაბლოკილი დავალებები, რომლებიც ელოდებიან რიგიდან მიღებას ან რიგში გაგზავნას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>always returns pdPASS </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xQueue</span></code>: გადატვირთვის რიგი </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id4">
<h3>ტიპის განმარტებები<a class="headerlink" href="freertos.html#id4" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv413QueueHandle_t">
<span id="_CPPv313QueueHandle_t"></span><span id="_CPPv213QueueHandle_t"></span><span id="QueueHandle_t"></span><span class="target" id="queue_8h_1aaf19d499892a4ce1409326ece00f5264"></span><em class="property">typedef </em>void *<code class="descname">QueueHandle_t</code><a class="headerlink" href="freertos.html#_CPPv413QueueHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითეთ, თუ რიგებზე მითითება ხდება. მაგალითად, xQueueCreate()-ის გამოძახება აბრუნებს QueueHandle_t ცვლადს, რომლის გამოყენებაც შემდეგ შესაძლებელია პარამეტრად xQueueSend(), xQueueReceive()-ისთვის და ა.შ. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv416QueueSetHandle_t">
<span id="_CPPv316QueueSetHandle_t"></span><span id="_CPPv216QueueSetHandle_t"></span><span id="QueueSetHandle_t"></span><span class="target" id="queue_8h_1a32a86d604e1706d72a5a4c62d8262f56"></span><em class="property">typedef </em>void *<code class="descname">QueueSetHandle_t</code><a class="headerlink" href="freertos.html#_CPPv416QueueSetHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითეთ, თუ რომელი რიგის ნაკრებებზე იქნება მითითებული მითითება. მაგალითად, xQueueCreateSet()-ის გამოძახება აბრუნებს xQueueSet ცვლადს, რომლის გამოყენებაც შემდეგ შესაძლებელია პარამეტრად xQueueSelectFromSet(), xQueueAddToSet()-ისთვის და ა.შ. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv422QueueSetMemberHandle_t">
<span id="_CPPv322QueueSetMemberHandle_t"></span><span id="_CPPv222QueueSetMemberHandle_t"></span><span id="QueueSetMemberHandle_t"></span><span class="target" id="queue_8h_1a6c19a940d8fe07d338928ecea68b1776"></span><em class="property">typedef </em>void *<code class="descname">QueueSetMemberHandle_t</code><a class="headerlink" href="freertos.html#_CPPv422QueueSetMemberHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>რიგის ნაკრებები შეიძლება შეიცავდეს როგორც რიგებს, ასევე სემაფორებს, ამიტომ QueueSetMemberHandle_t განისაზღვრება, როგორც ტიპი, რომელიც უნდა იქნას გამოყენებული, სადაც პარამეტრი ან დაბრუნებული მნიშვნელობა შეიძლება იყოს QueueHandle_t ან SemaphoreHandle_t. </p>
</dd></dl>
</div>
</div>
<div class="section" id="semaphore-api">
<h2>სემაფორი API<a class="headerlink" href="freertos.html#semaphore-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id5">
<h3>სათაურის ფაილი<a class="headerlink" href="freertos.html#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/semphr.h">freertos/include/freertos/semphr.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>მაკროები<a class="headerlink" href="freertos.html#id6" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.semBINARY_SEMAPHORE_QUEUE_LENGTH">
<span class="target" id="semphr_8h_1a73cfd14cf25a13f8dd4dc1d74b7fc04a"></span><code class="descname">semBINARY_SEMAPHORE_QUEUE_LENGTH</code><a class="headerlink" href="freertos.html#c.semBINARY_SEMAPHORE_QUEUE_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.semSEMAPHORE_QUEUE_ITEM_LENGTH">
<span class="target" id="semphr_8h_1a93bd07e28aed3084bdafa1f4e99700b2"></span><code class="descname">semSEMAPHORE_QUEUE_ITEM_LENGTH</code><a class="headerlink" href="freertos.html#c.semSEMAPHORE_QUEUE_ITEM_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.semGIVE_BLOCK_TIME">
<span class="target" id="semphr_8h_1a124bb5bd7805baa06fbd3239840d6803"></span><code class="descname">semGIVE_BLOCK_TIME</code><a class="headerlink" href="freertos.html#c.semGIVE_BLOCK_TIME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateBinary">
<span class="target" id="semphr_8h_1acba963695e4f159d9bfa2394cae5badc"></span><code class="descname">xSemaphoreCreateBinary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateBinary" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ ორობით სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი სემაფორის მითითება.</p>
<p>მრავალ შემთხვევაში, ორობითი სემაფორის ნაცვლად, დავალებაზე პირდაპირი შეტყობინების გამოყენება უფრო სწრაფი და მეხსიერების უფრო ეფექტურია! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/ RTOS -task-notifications.html</a></p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, ბინარული სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება სემაფორის სტრუქტურა. თუ ბინარული სემაფორა იქმნება xSemaphoreCreateBinary() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateBinary() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ ბინარული სემაფორი იქმნება xSemaphoreCreateBinaryStatic()-ის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება. შესაბამისად, xSemaphoreCreateBinaryStatic() საშუალებას იძლევა ბინარული სემაფორის შექმნა დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ძველი vSemaphoreCreateBinary() მაკრო ახლა მოძველებულია ამ xSemaphoreCreateBinary() ფუნქციის სასარგებლოდ. გაითვალისწინეთ, რომ vSemaphoreCreateBinary() მაკროს გამოყენებით შექმნილი ორობითი სემაფორები იქმნება ისეთ მდგომარეობაში, რომ სემაფორის „აღებაზე“ პირველი გამოძახება გაივლის, მაშინ როცა xSemaphoreCreateBinary() მაკროს გამოყენებით შექმნილი ორობითი სემაფორები იქმნება ისეთ მდგომარეობაში, რომ სემაფორის „აღებამდე“ ჯერ უნდა იყოს „მოცემული“.</p>
<p>ფუნქცია, რომელიც ქმნის სემაფორას არსებული რიგის მექანიზმის გამოყენებით. რიგის სიგრძეა 1, რადგან ეს არის ორობითი სემაფორი. მონაცემთა ზომაა 0, რადგან რეალურად არაფერია შენახული - მნიშვნელოვანია მხოლოდ ის, რიგი ცარიელია თუ სავსე (ორობითი სემაფორი ხელმისაწვდომია თუ არა).</p>
<p>ამ ტიპის სემაფორის გამოყენება შესაძლებელია დავალებებს შორის ან შეფერხებასა და დავალებას შორის სუფთა სინქრონიზაციისთვის. სემაფორის დაბრუნება საჭირო არ არის მიღების შემდეგ, ამიტომ ერთი დავალება/შეფერხება შეიძლება განუწყვეტლივ „მიეცეს“ სემაფორას, ხოლო მეორე განუწყვეტლივ „მიიღოს“ სემაფორა. ამ მიზეზით, ამ ტიპის სემაფორა არ იყენებს პრიორიტეტულ მემკვიდრეობის მექანიზმს. ალტერნატივისთვის, რომელიც იყენებს პრიორიტეტულ მემკვიდრეობას, იხილეთ xSemaphoreCreateMutex().</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">vSemaphoreCreateBinary</span> <span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Handle to the created semaphore.</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateBinaryStatic">
<span class="target" id="semphr_8h_1a1a8fb8e7922ce5ced3b36f0c963393f1"></span><code class="descname">xSemaphoreCreateBinaryStatic</code><span class="sig-paren">(</span>pxStaticSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateBinaryStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ ორობით სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი სემაფორის მითითება.</p>
<p>შენიშვნა: გამოყენების ბევრ სცენარში უფრო სწრაფი და მეხსიერების ეფექტური გამოყენებაა ორობითი სემაფორის ნაცვლად დავალებისკენ პირდაპირი შეტყობინების გამოყენება! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/ RTOS -task-notifications.html</a></p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, ბინარული სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება სემაფორის სტრუქტურა. თუ ბინარული სემაფორა იქმნება xSemaphoreCreateBinary() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateBinary() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ ბინარული სემაფორი იქმნება xSemaphoreCreateBinaryStatic()-ის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება. შესაბამისად, xSemaphoreCreateBinaryStatic() საშუალებას იძლევა ბინარული სემაფორის შექმნა დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ამ ტიპის სემაფორის გამოყენება შესაძლებელია დავალებებს შორის ან შეფერხებასა და დავალებას შორის სუფთა სინქრონიზაციისთვის. სემაფორის დაბრუნება საჭირო არ არის მიღების შემდეგ, ამიტომ ერთი დავალება/შეფერხება შეიძლება განუწყვეტლივ „მიეცეს“ სემაფორას, ხოლო მეორე განუწყვეტლივ „მიიღოს“ სემაფორა. ამ მიზეზით, ამ ტიპის სემაფორა არ იყენებს პრიორიტეტულ მემკვიდრეობის მექანიზმს. ალტერნატივისთვის, რომელიც იყენებს პრიორიტეტულ მემკვიდრეობას, იხილეთ xSemaphoreCreateMutex().</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span><span class="s1">'s data structures will be placed in the xSemaphoreBuffer</span>
   <span class="o">//</span> <span class="n">variable</span><span class="p">,</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">function</span><span class="o">.</span>  <span class="n">The</span>
   <span class="o">//</span> <span class="n">function</span><span class="s1">'s parameter is not NULL, so the function will not attempt any</span>
   <span class="o">//</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span><span class="p">,</span> <span class="ow">and</span> <span class="n">therefore</span> <span class="n">the</span> <span class="n">function</span> <span class="n">will</span> <span class="ow">not</span> <span class="k">return</span>
   <span class="o">//</span> <span class="k">return</span> <span class="n">NULL</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateBinary</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">Rest</span> <span class="n">of</span> <span class="n">task</span> <span class="n">code</span> <span class="n">goes</span> <span class="n">here</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the semaphore is created then a handle to the created semaphore is returned. If pxSemaphoreBuffer is NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxStaticSemaphore</span></code>უნდა მიუთითებდეს StaticSemaphore_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება სემაფორის მონაცემთა სტრუქტურის შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreTake">
<span class="target" id="semphr_8h_1af116e436d2a5ae5bd72dbade2b5ea930"></span><code class="descname">xSemaphoreTake</code><span class="sig-paren">(</span>xSemaphore, xBlockTime<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreTake" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> სემაფორის მისაღებად. სემაფორი წინასწარ უნდა იყოს შექმნილი vSemaphoreCreateBinary(), xSemaphoreCreateMutex() ან xSemaphoreCreateCounting() გამოძახებით.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">semaphore</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">vSemaphoreCreateBinary</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">semaphore</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTake</span><span class="p">(</span> <span class="n">xSemaphore</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>

           <span class="o">//</span> <span class="n">We</span> <span class="n">have</span> <span class="n">finished</span> <span class="n">accessing</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>  <span class="n">Release</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">semaphore</span><span class="o">.</span>
           <span class="n">xSemaphoreGive</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="p">);</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>სემაფორის სახელური, რომელიც აღებულია - მიიღება სემაფორის შექმნისას.</li>
<li><code class="docutils literal notranslate"><span class="pre">xBlockTime</span></code>: სემაფორის ხელმისაწვდომობის მოლოდინის დრო ტიკებში. მაკრო portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას ამის რეალურ დროში გადასაყვანად. სემაფორის გამოკითხვისთვის შეიძლება გამოყენებულ იქნას ნულოვანი ბლოკის დრო. portMAX_DELAY ბლოკის დრო შეიძლება გამოყენებულ იქნას განუსაზღვრელი ვადით ბლოკირებისთვის (იმ პირობით, რომ INCLUDE_vTaskSuspend დაყენებულია 1-ზე Free RTOS Config.h ფაილში).</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreTakeRecursive">
<span class="target" id="semphr_8h_1ad395f4bba51eea6af3397d72bc079e4d"></span><code class="descname">xSemaphoreTakeRecursive</code><span class="sig-paren">(</span>xMutex, xBlockTime<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreTakeRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> რეკურსიულად mutex ტიპის სემაფორის მისაღებად ან „ასაღებად“. mutex ადრე უნდა შექმნილიყო xSemaphoreCreateRecursiveMutex();-ის გამოძახების გამოყენებით.</p>
<p>იმისათვის, რომ ეს მაკრო ხელმისაწვდომი იყოს, Free RTOS Config.h ფაილში configUSE_RECURSIVE_MUTEXES უნდა იყოს დაყენებული 1-ზე.</p>
<p>ეს მაკრო არ უნდა იქნას გამოყენებული xSemaphoreCreateMutex()-ის გამოყენებით შექმნილ მუტექსებზე.</p>
<p>რეკურსიულად გამოყენებული მუტექსი შეიძლება მფლობელმა განმეორებით „აიღოს“. მუტექსი ხელახლა ხელმისაწვდომი არ გახდება მანამ, სანამ მფლობელი არ გამოიძახებს xSemaphoreGiveRecursive()-ს თითოეული წარმატებული „აღებ“ მოთხოვნისთვის. მაგალითად, თუ დავალება წარმატებით „აიღებს“ ერთსა და იმავე მუტექსს 5-ჯერ, მაშინ მუტექსი არ იქნება ხელმისაწვდომი სხვა დავალებებისთვის მანამ, სანამ ისიც ზუსტად ხუთჯერ არ „უბრუნებს“ მუტექსს.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xMutex</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">xMutex</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xMutex</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xSemaphore</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>
           <span class="o">//</span> <span class="n">For</span> <span class="n">some</span> <span class="n">reason</span> <span class="n">due</span> <span class="n">to</span> <span class="n">the</span> <span class="n">nature</span> <span class="n">of</span> <span class="n">the</span> <span class="n">code</span> <span class="n">further</span> <span class="n">calls</span> <span class="n">to</span>
           <span class="o">//</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">()</span> <span class="n">are</span> <span class="n">made</span> <span class="n">on</span> <span class="n">the</span> <span class="n">same</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">In</span> <span class="n">real</span>
           <span class="o">//</span> <span class="n">code</span> <span class="n">these</span> <span class="n">would</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">just</span> <span class="n">sequential</span> <span class="n">calls</span> <span class="k">as</span> <span class="n">this</span> <span class="n">would</span> <span class="n">make</span>
           <span class="o">//</span> <span class="n">no</span> <span class="n">sense</span><span class="o">.</span>  <span class="n">Instead</span> <span class="n">the</span> <span class="n">calls</span> <span class="n">are</span> <span class="n">likely</span> <span class="n">to</span> <span class="n">be</span> <span class="n">buried</span> <span class="n">inside</span>
           <span class="o">//</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">The</span> <span class="n">mutex</span> <span class="n">has</span> <span class="n">now</span> <span class="n">been</span> <span class="s1">'taken'</span> <span class="n">three</span> <span class="n">times</span><span class="p">,</span> <span class="n">so</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">be</span>
           <span class="o">//</span> <span class="n">available</span> <span class="n">to</span> <span class="n">another</span> <span class="n">task</span> <span class="n">until</span> <span class="n">it</span> <span class="n">has</span> <span class="n">also</span> <span class="n">been</span> <span class="n">given</span> <span class="n">back</span>
           <span class="o">//</span> <span class="n">three</span> <span class="n">times</span><span class="o">.</span>  <span class="n">Again</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">unlikely</span> <span class="n">that</span> <span class="n">real</span> <span class="n">code</span> <span class="n">would</span> <span class="n">have</span>
           <span class="o">//</span> <span class="n">these</span> <span class="n">calls</span> <span class="n">sequentially</span><span class="p">,</span> <span class="n">but</span> <span class="n">instead</span> <span class="n">buried</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span>
           <span class="o">//</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">just</span> <span class="k">for</span> <span class="n">illustrative</span> <span class="n">purposes</span><span class="o">.</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">can</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">by</span> <span class="n">other</span> <span class="n">tasks</span><span class="o">.</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was obtained. pdFALSE if xBlockTime expired without the semaphore becoming available.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xMutex</span></code>: მიღებული მუტექსის სახელური. ეს არის xSemaphoreCreateRecursiveMutex();-ის მიერ დაბრუნებული სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">xBlockTime</span></code>: სემაფორის ხელმისაწვდომობის მოლოდინის დრო ტიკებში. მაკრო portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას ამის რეალურ დროში გადასაყვანად. სემაფორის გამოკითხვისთვის შეიძლება გამოყენებულ იქნას ნულოვანი ბლოკის დრო. თუ დავალება უკვე ფლობს სემაფორას, მაშინ xSemaphoreTakeRecursive() დაუყოვნებლივ დააბრუნებს xBlockTime-ის მნიშვნელობის მიუხედავად.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreGive">
<span class="target" id="semphr_8h_1aae55761cabfa9bf85c8f4430f78c0953"></span><code class="descname">xSemaphoreGive</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreGive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> სემაფორის გასაშვებად. სემაფორი წინასწარ უნდა იყოს შექმნილი vSemaphoreCreateBinary(), xSemaphoreCreateMutex() ან xSemaphoreCreateCounting() გამოძახებით და მიღებული sSemaphoreTake()-ის გამოყენებით.</p>
<p>ეს მაკრო არ უნდა იქნას გამოყენებული ISR-დან. იხილეთ xSemaphoreGiveFromISR () ალტერნატივისთვის, რომლის გამოყენებაც შესაძლებელია ISR-დან.</p>
<p>ეს მაკრო ასევე არ უნდა იქნას გამოყენებული xSemaphoreCreateRecursiveMutex()-ის გამოყენებით შექმნილ სემაფორებზე.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>SemaphoreHandle_t xSemaphore = NULL;

void vATask( void * pvParameters )
{
   // Create the semaphore to guard a shared resource.
   vSemaphoreCreateBinary( xSemaphore );

   if( xSemaphore != NULL )
   {
       if( xSemaphoreGive( xSemaphore ) != pdTRUE )
       {
           // We would expect this call to fail because we cannot give
           // a semaphore without first "taking" it!
       }

       // Obtain the semaphore - don't block if the semaphore is not
       // immediately available.
       if( xSemaphoreTake( xSemaphore, ( TickType_t ) 0 ) )
       {
           // We now have the semaphore and can access the shared resource.

           // ...

           // We have finished accessing the shared resource so can free the
           // semaphore.
           if( xSemaphoreGive( xSemaphore ) != pdTRUE )
           {
               // We would not expect this call to fail because we must have
               // obtained the semaphore to get here.
           }
       }
   }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was released. pdFALSE if an error occurred. Semaphores are implemented using queues. An error can occur if there is no space on the queue to post a message - indicating that the semaphore was not first obtained correctly.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>სემაფორის გათავისუფლების სახელური. ეს არის სახელური, რომელიც დაბრუნდა სემაფორის შექმნისას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreGiveRecursive">
<span class="target" id="semphr_8h_1a398d66b17856c22dd49d39aaac42f105"></span><code class="descname">xSemaphoreGiveRecursive</code><span class="sig-paren">(</span>xMutex<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreGiveRecursive" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> რეკურსიულად mutex ტიპის სემაფორის გასათავისუფლებლად ან „მისაცემად“. mutex ადრე უნდა შექმნილიყო xSemaphoreCreateRecursiveMutex();-ის გამოძახების გამოყენებით.</p>
<p>იმისათვის, რომ ეს მაკრო ხელმისაწვდომი იყოს, Free RTOS Config.h ფაილში configUSE_RECURSIVE_MUTEXES უნდა იყოს დაყენებული 1-ზე.</p>
<p>ეს მაკრო არ უნდა იქნას გამოყენებული xSemaphoreCreateMutex()-ის გამოყენებით შექმნილ მუტექსებზე.</p>
<p>რეკურსიულად გამოყენებული მუტექსი შეიძლება მფლობელმა განმეორებით „აიღოს“. მუტექსი ხელახლა ხელმისაწვდომი არ გახდება მანამ, სანამ მფლობელი არ გამოიძახებს xSemaphoreGiveRecursive()-ს თითოეული წარმატებული „აღებ“ მოთხოვნისთვის. მაგალითად, თუ დავალება წარმატებით „აიღებს“ ერთსა და იმავე მუტექსს 5-ჯერ, მაშინ მუტექსი არ იქნება ხელმისაწვდომი სხვა დავალებებისთვის მანამ, სანამ ისიც ზუსტად ხუთჯერ არ „უბრუნებს“ მუტექსს.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xMutex</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">creates</span> <span class="n">a</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">to</span> <span class="n">guard</span> <span class="n">a</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>
   <span class="n">xMutex</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">task</span> <span class="n">that</span> <span class="n">uses</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnotherTask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="o">...</span> <span class="n">Do</span> <span class="n">other</span> <span class="n">things</span><span class="o">.</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xMutex</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">See</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">available</span>
       <span class="o">//</span> <span class="n">wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">it</span> <span class="n">becomes</span> <span class="n">free</span><span class="o">.</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdTRUE</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">were</span> <span class="n">able</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">now</span> <span class="n">access</span> <span class="n">the</span>
           <span class="o">//</span> <span class="n">shared</span> <span class="n">resource</span><span class="o">.</span>

           <span class="o">//</span> <span class="o">...</span>
           <span class="o">//</span> <span class="n">For</span> <span class="n">some</span> <span class="n">reason</span> <span class="n">due</span> <span class="n">to</span> <span class="n">the</span> <span class="n">nature</span> <span class="n">of</span> <span class="n">the</span> <span class="n">code</span> <span class="n">further</span> <span class="n">calls</span> <span class="n">to</span>
           <span class="o">//</span> <span class="n">xSemaphoreTakeRecursive</span><span class="p">()</span> <span class="n">are</span> <span class="n">made</span> <span class="n">on</span> <span class="n">the</span> <span class="n">same</span> <span class="n">mutex</span><span class="o">.</span>  <span class="n">In</span> <span class="n">real</span>
           <span class="o">//</span> <span class="n">code</span> <span class="n">these</span> <span class="n">would</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">just</span> <span class="n">sequential</span> <span class="n">calls</span> <span class="k">as</span> <span class="n">this</span> <span class="n">would</span> <span class="n">make</span>
           <span class="o">//</span> <span class="n">no</span> <span class="n">sense</span><span class="o">.</span>  <span class="n">Instead</span> <span class="n">the</span> <span class="n">calls</span> <span class="n">are</span> <span class="n">likely</span> <span class="n">to</span> <span class="n">be</span> <span class="n">buried</span> <span class="n">inside</span>
           <span class="o">//</span> <span class="n">a</span> <span class="n">more</span> <span class="nb">complex</span> <span class="n">call</span> <span class="n">structure</span><span class="o">.</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>
           <span class="n">xSemaphoreTakeRecursive</span><span class="p">(</span> <span class="n">xMutex</span><span class="p">,</span> <span class="p">(</span> <span class="n">TickType_t</span> <span class="p">)</span> <span class="mi">10</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">The</span> <span class="n">mutex</span> <span class="n">has</span> <span class="n">now</span> <span class="n">been</span> <span class="s1">'taken'</span> <span class="n">three</span> <span class="n">times</span><span class="p">,</span> <span class="n">so</span> <span class="n">will</span> <span class="ow">not</span> <span class="n">be</span>
           <span class="o">//</span> <span class="n">available</span> <span class="n">to</span> <span class="n">another</span> <span class="n">task</span> <span class="n">until</span> <span class="n">it</span> <span class="n">has</span> <span class="n">also</span> <span class="n">been</span> <span class="n">given</span> <span class="n">back</span>
           <span class="o">//</span> <span class="n">three</span> <span class="n">times</span><span class="o">.</span>  <span class="n">Again</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">unlikely</span> <span class="n">that</span> <span class="n">real</span> <span class="n">code</span> <span class="n">would</span> <span class="n">have</span>
           <span class="o">//</span> <span class="n">these</span> <span class="n">calls</span> <span class="n">sequentially</span><span class="p">,</span> <span class="n">it</span> <span class="n">would</span> <span class="n">be</span> <span class="n">more</span> <span class="n">likely</span> <span class="n">that</span> <span class="n">the</span> <span class="n">calls</span>
           <span class="o">//</span> <span class="n">to</span> <span class="n">xSemaphoreGiveRecursive</span><span class="p">()</span> <span class="n">would</span> <span class="n">be</span> <span class="n">called</span> <span class="k">as</span> <span class="n">a</span> <span class="n">call</span> <span class="n">stack</span>
           <span class="o">//</span> <span class="n">unwound</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">just</span> <span class="k">for</span> <span class="n">demonstrative</span> <span class="n">purposes</span><span class="o">.</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>
           <span class="n">xSemaphoreGiveRecursive</span><span class="p">(</span> <span class="n">xMutex</span> <span class="p">);</span>

           <span class="o">//</span> <span class="n">Now</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">can</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">by</span> <span class="n">other</span> <span class="n">tasks</span><span class="o">.</span>
       <span class="p">}</span>
       <span class="k">else</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">We</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">obtain</span> <span class="n">the</span> <span class="n">mutex</span> <span class="ow">and</span> <span class="n">can</span> <span class="n">therefore</span> <span class="ow">not</span> <span class="n">access</span>
           <span class="o">//</span> <span class="n">the</span> <span class="n">shared</span> <span class="n">resource</span> <span class="n">safely</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was given.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xMutex</span></code>: გამოშვებული ან „მოცემული“ მუტექსის სახელური. ეს არის xSemaphoreCreateMutex();-ის მიერ დაბრუნებული სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreGiveFromISR">
<span class="target" id="semphr_8h_1a68aa43df8b2a0dbe17d05fad74670ef0"></span><code class="descname">xSemaphoreGiveFromISR</code><span class="sig-paren">(</span>xSemaphore, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreGiveFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> სემაფორის გასაშვებად. სემაფორი წინასწარ უნდა იყოს შექმნილი vSemaphoreCreateBinary() ან xSemaphoreCreateCounting() გამოძახებით.</p>
<p>Mutex ტიპის სემაფორები (რომლებიც შექმნილია xSemaphoreCreateMutex()-ის გამოძახების გამოყენებით) არ უნდა იქნას გამოყენებული ამ მაკროსთან ერთად.</p>
<p>ეს მაკრო შეიძლება გამოყენებულ იქნას ISR-დან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\#define LONG_TIME 0xffff
\#define TICKS_TO_WAIT 10
SemaphoreHandle_t xSemaphore = NULL;

// Repetitive task.
void vATask( void * pvParameters )
{
   for( ;; )
   {
       // We want this task to run every 10 ticks of a timer.  The semaphore
       // was created before this task was started.

       // Block waiting for the semaphore to become available.
       if( xSemaphoreTake( xSemaphore, LONG_TIME ) == pdTRUE )
       {
           // It is time to execute.

           // ...

           // We have finished our task.  Return to the top of the loop where
           // we will block on the semaphore until it is time to execute
           // again.  Note when using the semaphore for synchronisation with an
           // ISR in this manner there is no need to 'give' the semaphore back.
       }
   }
}

// Timer ISR
void vTimerISR( void * pvParameters )
{
static uint8_t ucLocalTickCount = 0;
static BaseType_t xHigherPriorityTaskWoken;

   // A timer tick has occurred.

   // ... Do other time functions.

   // Is it time for vATask () to run?
   xHigherPriorityTaskWoken = pdFALSE;
   ucLocalTickCount++;
   if( ucLocalTickCount &gt;= TICKS_TO_WAIT )
   {
       // Unblock the task by releasing the semaphore.
       xSemaphoreGiveFromISR( xSemaphore, &amp;xHigherPriorityTaskWoken );

       // Reset the count so we release the semaphore again in 10 ticks time.
       ucLocalTickCount = 0;
   }

   if( xHigherPriorityTaskWoken != pdFALSE )
   {
       // We can force a context switch here.  Context switching from an
       // ISR uses port specific syntax.  Check the demo task for your port
       // to find the syntax required.
   }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was successfully given, otherwise errQUEUE_FULL.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>სემაფორის გათავისუფლების სახელური. ეს არის სახელური, რომელიც დაბრუნდა სემაფორის შექმნისას.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>xSemaphoreGiveFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ სემაფორის მინიჭებამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებულ დავალებაზე მაღალი პრიორიტეტი აქვს. თუ xSemaphoreGiveFromISR() ფუნქცია ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreTakeFromISR">
<span class="target" id="semphr_8h_1a076419b58e072655686939016e7ca3c5"></span><code class="descname">xSemaphoreTakeFromISR</code><span class="sig-paren">(</span>xSemaphore, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreTakeFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> ISR-დან სემაფორის აღება. სემაფორი წინასწარ უნდა იყოს შექმნილი vSemaphoreCreateBinary() ან xSemaphoreCreateCounting() გამოძახებით.</p>
<p>Mutex ტიპის სემაფორები (რომლებიც შექმნილია xSemaphoreCreateMutex()-ის გამოძახების გამოყენებით) არ უნდა იქნას გამოყენებული ამ მაკროსთან ერთად.</p>
<p>ეს მაკრო შეიძლება გამოყენებულ იქნას ISR-დან, თუმცა სემაფორის ISR-დან აღება გავრცელებული ოპერაცია არ არის. ის, სავარაუდოდ, მხოლოდ მაშინ იქნება სასარგებლო, როდესაც მთვლელი სემაფორის აღებას მაშინ შეძლებთ, როდესაც შეფერხება რესურსების პულიდან ობიექტს იღებს (როდესაც სემაფორის რაოდენობა მიუთითებს ხელმისაწვდომი რესურსების რაოდენობაზე).</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdTRUE if the semaphore was successfully taken, otherwise pdFALSE </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>სემაფორის სახელური, რომელიც აღებულია. ეს არის სახელური, რომელიც დაბრუნდა სემაფორის შექმნისას.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>xSemaphoreTakeFromISR() ფუნქცია *pxHigherPriorityTaskWoken-ს pdTRUE-ზე დააყენებს, თუ სემაფორის აღებამ დავალების განბლოკვა გამოიწვია და განბლოკილ დავალებას ამჟამად გაშვებულ დავალებაზე მაღალი პრიორიტეტი აქვს. თუ xSemaphoreTakeFromISR() ფუნქცია ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტიდან გასვლამდე კონტექსტის შეცვლა უნდა იყოს მოთხოვნილი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateMutex">
<span class="target" id="semphr_8h_1aa6a00aa9b91a9e5b3ebe4ae1c3f115c6"></span><code class="descname">xSemaphoreCreateMutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateMutex" title="Permalink to this definition">¶</a></dt>
<dd><p><em>მაკრო</em> რომელიც ახორციელებს mutex სემაფორას არსებული რიგის მექანიზმის გამოყენებით.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, mutex სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება mutex სტრუქტურა. თუ mutex იქმნება xSemaphoreCreateMutex() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateMutex() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ მუტექსი იქმნება xSemaphoreCreateMutexStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება. შესაბამისად, xSemaphoreCreateMutexStatic() საშუალებას იძლევა მუტექსი შეიქმნას დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ამ ფუნქციის გამოყენებით შექმნილ მუტექსებზე წვდომა შესაძლებელია xSemaphoreTake() და xSemaphoreGive() მაკროების გამოყენებით. xSemaphoreTakeRecursive() და xSemaphoreGiveRecursive() მაკროების გამოყენება დაუშვებელია.</p>
<p>ამ ტიპის სემაფორი იყენებს პრიორიტეტის მემკვიდრეობის მექანიზმს, ამიტომ სემაფორის „მიღების“ დავალება ყოველთვის უნდა „უბრუნებდეს“ მას, როგორც კი სემაფორი აღარ იქნება საჭირო.</p>
<p>Mutex ტიპის სემაფორების გამოყენება შეწყვეტის სერვისის რუტინებიდან არ შეიძლება.</p>
<p>იხილეთ vSemaphoreCreateBinary() ალტერნატიული იმპლემენტაციისთვის, რომელიც შეიძლება გამოყენებულ იქნას სუფთა სინქრონიზაციისთვის (სადაც ერთი დავალება ან შეწყვეტა ყოველთვის „აძლევს“ სემაფორას, ხოლო მეორე ყოველთვის „იღებს“ მას) და შეწყვეტის სერვისის რუტინების ფარგლებში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the mutex was successfully created then a handle to the created semaphore is returned. If there was not enough heap to allocate the mutex data structures then NULL is returned.</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateMutexStatic">
<span class="target" id="semphr_8h_1a2f6fea163b7069a27a4a3fd8adfbfadd"></span><code class="descname">xSemaphoreCreateMutexStatic</code><span class="sig-paren">(</span>pxMutexBuffer<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateMutexStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ mutex ტიპის სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი mutex-ის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, mutex სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება mutex სტრუქტურა. თუ mutex იქმნება xSemaphoreCreateMutex() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateMutex() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ მუტექსი იქმნება xSemaphoreCreateMutexStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება. შესაბამისად, xSemaphoreCreateMutexStatic() საშუალებას იძლევა მუტექსი შეიქმნას დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ამ ფუნქციის გამოყენებით შექმნილ მუტექსებზე წვდომა შესაძლებელია xSemaphoreTake() და xSemaphoreGive() მაკროების გამოყენებით. xSemaphoreTakeRecursive() და xSemaphoreGiveRecursive() მაკროების გამოყენება დაუშვებელია.</p>
<p>ამ ტიპის სემაფორი იყენებს პრიორიტეტის მემკვიდრეობის მექანიზმს, ამიტომ სემაფორის „მიღების“ დავალება ყოველთვის უნდა „უბრუნებდეს“ მას, როგორც კი სემაფორი აღარ იქნება საჭირო.</p>
<p>Mutex ტიპის სემაფორების გამოყენება შეწყვეტის სერვისის რუტინებიდან არ შეიძლება.</p>
<p>იხილეთ xSemaphoreCreateBinary() ალტერნატიული იმპლემენტაციისთვის, რომელიც შეიძლება გამოყენებულ იქნას სუფთა სინქრონიზაციისთვის (სადაც ერთი დავალება ან შეწყვეტა ყოველთვის „აძლევს“ სემაფორას, ხოლო მეორე ყოველთვის „იღებს“ სემაფორას) და შეწყვეტის სერვისის რუტინების ფარგლებში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">A</span> <span class="n">mutex</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">it</span> <span class="n">has</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">xMutexBuffer</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">into</span> <span class="n">xSemaphoreCreateMutexStatic</span><span class="p">()</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">attempted</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateMutexStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xMutexBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">As</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">performed</span><span class="p">,</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span>
   <span class="o">//</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">it</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the mutex was successfully created then a handle to the created mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxMutexBuffer</span></code>უნდა მიუთითებდეს StaticSemaphore_t ტიპის ცვლადზე, რომელიც გამოყენებული იქნება mutex-ის მონაცემთა სტრუქტურის შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად განაწილების საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateRecursiveMutex">
<span class="target" id="semphr_8h_1a1bbc843be5a41ea83d2693b2189fc0f8"></span><code class="descname">xSemaphoreCreateRecursiveMutex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateRecursiveMutex" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ რეკურსიული mutex ტიპის სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი რეკურსიული mutex-ის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, რეკურსიული მუტექსები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება მუტექსის სტრუქტურა. თუ რეკურსიული მუტექსი იქმნება xSemaphoreCreateRecursiveMutex() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateRecursiveMutex() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ რეკურსიული მუტექსი იქმნება xSemaphoreCreateRecursiveMutexStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც მუტექსი გამოიყენებს. შესაბამისად, xSemaphoreCreateRecursiveMutexStatic() საშუალებას იძლევა რეკურსიული მუტექსი შეიქმნას დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ამ მაკროს გამოყენებით შექმნილ მუტექსებზე წვდომა შესაძლებელია xSemaphoreTakeRecursive() და xSemaphoreGiveRecursive() მაკროების გამოყენებით. xSemaphoreTake() და xSemaphoreGive() მაკროების გამოყენება დაუშვებელია.</p>
<p>რეკურსიულად გამოყენებული მუტექსი შეიძლება მფლობელმა განმეორებით „აიღოს“. მუტექსი ხელახლა ხელმისაწვდომი არ გახდება მანამ, სანამ მფლობელი არ გამოიძახებს xSemaphoreGiveRecursive()-ს თითოეული წარმატებული „აღებ“ მოთხოვნისთვის. მაგალითად, თუ დავალება წარმატებით „აიღებს“ ერთსა და იმავე მუტექსს 5-ჯერ, მაშინ მუტექსი არ იქნება ხელმისაწვდომი სხვა დავალებებისთვის მანამ, სანამ ისიც ზუსტად ხუთჯერ არ „უბრუნებს“ მუტექსს.</p>
<p>ამ ტიპის სემაფორი იყენებს პრიორიტეტის მემკვიდრეობის მექანიზმს, ამიტომ სემაფორის „მიღების“ დავალება ყოველთვის უნდა „უბრუნებდეს“ მას, როგორც კი სემაფორი აღარ იქნება საჭირო.</p>
<p>Mutex ტიპის სემაფორების გამოყენება შეწყვეტის სერვისის რუტინებიდან არ შეიძლება.</p>
<p>იხილეთ vSemaphoreCreateBinary() ალტერნატიული იმპლემენტაციისთვის, რომელიც შეიძლება გამოყენებულ იქნას სუფთა სინქრონიზაციისთვის (სადაც ერთი დავალება ან შეწყვეტა ყოველთვის „აძლევს“ სემაფორას, ხოლო მეორე ყოველთვის „იღებს“ მას) და შეწყვეტის სერვისის რუტინების ფარგლებში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateMutex</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">macro</span> <span class="n">so</span> <span class="k">pass</span> <span class="n">the</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">directly</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutex</span><span class="p">();</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>xSemaphore Handle to the created mutex semaphore. Should be of type SemaphoreHandle_t.</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateRecursiveMutexStatic">
<span class="target" id="semphr_8h_1a6fda8db26863762a083770f060d1285b"></span><code class="descname">xSemaphoreCreateRecursiveMutexStatic</code><span class="sig-paren">(</span>pxStaticSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateRecursiveMutexStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ რეკურსიული mutex ტიპის სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი რეკურსიული mutex-ის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, რეკურსიული მუტექსები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება მუტექსის სტრუქტურა. თუ რეკურსიული მუტექსი იქმნება xSemaphoreCreateRecursiveMutex() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateRecursiveMutex() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ რეკურსიული მუტექსი იქმნება xSemaphoreCreateRecursiveMutexStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც მუტექსი გამოიყენებს. შესაბამისად, xSemaphoreCreateRecursiveMutexStatic() საშუალებას იძლევა რეკურსიული მუტექსი შეიქმნას დინამიური მეხსიერების განაწილების გამოყენების გარეშე.</p>
<p>ამ მაკროს გამოყენებით შექმნილ მუტექსებზე წვდომა შესაძლებელია xSemaphoreTakeRecursive() და xSemaphoreGiveRecursive() მაკროების გამოყენებით. xSemaphoreTake() და xSemaphoreGive() მაკროების გამოყენება დაუშვებელია.</p>
<p>რეკურსიულად გამოყენებული მუტექსი შეიძლება მფლობელმა განმეორებით „აიღოს“. მუტექსი ხელახლა ხელმისაწვდომი არ გახდება მანამ, სანამ მფლობელი არ გამოიძახებს xSemaphoreGiveRecursive()-ს თითოეული წარმატებული „აღებ“ მოთხოვნისთვის. მაგალითად, თუ დავალება წარმატებით „აიღებს“ ერთსა და იმავე მუტექსს 5-ჯერ, მაშინ მუტექსი არ იქნება ხელმისაწვდომი სხვა დავალებებისთვის მანამ, სანამ ისიც ზუსტად ხუთჯერ არ „უბრუნებს“ მუტექსს.</p>
<p>ამ ტიპის სემაფორი იყენებს პრიორიტეტის მემკვიდრეობის მექანიზმს, ამიტომ სემაფორის „მიღების“ დავალება ყოველთვის უნდა „უბრუნებდეს“ მას, როგორც კი სემაფორი აღარ იქნება საჭირო.</p>
<p>Mutex ტიპის სემაფორების გამოყენება შეწყვეტის სერვისის რუტინებიდან არ შეიძლება.</p>
<p>იხილეთ xSemaphoreCreateBinary() ალტერნატიული იმპლემენტაციისთვის, რომელიც შეიძლება გამოყენებულ იქნას სუფთა სინქრონიზაციისთვის (სადაც ერთი დავალება ან შეწყვეტა ყოველთვის „აძლევს“ სემაფორას, ხოლო მეორე ყოველთვის „იღებს“ სემაფორას) და შეწყვეტის სერვისის რუტინების ფარგლებში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xMutexBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="o">//</span> <span class="n">A</span> <span class="n">recursive</span> <span class="n">semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">created</span><span class="o">.</span>  <span class="n">Here</span> <span class="n">a</span>
   <span class="o">//</span> <span class="n">recursive</span> <span class="n">mutex</span> <span class="ow">is</span> <span class="n">created</span> <span class="n">using</span> <span class="n">xSemaphoreCreateRecursiveMutexStatic</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="n">address</span> <span class="n">of</span> <span class="n">xMutexBuffer</span> <span class="ow">is</span> <span class="n">passed</span> <span class="n">into</span> <span class="n">the</span> <span class="n">function</span><span class="p">,</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">hold</span>
   <span class="o">//</span> <span class="n">the</span> <span class="n">mutexes</span> <span class="n">data</span> <span class="n">structures</span> <span class="o">-</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">will</span> <span class="n">be</span>
   <span class="o">//</span> <span class="n">attempted</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateRecursiveMutexStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xMutexBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">As</span> <span class="n">no</span> <span class="n">dynamic</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">performed</span><span class="p">,</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span>
   <span class="o">//</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">it</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the recursive mutex was successfully created then a handle to the created recursive mutex is returned. If pxMutexBuffer was NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxStaticSemaphore</span></code>უნდა მიუთითებდეს StaticSemaphore_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება რეკურსიული მუტექსის მონაცემთა სტრუქტურის შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად განაწილების საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateCounting">
<span class="target" id="semphr_8h_1a7764616a918a46115403569a88148ad4"></span><code class="descname">xSemaphoreCreateCounting</code><span class="sig-paren">(</span>uxMaxCount, uxInitialCount<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateCounting" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ დათვლის სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი დათვლის სემაფორის მითითება.</p>
<p>მრავალ შემთხვევაში, დათვლის სემაფორის ნაცვლად, დავალებაზე პირდაპირი შეტყობინების გამოყენება უფრო სწრაფი და მეხსიერების ეფექტურია! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/ RTOS -task-notifications.html</a></p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, დათვლის სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება დათვლის სემაფორის სტრუქტურა. თუ დათვლის სემაფორა იქმნება xSemaphoreCreateCounting() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateCounting() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ დათვლის სემაფორა იქმნება xSemaphoreCreateCountingStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელს შეუძლია სურვილისამებრ უზრუნველყოს მეხსიერება, რომელსაც დათვლის სემაფორა გამოიყენებს. შესაბამისად, xSemaphoreCreateCountingStatic() საშუალებას იძლევა დათვლის სემაფორა შეიქმნას დინამიური მეხსიერების განაწილების გარეშე.</p>
<p>სემაფორების დათვლა, როგორც წესი, ორი რამისთვის გამოიყენება:</p>
<p>1) მოვლენების დათვლა.</p>
<p>ამ გამოყენების სცენარში, მოვლენების დამმუშავებელი „მისცემს“ სემაფორს ყოველ ჯერზე, როდესაც მოვლენა მოხდება (სემაფორის count მნიშვნელობის გაზრდით), ხოლო დამმუშავებლის დავალება „მიიღებს“ სემაფორს ყოველ ჯერზე, როდესაც ის დაამუშავებს მოვლენას (სემაფორის count მნიშვნელობის შემცირებით). შესაბამისად, count მნიშვნელობა არის სხვაობა მომხდარი და დამუშავებული მოვლენების რაოდენობას შორის. ამ შემთხვევაში სასურველია, რომ საწყისი count მნიშვნელობა ნულის ტოლი იყოს.</p>
<p>2) რესურსების მართვა.</p>
<p>ამ გამოყენების სცენარში, count მნიშვნელობა მიუთითებს ხელმისაწვდომი რესურსების რაოდენობაზე. რესურსის კონტროლის მისაღებად, დავალებამ ჯერ უნდა მიიღოს სემაფორი - სემაფორის count მნიშვნელობის შემცირებით. როდესაც count მნიშვნელობა ნულს მიაღწევს, თავისუფალი რესურსები აღარ რჩება. როდესაც დავალება რესურსით სრულდება, ის „უბრუნებს“ სემაფორს - სემაფორის count მნიშვნელობას ზრდის. ამ შემთხვევაში, სასურველია, რომ საწყისი count მნიშვნელობა ტოლი იყოს count მნიშვნელობის მაქსიმალურს, რაც მიუთითებს, რომ ყველა რესურსი თავისუფალია.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">()</span><span class="o">.</span>
   <span class="o">//</span> <span class="n">The</span> <span class="nb">max</span> <span class="n">value</span> <span class="n">to</span> <span class="n">which</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">count</span> <span class="n">should</span> <span class="n">be</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">initial</span> <span class="n">value</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">count</span> <span class="n">should</span> <span class="n">be</span> <span class="mf">0.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

   <span class="k">if</span><span class="p">(</span> <span class="n">xSemaphore</span> <span class="o">!=</span> <span class="n">NULL</span> <span class="p">)</span>
   <span class="p">{</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">was</span> <span class="n">created</span> <span class="n">successfully</span><span class="o">.</span>
       <span class="o">//</span> <span class="n">The</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">now</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>Handle to the created semaphore. Null if the semaphore could not be created.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxMaxCount</span></code>მაქსიმალური შესაძლო მნიშვნელობა. როდესაც სემაფორი ამ მნიშვნელობას მიაღწევს, მისი „მიცემა“ აღარ შეიძლება.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxInitialCount</span></code>სემაფორისთვის მინიჭებული რაოდენობის მნიშვნელობა მისი შექმნისას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreCreateCountingStatic">
<span class="target" id="semphr_8h_1a955bf5b3c1e256c5ce42c73d577c8438"></span><code class="descname">xSemaphoreCreateCountingStatic</code><span class="sig-paren">(</span>uxMaxCount, uxInitialCount, pxSemaphoreBuffer<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreCreateCountingStatic" title="Permalink to this definition">¶</a></dt>
<dd><p>ქმნის ახალ დათვლის სემაფორის ინსტანციას და აბრუნებს სახელურს, რომლითაც შესაძლებელია ახალი დათვლის სემაფორის მითითება.</p>
<p>მრავალ შემთხვევაში, დათვლის სემაფორის ნაცვლად, დავალებაზე პირდაპირი შეტყობინების გამოყენება უფრო სწრაფი და მეხსიერების ეფექტურია! <a class="reference external" href="http://www.freertos.org/RTOS-task-notifications.html">http://www.freertos.org/ RTOS -task-notifications.html</a></p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, დათვლის სემაფორები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება დათვლის სემაფორის სტრუქტურა. თუ დათვლის სემაფორა იქმნება xSemaphoreCreateCounting() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xSemaphoreCreateCounting() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ დათვლის სემაფორა იქმნება xSemaphoreCreateCountingStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება. შესაბამისად, xSemaphoreCreateCountingStatic() საშუალებას იძლევა დათვლის სემაფორა შეიქმნას დინამიური მეხსიერების განაწილების გარეშე.</p>
<p>სემაფორების დათვლა, როგორც წესი, ორი რამისთვის გამოიყენება:</p>
<p>1) მოვლენების დათვლა.</p>
<p>ამ გამოყენების სცენარში, მოვლენების დამმუშავებელი „მისცემს“ სემაფორს ყოველ ჯერზე, როდესაც მოვლენა მოხდება (სემაფორის count მნიშვნელობის გაზრდით), ხოლო დამმუშავებლის დავალება „მიიღებს“ სემაფორს ყოველ ჯერზე, როდესაც ის დაამუშავებს მოვლენას (სემაფორის count მნიშვნელობის შემცირებით). შესაბამისად, count მნიშვნელობა არის სხვაობა მომხდარი და დამუშავებული მოვლენების რაოდენობას შორის. ამ შემთხვევაში სასურველია, რომ საწყისი count მნიშვნელობა ნულის ტოლი იყოს.</p>
<p>2) რესურსების მართვა.</p>
<p>ამ გამოყენების სცენარში, count მნიშვნელობა მიუთითებს ხელმისაწვდომი რესურსების რაოდენობაზე. რესურსის კონტროლის მისაღებად, დავალებამ ჯერ უნდა მიიღოს სემაფორი - სემაფორის count მნიშვნელობის შემცირებით. როდესაც count მნიშვნელობა ნულს მიაღწევს, თავისუფალი რესურსები აღარ რჩება. როდესაც დავალება რესურსით სრულდება, ის „უბრუნებს“ სემაფორს - სემაფორის count მნიშვნელობას ზრდის. ამ შემთხვევაში, სასურველია, რომ საწყისი count მნიშვნელობა ტოლი იყოს count მნიშვნელობის მაქსიმალურს, რაც მიუთითებს, რომ ყველა რესურსი თავისუფალია.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span><span class="p">;</span>
<span class="n">StaticSemaphore_t</span> <span class="n">xSemaphoreBuffer</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vATask</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">SemaphoreHandle_t</span> <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Counting</span> <span class="n">semaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span> <span class="n">they</span> <span class="n">have</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">Create</span>
   <span class="o">//</span> <span class="n">a</span> <span class="n">counting</span> <span class="n">semaphore</span> <span class="n">using</span> <span class="n">xSemaphoreCreateCountingStatic</span><span class="p">()</span><span class="o">.</span>  <span class="n">The</span> <span class="nb">max</span>
   <span class="o">//</span> <span class="n">value</span> <span class="n">to</span> <span class="n">which</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">can</span> <span class="n">count</span> <span class="ow">is</span> <span class="mi">10</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">initial</span> <span class="n">value</span>
   <span class="o">//</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">count</span> <span class="n">will</span> <span class="n">be</span> <span class="mf">0.</span>  <span class="n">The</span> <span class="n">address</span> <span class="n">of</span> <span class="n">xSemaphoreBuffer</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="n">passed</span> <span class="ow">in</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">semaphore</span> <span class="n">structure</span><span class="p">,</span> <span class="n">so</span> <span class="n">no</span> <span class="n">dynamic</span>
   <span class="o">//</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">will</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
   <span class="n">xSemaphore</span> <span class="o">=</span> <span class="n">xSemaphoreCreateCounting</span><span class="p">(</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xSemaphoreBuffer</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">No</span> <span class="n">memory</span> <span class="n">allocation</span> <span class="n">was</span> <span class="n">attempted</span> <span class="n">so</span> <span class="n">xSemaphore</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span>
   <span class="o">//</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">check</span> <span class="n">its</span> <span class="n">value</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the counting semaphore was successfully created then a handle to the created counting semaphore is returned. If pxSemaphoreBuffer was NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">uxMaxCount</span></code>მაქსიმალური შესაძლო მნიშვნელობა. როდესაც სემაფორი ამ მნიშვნელობას მიაღწევს, მისი „მიცემა“ აღარ შეიძლება.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxInitialCount</span></code>სემაფორისთვის მინიჭებული რაოდენობის მნიშვნელობა მისი შექმნისას.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxSemaphoreBuffer</span></code>უნდა მიუთითებდეს StaticSemaphore_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება სემაფორის მონაცემთა სტრუქტურის შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.vSemaphoreDelete">
<span class="target" id="semphr_8h_1acd7d0eda0923d7caeeaaee9202c43eab"></span><code class="descname">vSemaphoreDelete</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.vSemaphoreDelete" title="Permalink to this definition">¶</a></dt>
<dd><p>სემაფორის წაშლა. ეს ფუნქცია სიფრთხილით უნდა იქნას გამოყენებული. მაგალითად, არ წაშალოთ mutex ტიპის სემაფორი, თუ mutex დავალებას ეკუთვნის.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xSemaphore</span></code>წასაშლელი სემაფორის სახელური. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xSemaphoreGetMutexHolder">
<span class="target" id="semphr_8h_1a7403bfbc06fb8449b2334f55d939a4c4"></span><code class="descname">xSemaphoreGetMutexHolder</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xSemaphoreGetMutexHolder" title="Permalink to this definition">¶</a></dt>
<dd><p>თუ xMutex მართლაც mutex ტიპის სემაფორია, დააბრუნეთ მიმდინარე mutex-ის მფლობელი. თუ xMutex არ არის mutex ტიპის სემაფორი, ან mutex ხელმისაწვდომია (არ არის დავალებაში შენახული), დააბრუნეთ NULL.</p>
<p>შენიშვნა: ეს კარგი გზაა იმის დასადგენად, გამომძახებელი დავალება მუტექსის მფლობელია თუ არა, მაგრამ არ არის კარგი გზა მუტექსის მფლობელის იდენტურობის დასადგენად, რადგან მფლობელი შეიძლება შეიცვალოს ფუნქციის გასვლასა და ტესტირებადი დაბრუნებული მნიშვნელობის შორის. </p>
</dd></dl>
<dl class="macro">
<dt id="c.uxSemaphoreGetCount">
<span class="target" id="semphr_8h_1aa26a3d7cf9b5595a652daeb7f81229f3"></span><code class="descname">uxSemaphoreGetCount</code><span class="sig-paren">(</span>xSemaphore<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.uxSemaphoreGetCount" title="Permalink to this definition">¶</a></dt>
<dd><p>თუ სემაფორა დათვლის სემაფორია, მაშინ uxSemaphoreGetCount() აბრუნებს მის მიმდინარე დათვლის მნიშვნელობას. თუ სემაფორა ორობითი სემაფორია, მაშინ uxSemaphoreGetCount() აბრუნებს 1-ს, თუ სემაფორა ხელმისაწვდომია, და 0-ს, თუ სემაფორა მიუწვდომელია. </p>
</dd></dl>
</div>
<div class="section" id="id7">
<h3>ტიპის განმარტებები<a class="headerlink" href="freertos.html#id7" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv417SemaphoreHandle_t">
<span id="_CPPv317SemaphoreHandle_t"></span><span id="_CPPv217SemaphoreHandle_t"></span><span id="SemaphoreHandle_t"></span><span class="target" id="semphr_8h_1ad88c6df4a04beedeac782918c8a332f5"></span><em class="property">typedef </em><a class="reference internal" href="freertos.html#_CPPv413QueueHandle_t" title="QueueHandle_t">რიგის სახელური_t</a> <code class="descname">SemaphoreHandle_t</code><a class="headerlink" href="freertos.html#_CPPv417SemaphoreHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
</div>
</div>
<div class="section" id="timer-api">
<h2>ტაიმერი API<a class="headerlink" href="freertos.html#timer-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>სათაურის ფაილი<a class="headerlink" href="freertos.html#id8" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/timers.h">freertos/include/freertos/timers.h</a></li>
</ul>
</div>
<div class="section" id="id9">
<h3>ფუნქციები<a class="headerlink" href="freertos.html#id9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv412xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t">
<span id="_CPPv312xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t"></span><span id="_CPPv212xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t"></span><span id="xTimerCreate__cCPC.TickType_tC.UBaseType_tC.voidPC.TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1acd5834fe4b94778f6204866277042627"></span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <code class="descname">xTimerCreate</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის ტაიმერის სახელი</em>, <em class="property">კონსტ</em> TickType_t <em>xTimerPeriodInTicks</em>, <em class="property">კონსტ</em> UBaseType_t <em>uxAutoReload</em>, void *<em class="property">კონსტ</em> <em>pvTimerID</em>, <a class="reference internal" href="freertos.html#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t">ტაიმერის უკუკავშირის ფუნქცია_t</a> <em>pxCallbackFunction</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv412xTimerCreatePCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ქმნის პროგრამული უზრუნველყოფის ტაიმერის ახალ ინსტანციას და აბრუნებს სახელურს, რომლის მეშვეობითაც შესაძლებელია შექმნილი პროგრამული უზრუნველყოფის ტაიმერის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, პროგრამული ტაიმერები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება ტაიმერის მონაცემთა სტრუქტურა. თუ პროგრამული ტაიმერი იქმნება xTimerCreate() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xTimerCreate() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ პროგრამული ტაიმერი იქმნება xTimerCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც პროგრამული ტაიმერი გამოიყენებს. შესაბამისად, xTimerCreateStatic() საშუალებას იძლევა პროგრამული ტაიმერის შექმნა დინამიური მეხსიერების გამოყოფის გარეშე.</p>
<p>ტაიმერები იქმნება მიძინებულ მდგომარეობაში. xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() და xTimerChangePeriodFromISR() API ფუნქციების გამოყენება შესაძლებელია ტაიმერის აქტიურ მდგომარეობაში გადასაყვანად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#define NUM_TIMERS 5

// An array to hold handles to the created timers.
TimerHandle_t xTimers[ NUM_TIMERS ];

// An array to hold a count of the number of times each timer expires.
int32_t lExpireCounters[ NUM_TIMERS ] = { 0 };

// Define a callback function that will be used by multiple timer instances.
// The callback function does nothing but count the number of times the
// associated timer expires, and stop the timer once the timer has expired
// 10 times.
void vTimerCallback( TimerHandle_t pxTimer )
{
int32_t lArrayIndex;
const int32_t xMaxExpiryCountBeforeStopping = 10;

       // Optionally do something if the pxTimer parameter is NULL.
       configASSERT( pxTimer );

    // Which timer expired?
    lArrayIndex = ( int32_t ) pvTimerGetTimerID( pxTimer );

    // Increment the number of times that pxTimer has expired.
    lExpireCounters[ lArrayIndex ] += 1;

    // If the timer has expired 10 times then stop it from running.
    if( lExpireCounters[ lArrayIndex ] == xMaxExpiryCountBeforeStopping )
    {
        // Do not use a block time if calling a timer API function from a
        // timer callback function, as doing so could cause a deadlock!
        xTimerStop( pxTimer, 0 );
    }
}

void main( void )
{
int32_t x;

    // Create then start some timers.  Starting the timers before the scheduler
    // has been started means the timers will start running immediately that
    // the scheduler starts.
    for( x = 0; x &lt; NUM_TIMERS; x++ )
    {
        xTimers[ x ] = xTimerCreate(    "Timer",       // Just a text name, not used by the kernel.
                                        ( 100 * x ),   // The timer period in ticks.
                                        pdTRUE,        // The timers will auto-reload themselves when they expire.
                                        ( void * ) x,  // Assign each timer a unique id equal to its array index.
                                        vTimerCallback // Each timer calls the same callback when it expires.
                                    );

        if( xTimers[ x ] == NULL )
        {
            // The timer was not created.
        }
        else
        {
            // Start the timer.  No block time is specified, and even if one was
            // it would be ignored because the scheduler has not yet been
            // started.
            if( xTimerStart( xTimers[ x ], 0 ) != pdPASS )
            {
                // The timer could not be set into the Active state.
            }
        }
    }

    // ...
    // Create tasks here.
    // ...

    // Starting the scheduler will start the timers running as they have already
    // been set into the active state.
    vTaskStartScheduler();

    // Should not reach here.
    for( ;; );
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcTimerName</span></code>: ტექსტური სახელი, რომელიც ენიჭება ტაიმერს. ეს კეთდება მხოლოდ გამართვა ის მუშაობის დასახმარებლად. თავად ბირთვი ტაიმერს მხოლოდ მისი სახელურით მოიხსენიებს და არასდროს მისი სახელით.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimerPeriodInTicks</span></code>ტაიმერის პერიოდი. დრო განისაზღვრება ტიკების პერიოდებით, ამიტომ კონსტანტა portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის გადასაყვანად. მაგალითად, თუ ტაიმერი უნდა იწურებოდეს 100 ტიკის შემდეგ, მაშინ xTimerPeriodInTicks უნდა დაყენდეს 100-ზე. ალტერნატიულად, თუ ტაიმერი უნდა იწურებოდეს 500 მილიწამის შემდეგ, მაშინ xPeriod შეიძლება დაყენდეს (500 / portTICK_PERIOD_MS) იმ პირობით, რომ configTICK_RATE_HZ ნაკლებია ან ტოლია 1000-ის.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxAutoReload</span></code>თუ uxAutoReload დაყენებულია pdTRUE-ზე, მაშინ ტაიმერი განმეორებით შეწყდება xTimerPeriodInTicks პარამეტრით დადგენილი სიხშირით. თუ uxAutoReload დაყენებულია pdFALSE-ზე, მაშინ ტაიმერი იქნება ერთჯერადი ტაიმერი და ვადის გასვლის შემდეგ გადავა მიძინებულ მდგომარეობაში.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvTimerID</span></code>: იდენტიფიკატორი, რომელიც ენიჭება შექმნილ ტაიმერს. როგორც წესი, ეს გამოიყენება ტაიმერის უკუკავშირის ფუნქციაში იმის დასადგენად, თუ რომელი ტაიმერი ამოიწურა, როდესაც იგივე უკუკავშირის ფუნქცია ენიჭება ერთზე მეტ ტაიმერს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxCallbackFunction</span></code>: ფუნქცია, რომელიც უნდა გამოიძახონ ტაიმერის ვადის გასვლის შემდეგ. უკუკავშირის ფუნქციებს უნდა ჰქონდეთ TimerCallbackFunction_t-ით განსაზღვრული პროტოტიპი, რომელიც არის „void vCallbackFunction( TimerHandle_t xTimer );“.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t">
<span id="_CPPv318xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="_CPPv218xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t"></span><span id="xTimerCreateStatic__cCPC.TickType_tC.UBaseType_tC.voidPC.TimerCallbackFunction_t.StaticTimer_tP"></span><span class="target" id="timers_8h_1a12002be9234be5958340690faa328e85"></span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <code class="descname">xTimerCreateStatic</code><span class="sig-paren">(</span><em class="property">კონსტ</em> char *<em class="property">კონსტ</em> <em>კომპიუტერის ტაიმერის სახელი</em>, <em class="property">კონსტ</em> TickType_t <em>xTimerPeriodInTicks</em>, <em class="property">კონსტ</em> UBaseType_t <em>uxAutoReload</em>, void *<em class="property">კონსტ</em> <em>pvTimerID</em>, <a class="reference internal" href="freertos.html#_CPPv423TimerCallbackFunction_t" title="TimerCallbackFunction_t">ტაიმერის უკუკავშირის ფუნქცია_t</a> <em>pxCallbackFunction</em>, StaticTimer_t *<em>pxTimerBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv418xTimerCreateStaticPCKcK10TickType_tK11UBaseType_tPCv23TimerCallbackFunction_tP13StaticTimer_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ქმნის პროგრამული უზრუნველყოფის ტაიმერის ახალ ინსტანციას და აბრუნებს სახელურს, რომლის მეშვეობითაც შესაძლებელია შექმნილი პროგრამული უზრუნველყოფის ტაიმერის მითითება.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, პროგრამული ტაიმერები იყენებენ მეხსიერების ბლოკს, რომელშიც ინახება ტაიმერის მონაცემთა სტრუქტურა. თუ პროგრამული ტაიმერი იქმნება xTimerCreate() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xTimerCreate() ფუნქციის შიგნით. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ პროგრამული ტაიმერი იქმნება xTimerCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც პროგრამული ტაიმერი გამოიყენებს. შესაბამისად, xTimerCreateStatic() საშუალებას იძლევა პროგრამული ტაიმერის შექმნა დინამიური მეხსიერების გამოყოფის გარეშე.</p>
<p>ტაიმერები იქმნება მიძინებულ მდგომარეობაში. xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() და xTimerChangePeriodFromISR() API ფუნქციების გამოყენება შესაძლებელია ტაიმერის აქტიურ მდგომარეობაში გადასაყვანად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">'s data structure.</span>
<span class="n">static</span> <span class="n">StaticTimer_t</span> <span class="n">xTimerBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">that</span> <span class="n">will</span> <span class="n">be</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">'s callback</span>
<span class="o">//</span> <span class="n">function</span><span class="o">.</span>
<span class="n">UBaseType_t</span> <span class="n">uxVariableToIncrement</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">A</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">increments</span> <span class="n">a</span> <span class="n">variable</span> <span class="n">passed</span> <span class="n">to</span>
<span class="o">//</span> <span class="n">it</span> <span class="n">when</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">was</span> <span class="n">created</span><span class="o">.</span>  <span class="n">After</span> <span class="n">the</span> <span class="mi">5</span><span class="n">th</span> <span class="n">increment</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="o">.</span>
<span class="n">static</span> <span class="n">void</span> <span class="n">prvTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xExpiredTimer</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">UBaseType_t</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span><span class="p">;</span>
<span class="n">BaseType_t</span> <span class="n">xReturned</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Obtain</span> <span class="n">the</span> <span class="n">address</span> <span class="n">of</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">increment</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">timer</span> <span class="n">ID</span><span class="o">.</span>
    <span class="n">puxVariableToIncrement</span> <span class="o">=</span> <span class="p">(</span> <span class="n">UBaseType_t</span> <span class="o">*</span> <span class="p">)</span> <span class="n">pvTimerGetTimerID</span><span class="p">(</span> <span class="n">xExpiredTimer</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">Increment</span> <span class="n">the</span> <span class="n">variable</span> <span class="n">to</span> <span class="n">show</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span><span class="o">.</span>
    <span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="p">)</span><span class="o">++</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">this</span> <span class="n">callback</span> <span class="n">has</span> <span class="n">executed</span> <span class="n">the</span> <span class="n">required</span> <span class="n">number</span> <span class="n">of</span> <span class="n">times</span><span class="p">,</span> <span class="n">stop</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">timer</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">puxVariableToIncrement</span> <span class="o">==</span> <span class="mi">5</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">called</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">timer</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">must</span> <span class="ow">not</span> <span class="n">block</span><span class="o">.</span>
        <span class="n">xTimerStop</span><span class="p">(</span> <span class="n">xExpiredTimer</span><span class="p">,</span> <span class="n">staticDONT_BLOCK</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">software</span> <span class="n">time</span><span class="o">.</span>  <span class="n">xTimerCreateStatic</span><span class="p">()</span> <span class="n">has</span> <span class="n">an</span> <span class="n">extra</span> <span class="n">parameter</span>
    <span class="o">//</span> <span class="n">than</span> <span class="n">the</span> <span class="n">normal</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">API</span> <span class="n">function</span><span class="o">.</span>  <span class="n">The</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">pointer</span>
    <span class="o">//</span> <span class="n">to</span> <span class="n">the</span> <span class="n">StaticTimer_t</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span>
    <span class="o">//</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="n">passed</span> <span class="k">as</span> <span class="n">NULL</span> <span class="n">then</span> <span class="n">the</span> <span class="n">structure</span> <span class="n">will</span> <span class="n">be</span>
    <span class="o">//</span> <span class="n">allocated</span> <span class="n">dynamically</span><span class="p">,</span> <span class="n">just</span> <span class="k">as</span> <span class="k">if</span> <span class="n">xTimerCreate</span><span class="p">()</span> <span class="n">had</span> <span class="n">been</span> <span class="n">called</span><span class="o">.</span>
    <span class="n">xTimer</span> <span class="o">=</span> <span class="n">xTimerCreateStatic</span><span class="p">(</span> <span class="s2">"T1"</span><span class="p">,</span>             <span class="o">//</span> <span class="n">Text</span> <span class="n">name</span> <span class="k">for</span> <span class="n">the</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Helps</span> <span class="n">debugging</span> <span class="n">only</span><span class="o">.</span>  <span class="n">Not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">FreeRTOS</span><span class="o">.</span>
                                 <span class="n">xTimerPeriod</span><span class="p">,</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
                                 <span class="n">pdTRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">auto</span><span class="o">-</span><span class="n">reload</span> <span class="n">timer</span><span class="o">.</span>
                                 <span class="p">(</span> <span class="n">void</span> <span class="o">*</span> <span class="p">)</span> <span class="o">&amp;</span><span class="n">uxVariableToIncrement</span><span class="p">,</span>    <span class="o">//</span> <span class="n">A</span> <span class="n">variable</span> <span class="n">incremented</span> <span class="n">by</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span><span class="s1">'s callback function</span>
                                 <span class="n">prvTimerCallback</span><span class="p">,</span> <span class="o">//</span> <span class="n">The</span> <span class="n">function</span> <span class="n">to</span> <span class="n">execute</span> <span class="n">when</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">expires</span><span class="o">.</span>
                                 <span class="o">&amp;</span><span class="n">xTimerBuffer</span> <span class="p">);</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">buffer</span> <span class="n">that</span> <span class="n">will</span> <span class="n">hold</span> <span class="n">the</span> <span class="n">software</span> <span class="n">timer</span> <span class="n">structure</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">started</span> <span class="n">yet</span> <span class="n">so</span> <span class="n">a</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
    <span class="n">xReturned</span> <span class="o">=</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>

    <span class="o">//</span> <span class="o">...</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
    <span class="o">//</span> <span class="o">...</span>

    <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">running</span> <span class="k">as</span> <span class="n">they</span> <span class="n">have</span> <span class="n">already</span>
    <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
    <span class="n">vTaskStartScheduler</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the timer is created then a handle to the created timer is returned. If pxTimerBuffer was NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pcTimerName</span></code>: ტექსტური სახელი, რომელიც ენიჭება ტაიმერს. ეს კეთდება მხოლოდ გამართვა ის მუშაობის დასახმარებლად. თავად ბირთვი ტაიმერს მხოლოდ მისი სახელურით მოიხსენიებს და არასდროს მისი სახელით.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTimerPeriodInTicks</span></code>ტაიმერის პერიოდი. დრო განისაზღვრება ტიკების პერიოდებით, ამიტომ კონსტანტა portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის გადასაყვანად. მაგალითად, თუ ტაიმერი უნდა იწურებოდეს 100 ტიკის შემდეგ, მაშინ xTimerPeriodInTicks უნდა დაყენდეს 100-ზე. ალტერნატიულად, თუ ტაიმერი უნდა იწურებოდეს 500 მილიწამის შემდეგ, მაშინ xPeriod შეიძლება დაყენდეს (500 / portTICK_PERIOD_MS) იმ პირობით, რომ configTICK_RATE_HZ ნაკლებია ან ტოლია 1000-ის.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxAutoReload</span></code>თუ uxAutoReload დაყენებულია pdTRUE-ზე, მაშინ ტაიმერი განმეორებით შეწყდება xTimerPeriodInTicks პარამეტრით დადგენილი სიხშირით. თუ uxAutoReload დაყენებულია pdFALSE-ზე, მაშინ ტაიმერი იქნება ერთჯერადი ტაიმერი და ვადის გასვლის შემდეგ გადავა მიძინებულ მდგომარეობაში.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvTimerID</span></code>: იდენტიფიკატორი, რომელიც ენიჭება შექმნილ ტაიმერს. როგორც წესი, ეს გამოიყენება ტაიმერის უკუკავშირის ფუნქციაში იმის დასადგენად, თუ რომელი ტაიმერი ამოიწურა, როდესაც იგივე უკუკავშირის ფუნქცია ენიჭება ერთზე მეტ ტაიმერს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxCallbackFunction</span></code>: ფუნქცია, რომელიც უნდა გამოიძახონ ტაიმერის ვადის გასვლის შემდეგ. უკუკავშირის ფუნქციებს უნდა ჰქონდეთ TimerCallbackFunction_t-ით განსაზღვრული პროტოტიპი, რომელიც არის „void vCallbackFunction( TimerHandle_t xTimer );“.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxTimerBuffer</span></code>უნდა მიუთითებდეს StaticTimer_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება პროგრამული ტაიმერის მონაცემთა სტრუქტურების შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417pvTimerGetTimerID13TimerHandle_t">
<span id="_CPPv317pvTimerGetTimerID13TimerHandle_t"></span><span id="_CPPv217pvTimerGetTimerID13TimerHandle_t"></span><span id="pvTimerGetTimerID__TimerHandle_t"></span><span class="target" id="timers_8h_1add681027143e1fdadcb8452a6a19585a"></span>void *<code class="descname">pvTimerGetTimerID</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417pvTimerGetTimerID13TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს ტაიმერისთვის მინიჭებულ ID-ს.</p>
<p>ტაიმერებს ID-ები ენიჭებათ xTimerCreated() ფუნქციის გამოძახების pvTimerID პარამეტრის გამოყენებით, რომელიც გამოყენებული იყო ტაიმერის შესაქმნელად.</p>
<p>თუ ერთი და იგივე უკუკავშირის ფუნქცია მინიჭებულია რამდენიმე ტაიმერზე, მაშინ ტაიმერის ID შეიძლება გამოყენებულ იქნას უკუკავშირის ფუნქციაში იმის დასადგენად, თუ რომელი ტაიმერი ამოიწურა სინამდვილეში.</p>
<p><p>გამოყენების მაგალითი:</p>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The ID assigned to the timer being queried.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერი, რომელზეც მოთხოვნა იგზავნება.</li>
</ul>
</dd>
</dl>
</p>
<p>იხილეთ xTimerCreate() API ფუნქციის გამოყენების მაგალითის სცენარი. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416vTimerSetTimerID13TimerHandle_tPv">
<span id="_CPPv316vTimerSetTimerID13TimerHandle_tPv"></span><span id="_CPPv216vTimerSetTimerID13TimerHandle_tPv"></span><span id="vTimerSetTimerID__TimerHandle_t.voidP"></span><span class="target" id="timers_8h_1a1f06045a953481dd7012d4c7762990cb"></span>void <code class="descname">vTimerSetTimerID</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em>, void *<em>pvNewID</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv416vTimerSetTimerID13TimerHandle_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტაიმერისთვის მინიჭებულ ID-ს ადგენს.</p>
<p>ტაიმერებს ID-ები ენიჭებათ xTimerCreated() ფუნქციის გამოძახების pvTimerID პარამეტრის გამოყენებით, რომელიც გამოყენებული იყო ტაიმერის შესაქმნელად.</p>
<p>თუ ერთი და იგივე უკუკავშირის ფუნქცია მინიჭებულია რამდენიმე ტაიმერზე, მაშინ ტაიმერის ID შეიძლება გამოყენებულ იქნას დროის სპეციფიკური (ტაიმერის ლოკალური) საცავად.</p>
<p><p>გამოყენების მაგალითი:</p>
<dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერი განახლდება.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvNewID</span></code>ტაიმერისთვის მინიჭებული ID.</li>
</ul>
</dd>
</dl>
</p>
<p>იხილეთ xTimerCreate() API ფუნქციის გამოყენების მაგალითის სცენარი. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xTimerIsTimerActive13TimerHandle_t">
<span id="_CPPv319xTimerIsTimerActive13TimerHandle_t"></span><span id="_CPPv219xTimerIsTimerActive13TimerHandle_t"></span><span id="xTimerIsTimerActive__TimerHandle_t"></span><span class="target" id="timers_8h_1a2cd9b1399fb25203be698f123846dc33"></span>BaseType_t <code class="descname">xTimerIsTimerActive</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xTimerIsTimerActive13TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ტაიმერს ეკითხება, აქტიურია თუ მიძინებული.</p>
<p>ტაიმერი იქნება უმოქმედო, თუ: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">)</span> <span class="n">It</span> <span class="n">has</span> <span class="n">been</span> <span class="n">created</span> <span class="n">but</span> <span class="ow">not</span> <span class="n">started</span><span class="p">,</span> <span class="ow">or</span>

<span class="mi">2</span><span class="p">)</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">expired</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span> <span class="n">that</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">been</span> <span class="n">restarted</span><span class="o">.</span>
</pre></div>
</div>
</p>
<p>ტაიმერები იქმნება მიძინებულ მდგომარეობაში. xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() და xTimerChangePeriodFromISR() API ფუნქციების გამოყენება შესაძლებელია ტაიმერის აქტიურ მდგომარეობაში გადასაყვანად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">"if( xTimerIsTimerActive( xTimer ) )"</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span><span class="o">.</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">do</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFALSE will be returned if the timer is dormant. A value other than pdFALSE will be returned if the timer is active.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერი, რომელზეც მოთხოვნა იგზავნება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv430xTimerGetTimerDaemonTaskHandlev">
<span id="_CPPv330xTimerGetTimerDaemonTaskHandlev"></span><span id="_CPPv230xTimerGetTimerDaemonTaskHandlev"></span><span id="xTimerGetTimerDaemonTaskHandle__void"></span><span class="target" id="timers_8h_1a1fe9e235a8c27986902b71ebda7385d8"></span><a class="reference internal" href="freertos.html#_CPPv412TaskHandle_t" title="TaskHandle_t">TaskHandle_t</a> <code class="descname">xTimerGetTimerDaemonTaskHandle</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv430xTimerGetTimerDaemonTaskHandlev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>xTimerGetTimerDaemonTaskHandle() მხოლოდ მაშინ არის ხელმისაწვდომი, თუ Free RTOS Config.h ფაილში INCLUDE_xTimerGetTimerDaemonTaskHandle დაყენებულია 1-ზე.</p>
<p>უბრალოდ აბრუნებს ტაიმერის სერვისის/დემონის დავალების სახელურს. თუ xTimerGetTimerDaemonTaskHandle()-ის გამოძახება დაგეგმარების დაწყებამდე არასწორია. </p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415xTimerGetPeriod13TimerHandle_t">
<span id="_CPPv315xTimerGetPeriod13TimerHandle_t"></span><span id="_CPPv215xTimerGetPeriod13TimerHandle_t"></span><span id="xTimerGetPeriod__TimerHandle_t"></span><span class="target" id="timers_8h_1a2735e79e155b2ca2a3809958ebb7431e"></span>TickType_t <code class="descname">xTimerGetPeriod</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415xTimerGetPeriod13TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს ტაიმერის პერიოდს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The period of the timer in ticks. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: მოთხოვნილი ტაიმერის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xTimerGetExpiryTime13TimerHandle_t">
<span id="_CPPv319xTimerGetExpiryTime13TimerHandle_t"></span><span id="_CPPv219xTimerGetExpiryTime13TimerHandle_t"></span><span id="xTimerGetExpiryTime__TimerHandle_t"></span><span class="target" id="timers_8h_1a06cdc26759c622eeb575070064e26025"></span>TickType_t <code class="descname">xTimerGetExpiryTime</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xTimerGetExpiryTime13TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს დროს ტიკებში, რომლის დროსაც ტაიმერი იწურება. თუ ეს ნაკლებია მიმდინარე ტიკების რაოდენობაზე, მაშინ ვადის გასვლის დრო გადაცილებულია მიმდინარე დროზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the timer is running then the time in ticks at which the timer will next expire is returned. If the timer is not running then the return value is undefined. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: მოთხოვნილი ტაიმერის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t">
<span id="_CPPv329xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="_CPPv229xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t"></span><span id="xTimerPendFunctionCallFromISR__PendedFunction_t.voidP.uint32_t.BaseType_tP"></span><span class="target" id="timers_8h_1af4444b6b1a4e8d7db156e6aaccdf66fa"></span>BaseType_t <code class="descname">xTimerPendFunctionCallFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv416PendedFunction_t" title="PendedFunction_t">დალოდებული ფუნქცია_t</a> <em>xFunctionToPend</em>, void *<em>pvპარამეტრი1</em>, uint32_t <em>ulParameter2</em>, BaseType_t *<em>pxHigherPriorityTaskWoken</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv429xTimerPendFunctionCallFromISR16PendedFunction_tPv8uint32_tP10BaseType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება აპლიკაციის შეწყვეტის სერვისის რუტინებიდან ფუნქციის შესრულების RTOS დემონის დავალებისთვის (ტაიმერის სერვისის დავალება, შესაბამისად, ეს ფუნქცია დანერგილია timers.c-ში და მას პრეფიქსი აქვს &amp;#39;Timer&amp;#39;).</p>
<p>იდეალურ შემთხვევაში, შეწყვეტის სერვისის რუტინა (ISR) რაც შეიძლება მოკლე უნდა იყოს, მაგრამ ზოგჯერ ISR-ს ან ბევრი დამუშავება აქვს შესასრულებელი, ან სჭირდება ისეთი დამუშავების შესრულება, რომელიც არ არის დეტერმინისტული. ამ შემთხვევებში, xTimerPendFunctionCallFromISR() შეიძლება გამოყენებულ იქნას ფუნქციის დამუშავების RTOS დემონის დავალებით გადასადებად.</p>
<p>გათვალისწინებულია მექანიზმი, რომელიც საშუალებას აძლევს შეწყვეტას პირდაპირ დაუბრუნდეს დავალებას, რომელიც შემდგომში შეასრულებს დალოდებულ უკუკავშირის ფუნქციას. ეს საშუალებას აძლევს უკუკავშირის ფუნქციას შესრულდეს შეწყვეტასთან ერთად დროში თანმიმდევრულად - ისევე, თითქოს უკუკავშირი შესრულდეს თავად შეწყვეტაში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">will</span> <span class="n">execute</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">context</span> <span class="n">of</span> <span class="n">the</span> <span class="n">daemon</span> <span class="n">task</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Note</span> <span class="n">callback</span> <span class="n">functions</span> <span class="n">must</span> <span class="nb">all</span> <span class="n">use</span> <span class="n">this</span> <span class="n">same</span> <span class="n">prototype</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vProcessInterface</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameter1</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">ulParameter2</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">The</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">requires</span> <span class="n">servicing</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span>
    <span class="o">//</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
   <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="p">(</span> <span class="n">BaseType_t</span> <span class="p">)</span> <span class="n">ulParameter2</span><span class="p">;</span>

   <span class="o">//</span> <span class="o">...</span><span class="n">Perform</span> <span class="n">the</span> <span class="n">processing</span> <span class="n">here</span><span class="o">...</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">An</span> <span class="n">ISR</span> <span class="n">that</span> <span class="n">receives</span> <span class="n">data</span> <span class="n">packets</span> <span class="kn">from</span> <span class="nn">multiple</span> <span class="n">interfaces</span>
<span class="n">void</span> <span class="n">vAnISR</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">BaseType_t</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="n">xHigherPriorityTaskWoken</span><span class="p">;</span>

   <span class="o">//</span> <span class="n">Query</span> <span class="n">the</span> <span class="n">hardware</span> <span class="n">to</span> <span class="n">determine</span> <span class="n">which</span> <span class="n">interface</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>
   <span class="n">xInterfaceToService</span> <span class="o">=</span> <span class="n">prvCheckInterfaces</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">actual</span> <span class="n">processing</span> <span class="ow">is</span> <span class="n">to</span> <span class="n">be</span> <span class="n">deferred</span> <span class="n">to</span> <span class="n">a</span> <span class="n">task</span><span class="o">.</span>  <span class="n">Request</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">vProcessInterface</span><span class="p">()</span> <span class="n">callback</span> <span class="n">function</span> <span class="ow">is</span> <span class="n">executed</span><span class="p">,</span> <span class="n">passing</span> <span class="ow">in</span> <span class="n">the</span>
   <span class="o">//</span> <span class="n">number</span> <span class="n">of</span> <span class="n">the</span> <span class="n">interface</span> <span class="n">that</span> <span class="n">needs</span> <span class="n">processing</span><span class="o">.</span>  <span class="n">The</span> <span class="n">interface</span> <span class="n">to</span>
   <span class="o">//</span> <span class="n">service</span> <span class="ow">is</span> <span class="n">passed</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">second</span> <span class="n">parameter</span><span class="o">.</span>  <span class="n">The</span> <span class="n">first</span> <span class="n">parameter</span> <span class="ow">is</span>
   <span class="o">//</span> <span class="ow">not</span> <span class="n">used</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span><span class="o">.</span>
   <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>
   <span class="n">xTimerPendFunctionCallFromISR</span><span class="p">(</span> <span class="n">vProcessInterface</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="p">(</span> <span class="n">uint32_t</span> <span class="p">)</span> <span class="n">xInterfaceToService</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

   <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="ow">is</span> <span class="n">now</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdTRUE</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span>
   <span class="o">//</span> <span class="n">switch</span> <span class="n">should</span> <span class="n">be</span> <span class="n">requested</span><span class="o">.</span>  <span class="n">The</span> <span class="n">macro</span> <span class="n">used</span> <span class="ow">is</span> <span class="n">port</span> <span class="n">specific</span> <span class="ow">and</span> <span class="n">will</span>
   <span class="o">//</span> <span class="n">be</span> <span class="n">either</span> <span class="n">portYIELD_FROM_ISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">portEND_SWITCHING_ISR</span><span class="p">()</span> <span class="o">-</span> <span class="n">refer</span> <span class="n">to</span>
   <span class="o">//</span> <span class="n">the</span> <span class="n">documentation</span> <span class="n">page</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="o">.</span>
   <span class="n">portYIELD_FROM_ISR</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xFunctionToPend</span></code>: ფუნქცია, რომელიც უნდა შესრულდეს ტაიმერის სერვისიდან/დემონის დავალებიდან. ფუნქცია უნდა შეესაბამებოდეს PendedFunction_t პროტოტიპს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter1</span></code>: უკუკავშირის ფუნქციის პირველი პარამეტრის მნიშვნელობა. პარამეტრს აქვს void * ტიპი, რაც საშუალებას იძლევა მისი გამოყენება ნებისმიერი ტიპის გადასაცემად. მაგალითად, unsigned longs შეიძლება გადაიცეს void *-ზე, ან void * შეიძლება გამოყენებულ იქნას სტრუქტურაზე მითითებისთვის.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulParameter2</span></code>უკუკავშირის ფუნქციის მეორე პარამეტრის მნიშვნელობა.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>როგორც ზემოთ აღინიშნა, ამ ფუნქციის გამოძახების შედეგად ტაიმერის დემონის დავალებაში გაიგზავნება შეტყობინება. თუ ტაიმერის დემონის დავალების პრიორიტეტი (რომელიც დაყენებულია Free RTOS Config.h ფაილში configTIMER_TASK_PRIORITY-ის გამოყენებით) უფრო მაღალია, ვიდრე ამჟამად შესრულებული დავალების პრიორიტეტი (დავალება, რომელიც შეფერხების შედეგად შეწყდა), მაშინ *pxHigherPriorityTaskWoken xTimerPendFunctionCallFromISR()-ში დაყენდება pdTRUE-ზე, რაც მიუთითებს, რომ შეფერხების დასრულებამდე უნდა მოითხოვონ კონტექსტის შეცვლა. ამ მიზეზით *pxHigherPriorityTaskWoken უნდა იყოს ინიციალიზებული pdFALSE-ზე. იხილეთ ქვემოთ მოცემული მაგალითის კოდი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t">
<span id="_CPPv322xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="_CPPv222xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t"></span><span id="xTimerPendFunctionCall__PendedFunction_t.voidP.uint32_t.TickType_t"></span><span class="target" id="timers_8h_1a5df6d08740c1184489440072246a02f2"></span>BaseType_t <code class="descname">xTimerPendFunctionCall</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv416PendedFunction_t" title="PendedFunction_t">დალოდებული ფუნქცია_t</a> <em>xFunctionToPend</em>, void *<em>pvპარამეტრი1</em>, uint32_t <em>ulParameter2</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv422xTimerPendFunctionCall16PendedFunction_tPv8uint32_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოიყენება ფუნქციის შესრულების RTOS დემონის დავალებით გადასადებად (ტაიმერის სერვისის დავალება, შესაბამისად, ეს ფუნქცია იმპლემენტირებულია timers.c-ში და მას პრეფიქსი აქვს &amp;#39;Timer&amp;#39;).</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdPASS is returned if the message was successfully sent to the timer daemon task, otherwise pdFALSE is returned. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xFunctionToPend</span></code>: ფუნქცია, რომელიც უნდა შესრულდეს ტაიმერის სერვისიდან/დემონის დავალებიდან. ფუნქცია უნდა შეესაბამებოდეს PendedFunction_t პროტოტიპს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pvParameter1</span></code>: უკუკავშირის ფუნქციის პირველი პარამეტრის მნიშვნელობა. პარამეტრს აქვს void * ტიპი, რაც საშუალებას იძლევა მისი გამოყენება ნებისმიერი ტიპის გადასაცემად. მაგალითად, unsigned longs შეიძლება გადაიცეს void *-ზე, ან void * შეიძლება გამოყენებულ იქნას სტრუქტურაზე მითითებისთვის.</li>
<li><code class="docutils literal notranslate"><span class="pre">ulParameter2</span></code>უკუკავშირის ფუნქციის მეორე პარამეტრის მნიშვნელობა.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>ამ ფუნქციის გამოძახების შედეგად, რიგში მყოფ ტაიმერის დემონის დავალებას გაეგზავნება შეტყობინება. xTicksToWait არის დრო, რომლის განმავლობაშიც დავალება უნდა დარჩეს დაბლოკილ მდგომარეობაში (ანუ დამუშავების დროის გამოყენების გარეშე), რათა ტაიმერის რიგში თავისუფალი ადგილი გახდეს, თუ რიგი სავსე აღმოჩნდება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419pcTimerGetTimerName13TimerHandle_t">
<span id="_CPPv319pcTimerGetTimerName13TimerHandle_t"></span><span id="_CPPv219pcTimerGetTimerName13TimerHandle_t"></span><span id="pcTimerGetTimerName__TimerHandle_t"></span><span class="target" id="timers_8h_1ac400899727aade5734a33f3228a6ef9d"></span><em class="property">კონსტ</em> char *<code class="descname">pcTimerGetTimerName</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> <em>x ტაიმერი</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419pcTimerGetTimerName13TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>აბრუნებს სახელს, რომელიც ტაიმერს მინიჭებული ჰქონდა ტაიმერის შექმნისას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The name assigned to the timer specified by the xTimer parameter. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: მოთხოვნილი ტაიმერის სახელური.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id10">
<h3>მაკროები<a class="headerlink" href="freertos.html#id10" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR">
<span class="target" id="timers_8h_1aff0b8d2d5d743afef9d52861618139bf"></span><code class="descname">tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_EXECUTE_CALLBACK">
<span class="target" id="timers_8h_1aca42f545424488ce7dfd43c0d70ca610"></span><code class="descname">tmrCOMMAND_EXECUTE_CALLBACK</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_EXECUTE_CALLBACK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_START_DONT_TRACE">
<span class="target" id="timers_8h_1adcc4f4391b0850b18596974d7618bdfc"></span><code class="descname">tmrCOMMAND_START_DONT_TRACE</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_START_DONT_TRACE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_START">
<span class="target" id="timers_8h_1afc38af63403775cc4ced3995f920343a"></span><code class="descname">tmrCOMMAND_START</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_START" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_RESET">
<span class="target" id="timers_8h_1a0a63f701c021371d186adca7c590e923"></span><code class="descname">tmrCOMMAND_RESET</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_RESET" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_STOP">
<span class="target" id="timers_8h_1a0cd6f6a41dcd52d2fc06c350f43516c0"></span><code class="descname">tmrCOMMAND_STOP</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_STOP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_CHANGE_PERIOD">
<span class="target" id="timers_8h_1adb27881a1a1118b9cc4d711391c89414"></span><code class="descname">tmrCOMMAND_CHANGE_PERIOD</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_CHANGE_PERIOD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_DELETE">
<span class="target" id="timers_8h_1a5a5586339a9dbc1320153fd96a1c2f33"></span><code class="descname">tmrCOMMAND_DELETE</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_DELETE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrFIRST_FROM_ISR_COMMAND">
<span class="target" id="timers_8h_1afab5e13e40f49f678d62925ab8bc44a1"></span><code class="descname">tmrFIRST_FROM_ISR_COMMAND</code><a class="headerlink" href="freertos.html#c.tmrFIRST_FROM_ISR_COMMAND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_START_FROM_ISR">
<span class="target" id="timers_8h_1add053fdcf41607ba790004590c11844f"></span><code class="descname">tmrCOMMAND_START_FROM_ISR</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_START_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_RESET_FROM_ISR">
<span class="target" id="timers_8h_1a1d69bd5e47301570a4aa149bd868534a"></span><code class="descname">tmrCOMMAND_RESET_FROM_ISR</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_RESET_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_STOP_FROM_ISR">
<span class="target" id="timers_8h_1acbf988b64a5897a1c030da417cc654de"></span><code class="descname">tmrCOMMAND_STOP_FROM_ISR</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_STOP_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.tmrCOMMAND_CHANGE_PERIOD_FROM_ISR">
<span class="target" id="timers_8h_1ab520106084753fbb137ac275ab3ff20b"></span><code class="descname">tmrCOMMAND_CHANGE_PERIOD_FROM_ISR</code><a class="headerlink" href="freertos.html#c.tmrCOMMAND_CHANGE_PERIOD_FROM_ISR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="macro">
<dt id="c.xTimerStart">
<span class="target" id="timers_8h_1a3a9b838f48991e852ce05c986b0eeb8c"></span><code class="descname">xTimerStart</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerStart" title="Permalink to this definition">¶</a></dt>
<dd><p>ტაიმერის ფუნქციონირება უზრუნველყოფილია ტაიმერის სერვისის/დემონის დავალებით. საჯარო უფასო RTOS timer API ფუნქციების უმეტესობა ტაიმერის სერვისის დავალებას ბრძანებებს უგზავნის რიგის მეშვეობით, რომელსაც ტაიმერის ბრძანების რიგი ეწოდება. ტაიმერის ბრძანების რიგი კერძოა თავად ბირთვისთვის და მასზე პირდაპირ წვდომა არ არის აპლიკაციის კოდისთვის. ტაიმერის ბრძანების რიგის სიგრძე განისაზღვრება configTIMER_QUEUE_LENGTH კონფიგურაციის მუდმივით.</p>
<p>xTimerStart() იწყებს ტაიმერს, რომელიც ადრე შეიქმნა xTimerCreate() API ფუნქციის გამოყენებით. თუ ტაიმერი უკვე ჩართული იყო და აქტიურ მდგომარეობაში იყო, მაშინ xTimerStart()-ს აქვს xTimerReset() API ფუნქციის ექვივალენტური ფუნქციონალი.</p>
<p>ტაიმერის გაშვება უზრუნველყოფს, რომ ტაიმერი აქტიურ მდგომარეობაშია. თუ ტაიმერი შუალედში არ შეჩერდება, არ წაიშლება ან არ გადაყენდება, ტაიმერთან დაკავშირებული უკუკავშირის ფუნქცია გამოიძახება &amp;#39;n&amp;#39; ტიკებით xTimerStart() გამოძახების შემდეგ, სადაც &amp;#39;n&amp;#39; არის ტაიმერის განსაზღვრული პერიოდი.</p>
<p>xTimerStart()-ის გამოძახება დამგეგმავის გაშვებამდეც შესაძლებელია, თუმცა ამის შემდეგ ტაიმერი რეალურად არ ჩაირთვება დამგეგმავის გაშვებამდე და ტაიმერის ვადის გასვლის დრო მისი გაშვების დროის ფარდობითი იქნება და არა xTimerStart()-ის გამოძახების დროის ფარდობითი.</p>
<p>xTimerStart() ფუნქციის ხელმისაწვდომობისთვის, configUSE_TIMERS კონფიგურაციის კონსტანტა უნდა იყოს დაყენებული 1-ზე.</p>
<p><p>გამოყენების მაგალითი:</p>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერის ჩართვის/გადატვირთვის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: განსაზღვრავს დროს, ტიკებში, რომლის დროსაც გამომძახებელი დავალება უნდა იყოს დაბლოკილ მდგომარეობაში, რათა დაელოდოს start ბრძანების წარმატებით გაგზავნას ტაიმერის ბრძანების რიგში, თუ რიგი უკვე სავსეა xTimerStart() გამოძახებისას. xTicksToWait იგნორირებულია, თუ xTimerStart() გამოძახება ხდება დამგეგმავის დაწყებამდე.</li>
</ul>
</dd>
</dl>
</p>
<p>იხილეთ xTimerCreate() API ფუნქციის გამოყენების მაგალითის სცენარი. </p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerStop">
<span class="target" id="timers_8h_1a8327c7fc10aee414cb163b445c5269a4"></span><code class="descname">xTimerStop</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerStop" title="Permalink to this definition">¶</a></dt>
<dd><p>ტაიმერის ფუნქციონირება უზრუნველყოფილია ტაიმერის სერვისის/დემონის დავალებით. საჯარო უფასო RTOS timer API ფუნქციების უმეტესობა ტაიმერის სერვისის დავალებას ბრძანებებს უგზავნის რიგის მეშვეობით, რომელსაც ტაიმერის ბრძანების რიგი ეწოდება. ტაიმერის ბრძანების რიგი კერძოა თავად ბირთვისთვის და მასზე პირდაპირ წვდომა არ არის აპლიკაციის კოდისთვის. ტაიმერის ბრძანების რიგის სიგრძე განისაზღვრება configTIMER_QUEUE_LENGTH კონფიგურაციის მუდმივით.</p>
<p>xTimerStop() აჩერებს ტაიმერს, რომელიც ადრე იყო ჩართული xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() ან xTimerChangePeriodFromISR() API ფუნქციებიდან რომელიმეს გამოყენებით.</p>
<p>ტაიმერის გაჩერება უზრუნველყოფს, რომ ტაიმერი აქტიურ მდგომარეობაში არ იქნება.</p>
<p>xTimerStop() ფუნქციის ხელმისაწვდომობისთვის, configUSE_TIMERS კონფიგურაციის კონსტანტა უნდა იყოს დაყენებული 1-ზე.</p>
<p><p>გამოყენების მაგალითი:</p>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: გაჩერებული ტაიმერის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: განსაზღვრავს დროს, ტიკებში, რომლის დროსაც გამომძახებელი დავალება უნდა იყოს დაბლოკილ მდგომარეობაში, რათა დაელოდოს გაჩერების ბრძანების წარმატებით გაგზავნას ტაიმერის ბრძანებების რიგში, თუ რიგი უკვე სავსეა xTimerStop() გამოძახებისას. xTicksToWait იგნორირებულია, თუ xTimerStop() გამოძახებულია დამგეგმავის დაწყებამდე.</li>
</ul>
</dd>
</dl>
</p>
<p>იხილეთ xTimerCreate() API ფუნქციის გამოყენების მაგალითის სცენარი. </p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerChangePeriod">
<span class="target" id="timers_8h_1ab12eac1c69a3437b8161ce81ff34b2f4"></span><code class="descname">xTimerChangePeriod</code><span class="sig-paren">(</span>xTimer, xNewPeriod, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerChangePeriod" title="Permalink to this definition">¶</a></dt>
<dd><p>ტაიმერის ფუნქციონირება უზრუნველყოფილია ტაიმერის სერვისის/დემონის დავალებით. საჯარო უფასო RTOS timer API ფუნქციების უმეტესობა ტაიმერის სერვისის დავალებას ბრძანებებს უგზავნის რიგის მეშვეობით, რომელსაც ტაიმერის ბრძანების რიგი ეწოდება. ტაიმერის ბრძანების რიგი კერძოა თავად ბირთვისთვის და მასზე პირდაპირ წვდომა არ არის აპლიკაციის კოდისთვის. ტაიმერის ბრძანების რიგის სიგრძე განისაზღვრება configTIMER_QUEUE_LENGTH კონფიგურაციის მუდმივით.</p>
<p>xTimerChangePeriod() ცვლის xTimerCreate() API ფუნქციის გამოყენებით ადრე შექმნილი ტაიმერის პერიოდს.</p>
<p>xTimerChangePeriod() ფუნქციის გამოძახება შესაძლებელია აქტიური ან მიძინებული მდგომარეობის ტაიმერის პერიოდის შესაცვლელად.</p>
<p>xTimerChangePeriod() ფუნქციის ხელმისაწვდომობისთვის, configUSE_TIMERS კონფიგურაციის კონსტანტა უნდა იყოს დაყენებული 1-ზე.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">function</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">//</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">timer</span>
<span class="o">//</span> <span class="ow">is</span> <span class="n">deleted</span><span class="o">.</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">referenced</span> <span class="n">by</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span> <span class="n">when</span> <span class="n">it</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">called</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="nb">set</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">started</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAFunction</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">xTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerIsTimerActive</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span> <span class="o">//</span> <span class="ow">or</span> <span class="n">more</span> <span class="n">simply</span> <span class="ow">and</span> <span class="n">equivalently</span> <span class="s2">"if( xTimerIsTimerActive( xTimer ) )"</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="n">already</span> <span class="n">active</span> <span class="o">-</span> <span class="n">delete</span> <span class="n">it</span><span class="o">.</span>
        <span class="n">xTimerDelete</span><span class="p">(</span> <span class="n">xTimer</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">xTimer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">active</span><span class="p">,</span> <span class="n">change</span> <span class="n">its</span> <span class="n">period</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>  <span class="n">This</span> <span class="n">will</span> <span class="n">also</span>
        <span class="o">//</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">start</span><span class="o">.</span>  <span class="n">Block</span> <span class="k">for</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span> <span class="n">ticks</span> <span class="k">if</span> <span class="n">the</span>
        <span class="o">//</span> <span class="n">change</span> <span class="n">period</span> <span class="n">command</span> <span class="n">cannot</span> <span class="n">immediately</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">the</span> <span class="n">timer</span>
        <span class="o">//</span> <span class="n">command</span> <span class="n">queue</span><span class="o">.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriod</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="mi">500</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">==</span> <span class="n">pdPASS</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">was</span> <span class="n">successfully</span> <span class="n">sent</span><span class="o">.</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">sent</span><span class="p">,</span> <span class="n">even</span> <span class="n">after</span> <span class="n">waiting</span> <span class="k">for</span> <span class="mi">100</span> <span class="n">ticks</span>
            <span class="o">//</span> <span class="n">to</span> <span class="k">pass</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>ტაიმერის სახელური, რომლის პერიოდიც იცვლება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xNewPeriod</span></code>xTimer-ის ახალი პერიოდი. ტაიმერის პერიოდები მითითებულია ტიკების პერიოდებში, ამიტომ კონსტანტა portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის გადასაყვანად. მაგალითად, თუ ტაიმერი უნდა იწურებოდეს 100 ტიკის შემდეგ, მაშინ xNewPeriod უნდა დაყენდეს 100-ზე. ალტერნატიულად, თუ ტაიმერი უნდა იწურებოდეს 500 მილიწამის შემდეგ, მაშინ xNewPeriod შეიძლება დაყენდეს (500 / portTICK_PERIOD_MS) იმ პირობით, რომ configTICK_RATE_HZ ნაკლებია ან ტოლია 1000-ის.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: განსაზღვრავს დროს, ტიკებში, რომლის დროსაც გამომძახებელი დავალება უნდა იყოს დაბლოკილ მდგომარეობაში, რათა დაელოდოს ცვლილების პერიოდის ბრძანების წარმატებით გაგზავნას ტაიმერის ბრძანების რიგში, თუ რიგი უკვე სავსეა xTimerChangePeriod() გამოძახებისას. xTicksToWait იგნორირებულია, თუ xTimerChangePeriod() გამოძახებულია დამგეგმავის დაწყებამდე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerDelete">
<span class="target" id="timers_8h_1a8c8e21f05ebe92e15449addc5d269d10"></span><code class="descname">xTimerDelete</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerDelete" title="Permalink to this definition">¶</a></dt>
<dd><p>ტაიმერის ფუნქციონირება უზრუნველყოფილია ტაიმერის სერვისის/დემონის დავალებით. საჯარო უფასო RTOS timer API ფუნქციების უმეტესობა ტაიმერის სერვისის დავალებას ბრძანებებს უგზავნის რიგის მეშვეობით, რომელსაც ტაიმერის ბრძანების რიგი ეწოდება. ტაიმერის ბრძანების რიგი კერძოა თავად ბირთვისთვის და მასზე პირდაპირ წვდომა არ არის აპლიკაციის კოდისთვის. ტაიმერის ბრძანების რიგის სიგრძე განისაზღვრება configTIMER_QUEUE_LENGTH კონფიგურაციის მუდმივით.</p>
<p>xTimerDelete() შლის ტაიმერს, რომელიც ადრე შეიქმნა xTimerCreate() API ფუნქციის გამოყენებით.</p>
<p>xTimerDelete() ფუნქციის ხელმისაწვდომობისთვის, configUSE_TIMERS კონფიგურაციის კონსტანტა უნდა იყოს დაყენებული 1-ზე.</p>
<p><p>გამოყენების მაგალითი:</p>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>წასაშლელი ტაიმერის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: განსაზღვრავს დროს, ტიკებში, რომლის დროსაც გამომძახებელი დავალება უნდა იყოს დაბლოკილ მდგომარეობაში, რათა დაელოდოს წაშლის ბრძანების წარმატებით გაგზავნას ტაიმერის ბრძანებების რიგში, თუ რიგი უკვე სავსეა xTimerDelete() გამოძახებისას. xTicksToWait იგნორირებულია, თუ xTimerDelete() გამოძახება ხდება დამგეგმავის დაწყებამდე.</li>
</ul>
</dd>
</dl>
</p>
<p>იხილეთ xTimerChangePeriod() API ფუნქციის გამოყენების მაგალითის სცენარი. </p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerReset">
<span class="target" id="timers_8h_1a8081b4541b752908dc55df2693e53287"></span><code class="descname">xTimerReset</code><span class="sig-paren">(</span>xTimer, xTicksToWait<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerReset" title="Permalink to this definition">¶</a></dt>
<dd><p>ტაიმერის ფუნქციონირება უზრუნველყოფილია ტაიმერის სერვისის/დემონის დავალებით. საჯარო უფასო RTOS timer API ფუნქციების უმეტესობა ტაიმერის სერვისის დავალებას ბრძანებებს უგზავნის რიგის მეშვეობით, რომელსაც ტაიმერის ბრძანების რიგი ეწოდება. ტაიმერის ბრძანების რიგი კერძოა თავად ბირთვისთვის და მასზე პირდაპირ წვდომა არ არის აპლიკაციის კოდისთვის. ტაიმერის ბრძანების რიგის სიგრძე განისაზღვრება configTIMER_QUEUE_LENGTH კონფიგურაციის მუდმივით.</p>
<p>xTimerReset() ხელახლა იწყებს ტაიმერს, რომელიც ადრე შეიქმნა xTimerCreate() API ფუნქციის გამოყენებით. თუ ტაიმერი უკვე ჩართული იყო და აქტიურ მდგომარეობაში იმყოფებოდა, მაშინ xTimerReset() აიძულებს ტაიმერს ხელახლა შეაფასოს თავისი ვადის გასვლის დრო ისე, რომ ის ფარდობითი იყოს xTimerReset() გამოძახების დროსთან. თუ ტაიმერი მიძინებულ მდგომარეობაში იმყოფებოდა, მაშინ xTimerReset()-ს აქვს xTimerStart() API ფუნქციის ექვივალენტური ფუნქციონალი.</p>
<p>ტაიმერის გადატვირთვა უზრუნველყოფს, რომ ტაიმერი აქტიურ მდგომარეობაშია. თუ ტაიმერი შუალედში არ შეჩერდება, არ წაიშლება ან არ გადაყენდება, ტაიმერთან დაკავშირებული უკუკავშირის ფუნქცია გამოიძახება &amp;#39;n&amp;#39; ტიკით xTimerReset() გამოძახების შემდეგ, სადაც &amp;#39;n&amp;#39; არის ტაიმერის განსაზღვრული პერიოდი.</p>
<p>xTimerReset() ფუნქციის გამოძახება დამგეგმავის გაშვებამდეც შესაძლებელია, თუმცა, ამის შემდეგ ტაიმერი რეალურად არ ჩაირთვება დამგეგმავის გაშვებამდე და ტაიმერების ვადის გასვლის დრო მისი გაშვების დროსთან შეფარდებითი იქნება და არა xTimerReset() ფუნქციის გამოძახების დროსთან.</p>
<p>xTimerReset() ფუნქციის ხელმისაწვდომობისთვის, configUSE_TIMERS კონფიგურაციის კონსტანტა უნდა იყოს დაყენებული 1-ზე.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">When</span> <span class="n">a</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>

<span class="n">TimerHandle_t</span> <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventHandler</span><span class="p">(</span> <span class="n">char</span> <span class="n">cKey</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">Wait</span> <span class="mi">10</span> <span class="n">ticks</span> <span class="k">for</span> <span class="n">the</span> <span class="n">command</span> <span class="n">to</span> <span class="n">be</span> <span class="n">successfully</span> <span class="n">sent</span>
    <span class="o">//</span> <span class="k">if</span> <span class="n">it</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">immediately</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerReset</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">main</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">int32_t</span> <span class="n">x</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Create</span> <span class="n">then</span> <span class="n">start</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span>
    <span class="o">//</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="k">if</span> <span class="n">no</span> <span class="n">keys</span> <span class="n">are</span> <span class="n">pressed</span> <span class="n">within</span> <span class="n">a</span> <span class="mi">5</span> <span class="n">second</span> <span class="n">period</span><span class="o">.</span>
    <span class="n">xBacklightTimer</span> <span class="o">=</span> <span class="n">xTimerCreate</span><span class="p">(</span> <span class="s2">"BacklightTimer"</span><span class="p">,</span>           <span class="o">//</span> <span class="n">Just</span> <span class="n">a</span> <span class="n">text</span> <span class="n">name</span><span class="p">,</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">kernel</span><span class="o">.</span>
                                    <span class="p">(</span> <span class="mi">5000</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">),</span> <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">period</span> <span class="ow">in</span> <span class="n">ticks</span><span class="o">.</span>
                                    <span class="n">pdFALSE</span><span class="p">,</span>                    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>
                                    <span class="mi">0</span><span class="p">,</span>                          <span class="o">//</span> <span class="n">The</span> <span class="nb">id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">callback</span> <span class="n">so</span> <span class="n">can</span> <span class="n">take</span> <span class="nb">any</span> <span class="n">value</span><span class="o">.</span>
                                    <span class="n">vBacklightTimerCallback</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">that</span> <span class="n">switches</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span><span class="o">.</span>
                                  <span class="p">);</span>

    <span class="k">if</span><span class="p">(</span> <span class="n">xBacklightTimer</span> <span class="o">==</span> <span class="n">NULL</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">created</span><span class="o">.</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Start</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">No</span> <span class="n">block</span> <span class="n">time</span> <span class="ow">is</span> <span class="n">specified</span><span class="p">,</span> <span class="ow">and</span> <span class="n">even</span> <span class="k">if</span> <span class="n">one</span> <span class="n">was</span>
        <span class="o">//</span> <span class="n">it</span> <span class="n">would</span> <span class="n">be</span> <span class="n">ignored</span> <span class="n">because</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">has</span> <span class="ow">not</span> <span class="n">yet</span> <span class="n">been</span>
        <span class="o">//</span> <span class="n">started</span><span class="o">.</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStart</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">Active</span> <span class="n">state</span><span class="o">.</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="o">...</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">tasks</span> <span class="n">here</span><span class="o">.</span>
    <span class="o">//</span> <span class="o">...</span>

    <span class="o">//</span> <span class="n">Starting</span> <span class="n">the</span> <span class="n">scheduler</span> <span class="n">will</span> <span class="n">start</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">running</span> <span class="k">as</span> <span class="n">it</span> <span class="n">has</span> <span class="n">already</span>
    <span class="o">//</span> <span class="n">been</span> <span class="nb">set</span> <span class="n">into</span> <span class="n">the</span> <span class="n">active</span> <span class="n">state</span><span class="o">.</span>
    <span class="n">xTaskStartScheduler</span><span class="p">();</span>

    <span class="o">//</span> <span class="n">Should</span> <span class="ow">not</span> <span class="n">reach</span> <span class="n">here</span><span class="o">.</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xTicksToWait ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერის გადაყენების/გაშვების/გადატვირთვის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: განსაზღვრავს დროს, ტიკებში, რომლის დროსაც გამომძახებელი დავალება უნდა იყოს დაბლოკილ მდგომარეობაში, რათა დაელოდოს გადატვირთვის ბრძანების წარმატებით გაგზავნას ტაიმერის ბრძანებების რიგში, თუ რიგი უკვე სავსეა xTimerReset() გამოძახების დროს. xTicksToWait იგნორირებულია, თუ xTimerReset() გამოძახებულია დამგეგმავის დაწყებამდე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerStartFromISR">
<span class="target" id="timers_8h_1adab5809f9679e44a343b8dbb8fb7c67f"></span><code class="descname">xTimerStartFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerStartFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xTimerStart()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">restart</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">"FromISR"</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
    <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
    <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStartFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">start</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერის ჩართვის/გადატვირთვის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>ტაიმერის სერვისის/დემონის დავალება დროის უმეტეს ნაწილს დაბლოკილ მდგომარეობაში ატარებს და ელოდება ტაიმერის ბრძანებების რიგში შეტყობინებების მიღებას. xTimerStartFromISR()-ის გამოძახება შეტყობინებას წერს ტაიმერის ბრძანებების რიგში, რაც პოტენციურად იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გადატანას. თუ xTimerStartFromISR()-ის გამოძახება იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გამოსვლას და ტაიმერის სერვისის/დემონის დავალებას აქვს პრიორიტეტი, რომელიც ტოლია ან მეტია ამჟამად შესრულებული დავალების (შეწყვეტილი დავალების) მიმართ, მაშინ *pxHigherPriorityTaskWoken xTimerStartFromISR() ფუნქციის ფარგლებში შიდა დონეზე დაყენდება pdTRUE-ზე. თუ xTimerStartFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტის დასრულებამდე უნდა შესრულდეს კონტექსტის შეცვლა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerStopFromISR">
<span class="target" id="timers_8h_1aef0f53e7ecfaa881621da83d61072db7"></span><code class="descname">xTimerStopFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerStopFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xTimerStop()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">simply</span> <span class="n">stopped</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">stops</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">simply</span> <span class="n">stop</span> <span class="n">the</span> <span class="n">timer</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
    <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">"FromISR"</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerStopFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">stop</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: გაჩერებული ტაიმერის სახელური.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>ტაიმერის სერვისის/დემონის დავალება დროის უმეტეს ნაწილს დაბლოკილ მდგომარეობაში ატარებს და ელოდება ტაიმერის ბრძანებების რიგში შეტყობინებების მიღებას. xTimerStopFromISR() გამოძახება შეტყობინებას წერს ტაიმერის ბრძანებების რიგში, რაც პოტენციურად იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გადატანას. თუ xTimerStopFromISR() გამოძახება იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გამოსვლას და ტაიმერის სერვისის/დემონის დავალებას აქვს პრიორიტეტი, რომელიც ტოლია ან მეტია ამჟამად შესრულებული დავალების (შეწყვეტილი დავალების) მიმართ, მაშინ *pxHigherPriorityTaskWoken xTimerStopFromISR() ფუნქციის ფარგლებში შიდა დონეზე დაყენდება pdTRUE-ზე. თუ xTimerStopFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტის დასრულებამდე უნდა შესრულდეს კონტექსტის შეცვლა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerChangePeriodFromISR">
<span class="target" id="timers_8h_1a6d89ca6afb6e692e98932b5038c9e14a"></span><code class="descname">xTimerChangePeriodFromISR</code><span class="sig-paren">(</span>xTimer, xNewPeriod, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerChangePeriodFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xTimerChangePeriod()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="ow">and</span> <span class="n">started</span><span class="o">.</span>  <span class="n">When</span>
<span class="o">//</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">occurs</span><span class="p">,</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">should</span> <span class="n">be</span> <span class="n">changed</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">that</span> <span class="n">changes</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vAnExampleInterruptServiceRoutine</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">The</span> <span class="n">interrupt</span> <span class="n">has</span> <span class="n">occurred</span> <span class="o">-</span> <span class="n">change</span> <span class="n">the</span> <span class="n">period</span> <span class="n">of</span> <span class="n">xTimer</span> <span class="n">to</span> <span class="mi">500</span><span class="n">ms</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">where</span> <span class="n">it</span> <span class="n">was</span> <span class="n">defined</span>
    <span class="o">//</span> <span class="p">(</span><span class="n">within</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>  <span class="n">As</span> <span class="n">this</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="p">,</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">"FromISR"</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerChangePeriodFromISR</span><span class="p">(</span> <span class="n">xTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">command</span> <span class="n">to</span> <span class="n">change</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">period</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span>
        <span class="o">//</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>ტაიმერის სახელური, რომლის პერიოდიც იცვლება.</li>
<li><code class="docutils literal notranslate"><span class="pre">xNewPeriod</span></code>xTimer-ის ახალი პერიოდი. ტაიმერის პერიოდები მითითებულია ტიკების პერიოდებში, ამიტომ კონსტანტა portTICK_PERIOD_MS შეიძლება გამოყენებულ იქნას მილიწამებში მითითებული დროის გადასაყვანად. მაგალითად, თუ ტაიმერი უნდა იწურებოდეს 100 ტიკის შემდეგ, მაშინ xNewPeriod უნდა დაყენდეს 100-ზე. ალტერნატიულად, თუ ტაიმერი უნდა იწურებოდეს 500 მილიწამის შემდეგ, მაშინ xNewPeriod შეიძლება დაყენდეს (500 / portTICK_PERIOD_MS) იმ პირობით, რომ configTICK_RATE_HZ ნაკლებია ან ტოლია 1000-ის.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>ტაიმერის სერვისის/დემონის დავალება დროის უმეტეს ნაწილს დაბლოკილ მდგომარეობაში ატარებს და ელოდება ტაიმერის ბრძანებების რიგში შეტყობინებების მიღებას. xTimerChangePeriodFromISR()-ის გამოძახება შეტყობინებას წერს ტაიმერის ბრძანებების რიგში, რაც პოტენციურად იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გადატანას. თუ xTimerChangePeriodFromISR()-ის გამოძახება იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გამოსვლას და ტაიმერის სერვისის/დემონის დავალებას აქვს პრიორიტეტი, რომელიც ტოლია ან მეტია ამჟამად შესრულებული დავალების (შეწყვეტილი დავალების) მიმართ, მაშინ *pxHigherPriorityTaskWoken xTimerChangePeriodFromISR() ფუნქციის ფარგლებში შიდა დონეზე დაყენდება pdTRUE-ზე. თუ xTimerChangePeriodFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტის დასრულებამდე უნდა შესრულდეს კონტექსტის შეცვლა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xTimerResetFromISR">
<span class="target" id="timers_8h_1a448138d0cebf76044f107ca56c842230"></span><code class="descname">xTimerResetFromISR</code><span class="sig-paren">(</span>xTimer, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xTimerResetFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xTimerReset()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტის სერვისის რუტინიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">This</span> <span class="n">scenario</span> <span class="n">assumes</span> <span class="n">xBacklightTimer</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span><span class="o">.</span>  <span class="n">When</span> <span class="n">a</span>
<span class="o">//</span> <span class="n">key</span> <span class="ow">is</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">an</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">on</span><span class="o">.</span>  <span class="n">If</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="k">pass</span>
<span class="o">//</span> <span class="n">without</span> <span class="n">a</span> <span class="n">key</span> <span class="n">being</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">then</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">switched</span> <span class="n">off</span><span class="o">.</span>  <span class="n">In</span>
<span class="o">//</span> <span class="n">this</span> <span class="n">case</span><span class="p">,</span> <span class="n">the</span> <span class="n">timer</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="p">,</span> <span class="ow">and</span> <span class="n">unlike</span> <span class="n">the</span> <span class="n">example</span> <span class="n">given</span> <span class="k">for</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">xTimerReset</span><span class="p">()</span> <span class="n">function</span><span class="p">,</span> <span class="n">the</span> <span class="n">key</span> <span class="n">press</span> <span class="n">event</span> <span class="n">handler</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span>
<span class="o">//</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">callback</span> <span class="n">function</span> <span class="n">assigned</span> <span class="n">to</span> <span class="n">the</span> <span class="n">one</span><span class="o">-</span><span class="n">shot</span> <span class="n">timer</span><span class="o">.</span>  <span class="n">In</span> <span class="n">this</span> <span class="n">case</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vBacklightTimerCallback</span><span class="p">(</span> <span class="n">TimerHandle_t</span> <span class="n">pxTimer</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">timer</span> <span class="n">expired</span><span class="p">,</span> <span class="n">therefore</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">must</span> <span class="n">have</span> <span class="n">passed</span> <span class="n">since</span> <span class="n">a</span> <span class="n">key</span>
    <span class="o">//</span> <span class="n">was</span> <span class="n">pressed</span><span class="o">.</span>  <span class="n">Switch</span> <span class="n">off</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_OFF</span> <span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">key</span> <span class="n">press</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span><span class="o">.</span>
<span class="n">void</span> <span class="n">vKeyPressEventInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">BaseType_t</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">=</span> <span class="n">pdFALSE</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Ensure</span> <span class="n">the</span> <span class="n">LCD</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="ow">is</span> <span class="n">on</span><span class="p">,</span> <span class="n">then</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">that</span> <span class="ow">is</span>
    <span class="o">//</span> <span class="n">responsible</span> <span class="k">for</span> <span class="n">turning</span> <span class="n">the</span> <span class="n">back</span><span class="o">-</span><span class="n">light</span> <span class="n">off</span> <span class="n">after</span> <span class="mi">5</span> <span class="n">seconds</span> <span class="n">of</span>
    <span class="o">//</span> <span class="n">key</span> <span class="n">inactivity</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">interrupt</span> <span class="n">service</span> <span class="n">routine</span> <span class="n">so</span> <span class="n">can</span> <span class="n">only</span>
    <span class="o">//</span> <span class="n">call</span> <span class="n">FreeRTOS</span> <span class="n">API</span> <span class="n">functions</span> <span class="n">that</span> <span class="n">end</span> <span class="ow">in</span> <span class="s2">"FromISR"</span><span class="o">.</span>
    <span class="n">vSetBacklightState</span><span class="p">(</span> <span class="n">BACKLIGHT_ON</span> <span class="p">);</span>

    <span class="o">//</span> <span class="n">xTimerStartFromISR</span><span class="p">()</span> <span class="ow">or</span> <span class="n">xTimerResetFromISR</span><span class="p">()</span> <span class="n">could</span> <span class="n">be</span> <span class="n">called</span> <span class="n">here</span>
    <span class="o">//</span> <span class="k">as</span> <span class="n">both</span> <span class="n">cause</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">to</span> <span class="n">re</span><span class="o">-</span><span class="n">calculate</span> <span class="n">its</span> <span class="n">expiry</span> <span class="n">time</span><span class="o">.</span>
    <span class="o">//</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">was</span> <span class="n">initialised</span> <span class="n">to</span> <span class="n">pdFALSE</span> <span class="n">when</span> <span class="n">it</span> <span class="n">was</span>
    <span class="o">//</span> <span class="n">declared</span> <span class="p">(</span><span class="ow">in</span> <span class="n">this</span> <span class="n">function</span><span class="p">)</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xTimerResetFromISR</span><span class="p">(</span> <span class="n">xBacklightTimer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">xHigherPriorityTaskWoken</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">pdPASS</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">The</span> <span class="n">reset</span> <span class="n">command</span> <span class="n">was</span> <span class="ow">not</span> <span class="n">executed</span> <span class="n">successfully</span><span class="o">.</span>  <span class="n">Take</span> <span class="n">appropriate</span>
        <span class="o">//</span> <span class="n">action</span> <span class="n">here</span><span class="o">.</span>
    <span class="p">}</span>

    <span class="o">//</span> <span class="n">Perform</span> <span class="n">the</span> <span class="n">rest</span> <span class="n">of</span> <span class="n">the</span> <span class="n">key</span> <span class="n">processing</span> <span class="n">here</span><span class="o">.</span>

    <span class="o">//</span> <span class="n">If</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="n">equals</span> <span class="n">pdTRUE</span><span class="p">,</span> <span class="n">then</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="n">should</span> <span class="n">be</span> <span class="n">performed</span><span class="o">.</span>  <span class="n">The</span> <span class="n">syntax</span> <span class="n">required</span> <span class="n">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">context</span> <span class="n">switch</span>
    <span class="o">//</span> <span class="kn">from</span> <span class="nn">inside</span> <span class="n">an</span> <span class="n">ISR</span> <span class="n">varies</span> <span class="kn">from</span> <span class="nn">port</span> <span class="n">to</span> <span class="n">port</span><span class="p">,</span> <span class="ow">and</span> <span class="kn">from</span> <span class="nn">compiler</span> <span class="n">to</span>
    <span class="o">//</span> <span class="n">compiler</span><span class="o">.</span>  <span class="n">Inspect</span> <span class="n">the</span> <span class="n">demos</span> <span class="k">for</span> <span class="n">the</span> <span class="n">port</span> <span class="n">you</span> <span class="n">are</span> <span class="n">using</span> <span class="n">to</span> <span class="n">find</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">actual</span> <span class="n">syntax</span> <span class="n">required</span><span class="o">.</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">xHigherPriorityTaskWoken</span> <span class="o">!=</span> <span class="n">pdFALSE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="o">//</span> <span class="n">Call</span> <span class="n">the</span> <span class="n">interrupt</span> <span class="n">safe</span> <span class="k">yield</span> <span class="n">function</span> <span class="n">here</span> <span class="p">(</span><span class="n">actual</span> <span class="n">function</span>
        <span class="o">//</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FreeRTOS</span> <span class="n">port</span> <span class="n">being</span> <span class="n">used</span><span class="p">)</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xTimer</span></code>: ტაიმერის სახელური, რომელიც უნდა დაიწყოს, გადაყენდეს ან ხელახლა ჩაირთოს.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>ტაიმერის სერვისის/დემონის დავალება დროის უმეტეს ნაწილს დაბლოკილ მდგომარეობაში ატარებს და ელოდება ტაიმერის ბრძანებების რიგში შეტყობინებების მიღებას. xTimerResetFromISR() გამოძახება შეტყობინებას წერს ტაიმერის ბრძანებების რიგში, რაც პოტენციურად იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გადატანას. თუ xTimerResetFromISR() გამოძახება იწვევს ტაიმერის სერვისის/დემონის დავალების დაბლოკილი მდგომარეობიდან გამოსვლას და ტაიმერის სერვისის/დემონის დავალებას აქვს პრიორიტეტი, რომელიც ტოლია ან მეტია ამჟამად შესრულებული დავალების (შეწყვეტილი დავალების) მიმართ, მაშინ *pxHigherPriorityTaskWoken xTimerResetFromISR() ფუნქციის ფარგლებში შიდად დაყენდება pdTRUE-ზე. თუ xTimerResetFromISR() ამ მნიშვნელობას pdTRUE-ზე დააყენებს, მაშინ შეწყვეტის დასრულებამდე უნდა შესრულდეს კონტექსტის შეცვლა.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id11">
<h3>ტიპის განმარტებები<a class="headerlink" href="freertos.html#id11" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv413TimerHandle_t">
<span id="_CPPv313TimerHandle_t"></span><span id="_CPPv213TimerHandle_t"></span><span id="TimerHandle_t"></span><span class="target" id="timers_8h_1aae4bf1dce696ab615d5fd073606fd3cb"></span><em class="property">typedef </em>void *<code class="descname">TimerHandle_t</code><a class="headerlink" href="freertos.html#_CPPv413TimerHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მიუთითეთ, თუ რომელი პროგრამული ტაიმერებით ხდება მათი მითითება. მაგალითად, xTimerCreate() ფუნქციის გამოძახება აბრუნებს TimerHandle_t ცვლადს, რომლის გამოყენებაც შესაძლებელია სხვა პროგრამული ტაიმერის API ფუნქციების გამოძახებისას (მაგალითად, xTimerStart(), xTimerReset() და ა.შ.) მიმართვისას. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv423TimerCallbackFunction_t">
<span id="_CPPv323TimerCallbackFunction_t"></span><span id="_CPPv223TimerCallbackFunction_t"></span><span id="TimerCallbackFunction_t"></span><span class="target" id="timers_8h_1a5cf6d1f61ccd4871022ed8ad454c6027"></span><em class="property">typedef </em>void (*<code class="descname">TimerCallbackFunction_t</code>)<span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv413TimerHandle_t" title="TimerHandle_t">ტაიმერის სახელური_t</a> xTimer<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv423TimerCallbackFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განსაზღვრავს პროტოტიპს, რომელსაც ტაიმერის უკუკავშირის ფუნქციები უნდა შეესაბამებოდეს. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv416PendedFunction_t">
<span id="_CPPv316PendedFunction_t"></span><span id="_CPPv216PendedFunction_t"></span><span id="PendedFunction_t"></span><span class="target" id="timers_8h_1af6e8e2be58df2be9f9bb808fcdc51622"></span><em class="property">typedef </em>void (*<code class="descname">PendedFunction_t</code>)<span class="sig-paren">(</span>void *, uint32_t<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv416PendedFunction_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>განსაზღვრავს პროტოტიპს, რომელსაც უნდა შეესაბამებოდეს xTimerPendFunctionCallFromISR() ფუნქციასთან ერთად გამოყენებული ფუნქციები. </p>
</dd></dl>
</div>
</div>
<div class="section" id="event-group-api">
<h2>ღონისძიებების ჯგუფი, API<a class="headerlink" href="freertos.html#event-group-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id12">
<h3>სათაურის ფაილი<a class="headerlink" href="freertos.html#id12" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/freertos/include/freertos/event_groups.h">freertos/include/freertos/event_groups.h</a></li>
</ul>
</div>
<div class="section" id="id13">
<h3>ფუნქციები<a class="headerlink" href="freertos.html#id13" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv417xEventGroupCreatev">
<span id="_CPPv317xEventGroupCreatev"></span><span id="_CPPv217xEventGroupCreatev"></span><span id="xEventGroupCreate__void"></span><span class="target" id="event__groups_8h_1a7ed741a0902718aca9c8d3ca273f1b73"></span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <code class="descname">xEventGroupCreate</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417xEventGroupCreatev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი ღონისძიებების ჯგუფი.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, მოვლენების ჯგუფები იყენებენ მეხსიერების [მცირე] ბლოკს, რომელშიც ინახება მოვლენების ჯგუფის სტრუქტურა. თუ მოვლენების ჯგუფი იქმნება xEventGroupCreate() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xEventGroupCreate() ფუნქციის ფარგლებში. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ მოვლენების ჯგუფი იქმნება xEventGropuCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც მოვლენების ჯგუფი გამოიყენებს. შესაბამისად, xEventGroupCreateStatic() საშუალებას იძლევა მოვლენების ჯგუფი შეიქმნას დინამიური მეხსიერების განაწილების გარეშე.</p>
<p>მიუხედავად იმისა, რომ მოვლენების ჯგუფები ტიკებთან არ არის დაკავშირებული, შიდა იმპლემენტაციის მიზეზების გამო, მოვლენების ჯგუფში გამოსაყენებლად ხელმისაწვდომი ბიტების რაოდენობა დამოკიდებულია Free RTOS Config.h-ში configUSE_16_BIT_TICKS პარამეტრზე. თუ configUSE_16_BIT_TICKS არის 1, მაშინ თითოეული მოვლენების ჯგუფი შეიცავს 8 გამოსაყენებელ ბიტს (ბიტი 0-დან ბიტ 7-მდე). თუ configUSE_16_BIT_TICKS დაყენებულია 0-ზე, მაშინ თითოეული მოვლენების ჯგუფს აქვს 24 გამოსაყენებელი ბიტი (ბიტი 0-დან ბიტ 23-მდე). EventBits_t ტიპი გამოიყენება მოვლენების ჯგუფში მოვლენების ბიტების შესანახად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Declare a variable to hold the created event group.
EventGroupHandle_t xCreatedEventGroup;

// Attempt to create the event group.
xCreatedEventGroup = xEventGroupCreate();

// Was the event group created successfully?
if( xCreatedEventGroup == NULL )
{
    // The event group was not created because there was insufficient
    // FreeRTOS heap available.
}
else
{
    // The event group was created.
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. See <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a></dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t">
<span id="_CPPv323xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="_CPPv223xEventGroupCreateStaticP18StaticEventGroup_t"></span><span id="xEventGroupCreateStatic__StaticEventGroup_tP"></span><span class="target" id="event__groups_8h_1a19fff40ab0121395db2b2c8a823ec7e6"></span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <code class="descname">xEventGroupCreateStatic</code><span class="sig-paren">(</span>StaticEventGroup_t *<em>pxEventGroupBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv423xEventGroupCreateStaticP18StaticEventGroup_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი ღონისძიებების ჯგუფი.</p>
<p>შინაგანად, Free RTOS იმპლემენტაციის ფარგლებში, მოვლენების ჯგუფები იყენებენ მეხსიერების [მცირე] ბლოკს, რომელშიც ინახება მოვლენების ჯგუფის სტრუქტურა. თუ მოვლენების ჯგუფი იქმნება xEventGropuCreate() ფუნქციის გამოყენებით, მაშინ საჭირო მეხსიერება ავტომატურად დინამიურად გამოიყოფა xEventGroupCreate() ფუნქციის ფარგლებში. (იხ. <a class="reference external" href="http://www.freertos.org/a00111.html">http://www.freertos.org/a00111.html</a>). თუ მოვლენების ჯგუფი იქმნება xEventGropuCreateStatic() ფუნქციის გამოყენებით, მაშინ აპლიკაციის შემქმნელმა უნდა უზრუნველყოს მეხსიერება, რომელსაც მოვლენების ჯგუფი გამოიყენებს. შესაბამისად, xEventGroupCreateStatic() საშუალებას იძლევა მოვლენების ჯგუფი შეიქმნას დინამიური მეხსიერების განაწილების გარეშე.</p>
<p>მიუხედავად იმისა, რომ მოვლენების ჯგუფები ტიკებთან არ არის დაკავშირებული, შიდა იმპლემენტაციის მიზეზების გამო, მოვლენების ჯგუფში გამოსაყენებლად ხელმისაწვდომი ბიტების რაოდენობა დამოკიდებულია Free RTOS Config.h-ში configUSE_16_BIT_TICKS პარამეტრზე. თუ configUSE_16_BIT_TICKS არის 1, მაშინ თითოეული მოვლენების ჯგუფი შეიცავს 8 გამოსაყენებელ ბიტს (ბიტი 0-დან ბიტ 7-მდე). თუ configUSE_16_BIT_TICKS დაყენებულია 0-ზე, მაშინ თითოეული მოვლენების ჯგუფს აქვს 24 გამოსაყენებელი ბიტი (ბიტი 0-დან ბიტ 23-მდე). EventBits_t ტიპი გამოიყენება მოვლენების ჯგუფში მოვლენების ბიტების შესანახად.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">StaticEventGroup_t</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">publicly</span> <span class="n">accessible</span> <span class="n">structure</span> <span class="n">that</span> <span class="n">has</span> <span class="n">the</span> <span class="n">same</span>
<span class="o">//</span> <span class="n">size</span> <span class="ow">and</span> <span class="n">alignment</span> <span class="n">requirements</span> <span class="k">as</span> <span class="n">the</span> <span class="n">real</span> <span class="n">event</span> <span class="n">group</span> <span class="n">structure</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span>
<span class="o">//</span> <span class="n">provided</span> <span class="k">as</span> <span class="n">a</span> <span class="n">mechanism</span> <span class="k">for</span> <span class="n">applications</span> <span class="n">to</span> <span class="n">know</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">event</span>
<span class="o">//</span> <span class="n">group</span> <span class="p">(</span><span class="n">which</span> <span class="ow">is</span> <span class="n">dependent</span> <span class="n">on</span> <span class="n">the</span> <span class="n">architecture</span> <span class="ow">and</span> <span class="n">configuration</span> <span class="n">file</span>
<span class="o">//</span> <span class="n">settings</span><span class="p">)</span> <span class="n">without</span> <span class="n">breaking</span> <span class="n">the</span> <span class="n">strict</span> <span class="n">data</span> <span class="n">hiding</span> <span class="n">policy</span> <span class="n">by</span> <span class="n">exposing</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">real</span> <span class="n">event</span> <span class="n">group</span> <span class="n">internals</span><span class="o">.</span>  <span class="n">This</span> <span class="n">StaticEventGroup_t</span> <span class="n">variable</span> <span class="ow">is</span> <span class="n">passed</span>
<span class="o">//</span> <span class="n">into</span> <span class="n">the</span> <span class="n">xSemaphoreCreateEventGroupStatic</span><span class="p">()</span> <span class="n">function</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">store</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span><span class="s1">'s data structures</span>
<span class="n">StaticEventGroup_t</span> <span class="n">xEventGroupBuffer</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span> <span class="n">without</span> <span class="n">dynamically</span> <span class="n">allocating</span> <span class="nb">any</span> <span class="n">memory</span><span class="o">.</span>
<span class="n">xEventGroup</span> <span class="o">=</span> <span class="n">xEventGroupCreateStatic</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">xEventGroupBuffer</span> <span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the event group was created then a handle to the event group is returned. If pxEventGroupBuffer was NULL then NULL is returned.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pxEventGroupBuffer</span></code>pxEventGroupBuffer უნდა მიუთითებდეს StaticEventGroup_t ტიპის ცვლადზე, რომელიც შემდეგ გამოყენებული იქნება მოვლენათა ჯგუფის მონაცემთა სტრუქტურების შესანახად, რაც გამორიცხავს მეხსიერების დინამიურად გამოყოფის საჭიროებას.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t">
<span id="_CPPv319xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="_CPPv219xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t"></span><span id="xEventGroupWaitBits__EventGroupHandle_t.EventBits_tC.BaseType_tC.BaseType_tC.TickType_t"></span><span class="target" id="event__groups_8h_1aab9d5b405bc57b7624dcabe9a9a503db"></span><a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupWaitBits</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToWaitFor</em>, <em class="property">კონსტ</em> BaseType_t <em>xClearOnExit</em>, <em class="property">კონსტ</em> BaseType_t <em>xWaitForAllBits</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv419xEventGroupWaitBits18EventGroupHandle_tK11EventBits_tK10BaseType_tK10BaseType_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>[პოტენციურად] ბლოკი, რომელიც დაელოდება ერთი ან მეტი ბიტის დაყენებას ადრე შექმნილ მოვლენათა ჯგუფში.</p>
<p>ამ ფუნქციის გამოძახება შეფერხებიდან შეუძლებელია.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>
<span class="n">const</span> <span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span> <span class="k">for</span> <span class="n">either</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span> <span class="n">within</span>
     <span class="o">//</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span><span class="o">.</span>  <span class="n">Clear</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">before</span> <span class="n">exiting</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupWaitBits</span><span class="p">(</span>
                 <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">tested</span><span class="o">.</span>
                 <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span><span class="p">,</span>  <span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">within</span> <span class="n">the</span> <span class="n">event</span> <span class="n">group</span> <span class="n">to</span> <span class="n">wait</span> <span class="k">for</span><span class="o">.</span>
                 <span class="n">pdTRUE</span><span class="p">,</span>         <span class="o">//</span> <span class="n">BIT_0</span> <span class="ow">and</span> <span class="n">BIT_4</span> <span class="n">should</span> <span class="n">be</span> <span class="n">cleared</span> <span class="n">before</span> <span class="n">returning</span><span class="o">.</span>
                 <span class="n">pdFALSE</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Don</span><span class="s1">'t wait for both bits, either bit will do.</span>
                 <span class="n">xTicksToWait</span> <span class="p">);</span> <span class="o">//</span> <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span> <span class="k">for</span> <span class="n">either</span> <span class="n">bit</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">both</span> <span class="n">bits</span> <span class="n">were</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">just</span> <span class="n">BIT_0</span> <span class="n">was</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">just</span> <span class="n">BIT_4</span> <span class="n">was</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">xEventGroupWaitBits</span><span class="p">()</span> <span class="n">returned</span> <span class="n">because</span> <span class="n">xTicksToWait</span> <span class="n">ticks</span> <span class="n">passed</span>
         <span class="o">//</span> <span class="n">without</span> <span class="n">either</span> <span class="n">BIT_0</span> <span class="ow">or</span> <span class="n">BIT_4</span> <span class="n">becoming</span> <span class="nb">set</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
{გ} <dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared in the case that xClearOnExit parameter was set to pdTRUE.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენების ჯგუფი, რომელშიც ბიტები ტესტირდება. მოვლენების ჯგუფი ადრე უნდა შექმნილიყო xEventGroupCreate()-ის გამოძახების გამოყენებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToWaitFor</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს მოვლენების ჯგუფში შესამოწმებელ ბიტზე ან ბიტებზე. მაგალითად, 0 და/ან 2 ბიტის მოლოდინში, uxBitsToWaitFor-ს მნიშვნელობა უნდა მიენიჭოს 0x05-ს. 0 და/ან 1 და/ან 2 ბიტის მოლოდინში, uxBitsToWaitFor-ს მნიშვნელობა უნდა მიენიჭოს 0x07-ს და ა.შ.</li>
<li><code class="docutils literal notranslate"><span class="pre">xClearOnExit</span></code>თუ xClearOnExit დაყენებულია pdTRUE-ზე, მაშინ uxBitsToWaitFor-ში არსებული ნებისმიერი ბიტი, რომელიც დაყენებულია მოვლენების ჯგუფში, წაიშლება xEventGroupWaitBits()-ის დაბრუნებამდე, თუ დაკმაყოფილებულია ლოდინის პირობა (თუ ფუნქცია ბრუნდება ტაიმაუტისგან განსხვავებული მიზეზის გამო). თუ xClearOnExit დაყენებულია pdFALSE-ზე, მაშინ მოვლენების ჯგუფში დაყენებული ბიტები არ იცვლება xEventGroupWaitBits()-ის გამოძახებისას.</li>
<li><code class="docutils literal notranslate"><span class="pre">xWaitForAllBits</span></code>თუ xWaitForAllBits დაყენებულია pdTRUE-ზე, მაშინ xEventGroupWaitBits() დააბრუნებს მნიშვნელობას, როდესაც uxBitsToWaitFor-ში დაყენებული ყველა ბიტი დაყენებულია ან მითითებული ბლოკის დრო ამოიწურება. თუ xWaitForAllBits დაყენებულია pdFALSE-ზე, მაშინ xEventGroupWaitBits() დააბრუნებს მნიშვნელობას, როდესაც uxBitsToWaitFor-ში დაყენებული რომელიმე ბიტი დაყენებულია ან მითითებული ბლოკის დრო ამოიწურება. ბლოკის დრო მითითებულია xTicksToWait პარამეტრით.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო (მითითებულია „ნიშნებში“), რომლის განმავლობაშიც uxBitsToWaitFor-ის მიერ მითითებული ბიტების ერთი/ყველა (xWaitForAllBits მნიშვნელობის მიხედვით) დაყენებას უნდა დაველოდოთ.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv320xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv220xEventGroupClearBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupClearBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a0fb72cfdd4f0d5f86d955fc3af448f2a"></span><a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupClearBits</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToClear</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv420xEventGroupClearBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოვლენების ჯგუფში ბიტების გასუფთავება. ეს ფუნქცია ვერ გამოიძახება შეწყვეტიდან.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Clear</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupClearBits</span><span class="p">(</span>
                             <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                             <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span><span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="n">cleared</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Both</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">were</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">called</span><span class="o">.</span>  <span class="n">Both</span> <span class="n">will</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">set</span><span class="p">)</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span><span class="o">.</span>  <span class="n">It</span> <span class="n">will</span>
         <span class="o">//</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="nb">set</span> <span class="n">before</span> <span class="n">xEventGroupClearBits</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span><span class="o">.</span>  <span class="n">It</span> <span class="n">will</span>
         <span class="o">//</span> <span class="n">now</span> <span class="n">be</span> <span class="n">clear</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Neither</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">nor</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">were</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">first</span> <span class="n">place</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The value of the event group before the specified bits were cleared.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენათა ჯგუფი, რომელშიც ბიტები უნდა გაიწმინდოს.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToClear</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს მოვლენების ჯგუფში გასასუფთავებელ ბიტზე ან ბიტებზე. მაგალითად, მხოლოდ მე-3 ბიტის გასასუფთავებლად, uxBitsToClear დააყენეთ 0x08-ზე. მე-3 ბიტის და 0 ბიტის გასასუფთავებლად, uxBitsToClear დააყენეთ 0x09-ზე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t">
<span id="_CPPv318xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="_CPPv218xEventGroupSetBits18EventGroupHandle_tK11EventBits_t"></span><span id="xEventGroupSetBits__EventGroupHandle_t.EventBits_tC"></span><span class="target" id="event__groups_8h_1a02d7b3bb55f7e11d9c47116266c5fb2e"></span><a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupSetBits</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToSet</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv418xEventGroupSetBits18EventGroupHandle_tK11EventBits_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოვლენების ჯგუფში ბიტების დაყენება. ამ ფუნქციის გამოძახება შეწყვეტიდან შეუძლებელია. xEventGroupSetBitsFromISR() არის ვერსია, რომლის გამოძახებაც შეწყვეტიდან შეიძლება.</p>
<p>მოვლენების ჯგუფში ბიტების დაყენება ავტომატურად განბლოკავს დავალებებს, რომლებიც დაბლოკილია ბიტების მოლოდინში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

<span class="n">void</span> <span class="n">aFunction</span><span class="p">(</span> <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxBits</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
     <span class="n">uxBits</span> <span class="o">=</span> <span class="n">xEventGroupSetBits</span><span class="p">(</span>
                         <span class="n">xEventGroup</span><span class="p">,</span>    <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                         <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span><span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="nb">set</span><span class="o">.</span>

     <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span> <span class="o">==</span> <span class="p">(</span> <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Both</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_0</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">0</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="p">,</span> <span class="n">but</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">cleared</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="n">cleared</span> <span class="n">automatically</span> <span class="k">as</span> <span class="n">a</span>
         <span class="o">//</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">was</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">Blocked</span>
         <span class="o">//</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxBits</span> <span class="o">&amp;</span> <span class="n">BIT_4</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span> <span class="n">when</span> <span class="n">the</span> <span class="n">function</span> <span class="n">returned</span><span class="p">,</span> <span class="n">but</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span>
         <span class="o">//</span> <span class="n">cleared</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="n">cleared</span> <span class="n">automatically</span> <span class="k">as</span> <span class="n">a</span>
         <span class="o">//</span> <span class="n">task</span> <span class="n">that</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">was</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">Blocked</span>
         <span class="o">//</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
     <span class="k">else</span>
     <span class="p">{</span>
         <span class="o">//</span> <span class="n">Neither</span> <span class="n">bit</span> <span class="mi">0</span> <span class="n">nor</span> <span class="n">bit</span> <span class="mi">4</span> <span class="n">remained</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">It</span> <span class="n">might</span> <span class="n">be</span> <span class="n">that</span> <span class="n">a</span> <span class="n">task</span>
         <span class="o">//</span> <span class="n">was</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">both</span> <span class="n">of</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">to</span> <span class="n">be</span> <span class="nb">set</span><span class="p">,</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">bits</span> <span class="n">were</span>
         <span class="o">//</span> <span class="n">cleared</span> <span class="k">as</span> <span class="n">the</span> <span class="n">task</span> <span class="n">left</span> <span class="n">the</span> <span class="n">Blocked</span> <span class="n">state</span><span class="o">.</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
{გ} <dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The value of the event group at the time the call to xEventGroupSetBits() returns. There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared. First, if setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will be cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()). Second, any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენათა ჯგუფი, რომელშიც ბიტები უნდა დაყენდეს.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს დასაყენებელ ბიტზე ან ბიტებზე. მაგალითად, მხოლოდ მე-3 ბიტის დასაყენებლად, uxBitsToSet დააყენეთ 0x08-ზე. მე-3 ბიტის და 0 ბიტის დასაყენებლად, uxBitsToSet დააყენეთ 0x09-ზე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t">
<span id="_CPPv315xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="_CPPv215xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t"></span><span id="xEventGroupSync__EventGroupHandle_t.EventBits_tC.EventBits_tC.TickType_t"></span><span class="target" id="event__groups_8h_1a869511456b86426f52e2eec898bff341"></span><a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupSync</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em>, <em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToSet</em>, <em class="property">კონსტ</em> <a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <em>uxBitsToWaitFor</em>, TickType_t <em>xTicksToWait</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv415xEventGroupSync18EventGroupHandle_tK11EventBits_tK11EventBits_t10TickType_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ატომურად დააყენეთ ბიტები მოვლენების ჯგუფში, შემდეგ დაელოდეთ ბიტების კომბინაციის დაყენებას იმავე მოვლენების ჯგუფში. ეს ფუნქციონალი, როგორც წესი, გამოიყენება მრავალი დავალების სინქრონიზაციისთვის, სადაც თითოეულმა დავალებამ უნდა დაელოდოს სხვა დავალებების სინქრონიზაციის წერტილამდე გაგრძელებამდე.</p>
<p>ეს ფუნქცია არ შეიძლება გამოყენებულ იქნას შეფერხებიდან.</p>
<p>ფუნქცია დაბრუნდება მისი ბლოკის დროის ამოწურვამდე, თუ uxBitsToWait პარამეტრით მითითებული ბიტები დაყენდება ან დაყენდება ამ დროის განმავლობაში. ამ შემთხვევაში, uxBitsToWait-ით მითითებული ყველა ბიტი ავტომატურად წაიშლება ფუნქციის დაბრუნებამდე.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Bits</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">three</span> <span class="n">tasks</span><span class="o">.</span>
<span class="c1">#define TASK_0_BIT     ( 1 &lt;&lt; 0 )</span>
<span class="c1">#define TASK_1_BIT     ( 1 &lt;&lt; 1 )</span>
<span class="c1">#define TASK_2_BIT     ( 1 &lt;&lt; 2 )</span>

<span class="c1">#define ALL_SYNC_BITS ( TASK_0_BIT | TASK_1_BIT | TASK_2_BIT )</span>

<span class="o">//</span> <span class="n">Use</span> <span class="n">an</span> <span class="n">event</span> <span class="n">group</span> <span class="n">to</span> <span class="n">synchronise</span> <span class="n">three</span> <span class="n">tasks</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">assumed</span> <span class="n">this</span> <span class="n">event</span>
<span class="o">//</span> <span class="n">group</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="n">elsewhere</span><span class="o">.</span>
<span class="n">EventGroupHandle_t</span> <span class="n">xEventBits</span><span class="p">;</span>

<span class="n">void</span> <span class="n">vTask0</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
<span class="n">EventBits_t</span> <span class="n">uxReturn</span><span class="p">;</span>
<span class="n">TickType_t</span> <span class="n">xTicksToWait</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="n">portTICK_PERIOD_MS</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">sync</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span> <span class="n">bits</span> <span class="n">defined</span>
       <span class="o">//</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span> <span class="n">synchronisation</span>
       <span class="o">//</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span> <span class="n">a</span> <span class="n">maximum</span> <span class="n">of</span> <span class="mi">100</span><span class="n">ms</span>
       <span class="o">//</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">uxReturn</span> <span class="o">=</span> <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_0_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">xTicksToWait</span> <span class="p">);</span>

       <span class="k">if</span><span class="p">(</span> <span class="p">(</span> <span class="n">uxReturn</span> <span class="o">&amp;</span> <span class="n">ALL_SYNC_BITS</span> <span class="p">)</span> <span class="o">==</span> <span class="n">ALL_SYNC_BITS</span> <span class="p">)</span>
       <span class="p">{</span>
           <span class="o">//</span> <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">reached</span> <span class="n">the</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">before</span> <span class="n">the</span> <span class="n">call</span>
           <span class="o">//</span> <span class="n">to</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">timed</span> <span class="n">out</span><span class="o">.</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vTask1</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span>
       <span class="o">//</span> <span class="n">bits</span> <span class="n">defined</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span>
       <span class="o">//</span> <span class="n">indefinitely</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_1_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">portMAX_DELAY</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span> <span class="k">with</span> <span class="n">an</span> <span class="n">indefinite</span> <span class="n">block</span> <span class="n">time</span><span class="p">,</span> <span class="n">so</span>
       <span class="o">//</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">only</span> <span class="n">reach</span> <span class="n">here</span> <span class="k">if</span> <span class="n">the</span> <span class="n">syncrhonisation</span> <span class="n">was</span> <span class="n">made</span> <span class="n">by</span> <span class="nb">all</span>
       <span class="o">//</span> <span class="n">three</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">test</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span><span class="o">.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">void</span> <span class="n">vTask2</span><span class="p">(</span> <span class="n">void</span> <span class="o">*</span><span class="n">pvParameters</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span> <span class="p">;;</span> <span class="p">)</span>
    <span class="p">{</span>
       <span class="o">//</span> <span class="n">Perform</span> <span class="n">task</span> <span class="n">functionality</span> <span class="n">here</span><span class="o">.</span>

       <span class="o">//</span> <span class="n">Set</span> <span class="n">bit</span> <span class="mi">2</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">event</span> <span class="n">flag</span> <span class="n">to</span> <span class="n">note</span> <span class="n">this</span> <span class="n">task</span> <span class="n">has</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span><span class="o">.</span>  <span class="n">The</span> <span class="n">other</span> <span class="n">two</span> <span class="n">tasks</span> <span class="n">will</span> <span class="nb">set</span> <span class="n">the</span> <span class="n">other</span> <span class="n">two</span>
       <span class="o">//</span> <span class="n">bits</span> <span class="n">defined</span> <span class="n">by</span> <span class="n">ALL_SYNC_BITS</span><span class="o">.</span>  <span class="n">All</span> <span class="n">three</span> <span class="n">tasks</span> <span class="n">have</span> <span class="n">reached</span> <span class="n">the</span>
       <span class="o">//</span> <span class="n">synchronisation</span> <span class="n">point</span> <span class="n">when</span> <span class="nb">all</span> <span class="n">the</span> <span class="n">ALL_SYNC_BITS</span> <span class="n">are</span> <span class="nb">set</span><span class="o">.</span>  <span class="n">Wait</span>
       <span class="o">//</span> <span class="n">indefinitely</span> <span class="k">for</span> <span class="n">this</span> <span class="n">to</span> <span class="n">happen</span><span class="o">.</span>
       <span class="n">xEventGroupSync</span><span class="p">(</span> <span class="n">xEventBits</span><span class="p">,</span> <span class="n">TASK_2_BIT</span><span class="p">,</span> <span class="n">ALL_SYNC_BITS</span><span class="p">,</span> <span class="n">portMAX_DELAY</span> <span class="p">);</span>

       <span class="o">//</span> <span class="n">xEventGroupSync</span><span class="p">()</span> <span class="n">was</span> <span class="n">called</span> <span class="k">with</span> <span class="n">an</span> <span class="n">indefinite</span> <span class="n">block</span> <span class="n">time</span><span class="p">,</span> <span class="n">so</span>
       <span class="o">//</span> <span class="n">this</span> <span class="n">task</span> <span class="n">will</span> <span class="n">only</span> <span class="n">reach</span> <span class="n">here</span> <span class="k">if</span> <span class="n">the</span> <span class="n">syncrhonisation</span> <span class="n">was</span> <span class="n">made</span> <span class="n">by</span> <span class="nb">all</span>
       <span class="o">//</span> <span class="n">three</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">so</span> <span class="n">there</span> <span class="ow">is</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">test</span> <span class="n">the</span> <span class="k">return</span> <span class="n">value</span><span class="o">.</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The value of the event group at the time either the bits being waited for became set, or the block time expired. Test the return value to know which bits were set. If xEventGroupSync() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupSync() returned because all the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენების ჯგუფი, რომელშიც ბიტები ტესტირდება. მოვლენების ჯგუფი ადრე უნდა შექმნილიყო xEventGroupCreate()-ის გამოძახების გამოყენებით.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>: მოვლენების ჯგუფში დასაყენებელი ბიტები, სანამ დადგინდება, დაყენებულია თუ არა და შესაძლოა ელოდება თუ არა uxBitsToWait პარამეტრით მითითებული ყველა ბიტი.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToWaitFor</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს მოვლენების ჯგუფში შესამოწმებელ ბიტზე ან ბიტებზე. მაგალითად, 0 ბიტის და 2 ბიტის მოლოდინში, uxBitsToWaitFor-ს მნიშვნელობა უნდა მიენიჭოს 0x05-ს. 0 ბიტის, 1 ბიტის და 2 ბიტის მოლოდინში, uxBitsToWaitFor-ს მნიშვნელობა უნდა მიენიჭოს 0x07-ს და ა.შ.</li>
<li><code class="docutils literal notranslate"><span class="pre">xTicksToWait</span></code>: მაქსიმალური დრო (მითითებულია &amp;#39;ticks&amp;#39;-ში) uxBitsToWaitFor-ის მიერ მითითებული ყველა ბიტის დაყენების მოლოდინის მიზნით.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t">
<span id="_CPPv325xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="_CPPv225xEventGroupGetBitsFromISR18EventGroupHandle_t"></span><span id="xEventGroupGetBitsFromISR__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1adcb3d3f7dded9fa372bb1ee405c36b8d"></span><a class="reference internal" href="freertos.html#_CPPv411EventBits_t" title="EventBits_t">EventBits_t</a> <code class="descname">xEventGroupGetBitsFromISR</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv425xEventGroupGetBitsFromISR18EventGroupHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>xEventGroupGetBits()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია ISR-დან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The event group bits at the time xEventGroupGetBitsFromISR() was called. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენების ჯგუფი, რომელზეც მოთხოვნა იგზავნება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv417vEventGroupDelete18EventGroupHandle_t">
<span id="_CPPv317vEventGroupDelete18EventGroupHandle_t"></span><span id="_CPPv217vEventGroupDelete18EventGroupHandle_t"></span><span id="vEventGroupDelete__EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1a6939faca89fc4ba52fa8288527042464"></span>void <code class="descname">vEventGroupDelete</code><span class="sig-paren">(</span><a class="reference internal" href="freertos.html#_CPPv418EventGroupHandle_t" title="EventGroupHandle_t">EventGroupHandle_t</a> <em>xEventGroup</em><span class="sig-paren">)</span><a class="headerlink" href="freertos.html#_CPPv417vEventGroupDelete18EventGroupHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>წაშალეთ მოვლენების ჯგუფი, რომელიც ადრე შეიქმნა xEventGroupCreate()-ის გამოძახებით. მოვლენების ჯგუფში დაბლოკილი დავალებები განიბლოკება და მოვლენების ჯგუფის მნიშვნელობად 0-ს მიიღებს.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: ღონისძიებების ჯგუფი წაიშლება. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id14">
<h3>მაკროები<a class="headerlink" href="freertos.html#id14" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.xEventGroupClearBitsFromISR">
<span class="target" id="event__groups_8h_1a3d7de214a697f33fe7b914e26a93f33a"></span><code class="descname">xEventGroupClearBitsFromISR</code><span class="sig-paren">(</span>xEventGroup, uxBitsToClear<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xEventGroupClearBitsFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xEventGroupClearBits()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტიდან.</p>
<p>მოვლენების ჯგუფში ბიტების დაყენება არ არის დეტერმინისტული ოპერაცია, რადგან არსებობს დავალებების უცნობი რაოდენობა, რომლებიც შეიძლება ელოდებოდნენ ბიტის ან ბიტების დაყენებას. თავისუფალი RTOS არ იძლევა არადეტერმინისტული ოპერაციების შესრულების საშუალებას, როდესაც შეწყვეტები გამორთულია, ამიტომ იცავს დავალებებიდან წვდომადი მოვლენების ჯგუფებს დამგეგმავის შეჩერებით, შეწყვეტების გამორთვის ნაცვლად. შედეგად, მოვლენების ჯგუფებზე წვდომა შეუძლებელია უშუალოდ შეწყვეტის სერვისის რუტინიდან. ამიტომ, xEventGroupClearBitsFromISR() უგზავნის შეტყობინებას ტაიმერის დავალებას, რათა შესრულდეს გასუფთავების ოპერაცია ტაიმერის დავალების კონტექსტში.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="c1">#define BIT_0    ( 1 &lt;&lt; 0 )</span>
 <span class="c1">#define BIT_4    ( 1 &lt;&lt; 4 )</span>

 <span class="o">//</span> <span class="n">An</span> <span class="n">event</span> <span class="n">group</span> <span class="n">which</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">assumed</span> <span class="n">has</span> <span class="n">already</span> <span class="n">been</span> <span class="n">created</span> <span class="n">by</span> <span class="n">a</span> <span class="n">call</span> <span class="n">to</span>
 <span class="o">//</span> <span class="n">xEventGroupCreate</span><span class="p">()</span><span class="o">.</span>
 <span class="n">EventGroupHandle_t</span> <span class="n">xEventGroup</span><span class="p">;</span>

 <span class="n">void</span> <span class="n">anInterruptHandler</span><span class="p">(</span> <span class="n">void</span> <span class="p">)</span>
 <span class="p">{</span>
      <span class="o">//</span> <span class="n">Clear</span> <span class="n">bit</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">bit</span> <span class="mi">4</span> <span class="ow">in</span> <span class="n">xEventGroup</span><span class="o">.</span>
      <span class="n">xResult</span> <span class="o">=</span> <span class="n">xEventGroupClearBitsFromISR</span><span class="p">(</span>
                          <span class="n">xEventGroup</span><span class="p">,</span>     <span class="o">//</span> <span class="n">The</span> <span class="n">event</span> <span class="n">group</span> <span class="n">being</span> <span class="n">updated</span><span class="o">.</span>
                          <span class="n">BIT_0</span> <span class="o">|</span> <span class="n">BIT_4</span> <span class="p">);</span> <span class="o">//</span> <span class="n">The</span> <span class="n">bits</span> <span class="n">being</span> <span class="nb">set</span><span class="o">.</span>

      <span class="k">if</span><span class="p">(</span> <span class="n">xResult</span> <span class="o">==</span> <span class="n">pdPASS</span> <span class="p">)</span>
      <span class="p">{</span>
          <span class="o">//</span> <span class="n">The</span> <span class="n">message</span> <span class="n">was</span> <span class="n">posted</span> <span class="n">successfully</span><span class="o">.</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენათა ჯგუფი, რომელშიც ბიტები უნდა გაიწმინდოს.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToClear</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს გასასუფთავებელ ბიტზე ან ბიტებზე. მაგალითად, მხოლოდ მე-3 ბიტის გასასუფთავებლად, uxBitsToClear დააყენეთ 0x08-ზე. მე-3 ბიტის და 0 ბიტის გასასუფთავებლად, uxBitsToClear დააყენეთ 0x09-ზე.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xEventGroupSetBitsFromISR">
<span class="target" id="event__groups_8h_1a62b68278abac6358369ae8e390988a02"></span><code class="descname">xEventGroupSetBitsFromISR</code><span class="sig-paren">(</span>xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xEventGroupSetBitsFromISR" title="Permalink to this definition">¶</a></dt>
<dd><p>xEventGroupSetBits()-ის ვერსია, რომლის გამოძახებაც შესაძლებელია შეწყვეტიდან.</p>
<p>მოვლენების ჯგუფში ბიტების დაყენება არ არის დეტერმინისტული ოპერაცია, რადგან არსებობს დავალებების უცნობი რაოდენობა, რომლებიც შეიძლება ელოდებოდეს ბიტის ან ბიტების დაყენებას. თავისუფალი RTOS არ იძლევა არადეტერმინისტული ოპერაციების შესრულების საშუალებას შეფერხებებში ან კრიტიკული სექციებიდან. ამიტომ, xEventGroupSetBitFromISR() უგზავნის შეტყობინებას ტაიმერის დავალებას, რათა ტაიმერის დავალების კონტექსტში შესრულდეს დაყენების ოპერაცია - სადაც კრიტიკული სექციის ნაცვლად გამოიყენება დამგეგმავის საკეტი.</p>
<p><p>გამოყენების მაგალითი: </p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> #define BIT_0    ( 1 &lt;&lt; 0 )
 #define BIT_4    ( 1 &lt;&lt; 4 )

 // An event group which it is assumed has already been created by a call to
 // xEventGroupCreate().
 EventGroupHandle_t xEventGroup;

 void anInterruptHandler( void )
 {
 BaseType_t xHigherPriorityTaskWoken, xResult;

      // xHigherPriorityTaskWoken must be initialised to pdFALSE.
      xHigherPriorityTaskWoken = pdFALSE;

      // Set bit 0 and bit 4 in xEventGroup.
      xResult = xEventGroupSetBitsFromISR(
                          xEventGroup,    // The event group being updated.
                          BIT_0 | BIT_4   // The bits being set.
                          &amp;xHigherPriorityTaskWoken );

      // Was the message posted successfully?
      if( xResult == pdPASS )
      {
          // If xHigherPriorityTaskWoken is now set to pdTRUE then a context
          // switch should be requested.  The macro used is port specific and
          // will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -
          // refer to the documentation page for the port being used.
          portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
      }
}
</pre></div>
</div>
<dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>If the request to execute the function was posted successfully then pdPASS is returned, otherwise pdFALSE is returned. pdFALSE will be returned if the timer service queue was full.</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენათა ჯგუფი, რომელშიც ბიტები უნდა დაყენდეს.</li>
<li><code class="docutils literal notranslate"><span class="pre">uxBitsToSet</span></code>ბიტური მნიშვნელობა, რომელიც მიუთითებს დასაყენებელ ბიტზე ან ბიტებზე. მაგალითად, მხოლოდ მე-3 ბიტის დასაყენებლად, uxBitsToSet დააყენეთ 0x08-ზე. მე-3 ბიტის და 0 ბიტის დასაყენებლად, uxBitsToSet დააყენეთ 0x09-ზე.</li>
<li><code class="docutils literal notranslate"><span class="pre">pxHigherPriorityTaskWoken</span></code>როგორც ზემოთ აღინიშნა, ამ ფუნქციის გამოძახების შედეგად ტაიმერის დემონის დავალებაში გაიგზავნება შეტყობინება. თუ ტაიმერის დემონის დავალების პრიორიტეტი უფრო მაღალია, ვიდრე ამჟამად შესრულებული დავალების პრიორიტეტი (დავალება, რომელიც შეფერხების შედეგად შეწყდა), მაშინ *pxHigherPriorityTaskWoken xEventGroupSetBitsFromISR()-ის მიერ დაყენდება pdTRUE-ზე, რაც მიუთითებს, რომ შეფერხების დასრულებამდე უნდა მოითხოვონ კონტექსტის შეცვლა. ამ მიზეზით, *pxHigherPriorityTaskWoken უნდა იყოს ინიციალიზებული pdFALSE-ზე. იხილეთ ქვემოთ მოცემული მაგალითის კოდი.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="macro">
<dt id="c.xEventGroupGetBits">
<span class="target" id="event__groups_8h_1a0ae86f092fb07ccb475ae938f9a12584"></span><code class="descname">xEventGroupGetBits</code><span class="sig-paren">(</span>xEventGroup<span class="sig-paren">)</span><a class="headerlink" href="freertos.html#c.xEventGroupGetBits" title="Permalink to this definition">¶</a></dt>
<dd><p>აბრუნებს მოვლენების ჯგუფში ბიტების მიმდინარე მნიშვნელობას. ეს ფუნქცია არ შეიძლება გამოყენებულ იქნას შეწყვეტიდან.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd>The event group bits at the time xEventGroupGetBits() was called. </dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xEventGroup</span></code>: მოვლენების ჯგუფი, რომელზეც მოთხოვნა იგზავნება.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id15">
<h3>ტიპის განმარტებები<a class="headerlink" href="freertos.html#id15" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv418EventGroupHandle_t">
<span id="_CPPv318EventGroupHandle_t"></span><span id="_CPPv218EventGroupHandle_t"></span><span id="EventGroupHandle_t"></span><span class="target" id="event__groups_8h_1a5119294106541c4eca46e8742fdb4e85"></span><em class="property">typedef </em>void *<code class="descname">EventGroupHandle_t</code><a class="headerlink" href="freertos.html#_CPPv418EventGroupHandle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><p>მოვლენების ჯგუფი არის ბიტების ერთობლიობა, რომელსაც აპლიკაციას შეუძლია მიანიჭოს მნიშვნელობა. მაგალითად, აპლიკაციამ შეიძლება შექმნას მოვლენების ჯგუფი CAN ავტობუსთან დაკავშირებული სხვადასხვა მოვლენების სტატუსის გადასაცემად, რომლებშიც ბიტი 0 შეიძლება ნიშნავდეს „CAN“-ს.</p>
<p>„შეტყობინება მიღებულია და მზადაა დასამუშავებლად“, ბიტი 1 შეიძლება ნიშნავდეს „აპლიკაციამ რიგში დააყენა შეტყობინება, რომელიც მზადაა გასაგზავნად CAN ქსელში“, ხოლო ბიტი 2 შეიძლება ნიშნავდეს „დროა, გავგზავნოთ SYNC შეტყობინება CAN ქსელში“ და ა.შ. შემდეგ დავალებას შეუძლია შეამოწმოს ბიტების მნიშვნელობები იმის სანახავად, თუ რომელი მოვლენებია აქტიური და სურვილისამებრ შევიდეს დაბლოკილ მდგომარეობაში, რათა დაელოდოს მითითებული ბიტის ან მითითებული ბიტების ჯგუფის გააქტიურებას. CAN ავტობუსის მაგალითის გასაგრძელებლად, CAN-ის მაკონტროლებელ დავალებას შეუძლია შევიდეს დაბლოკილ მდგომარეობაში (და შესაბამისად, არ დახარჯოს დამუშავების დრო) მანამ, სანამ ბიტი 0, ბიტი 1 ან ბიტი 2 არ იქნება აქტიური, რომლის დროსაც რეალურად აქტიური ბიტი აცნობებს დავალებას, თუ რომელი ქმედება უნდა შეასრულოს (მიღებული შეტყობინების დამუშავება, შეტყობინების გაგზავნა ან SYNC-ის გაგზავნა).</p>
</p>
<p>მოვლენათა ჯგუფების იმპლემენტაცია შეიცავს ინტელექტს, რათა თავიდან აიცილოს რბოლის პირობები, რომლებიც სხვა შემთხვევაში წარმოიშობოდა, თუ აპლიკაცია იმავე მიზნით გამოიყენებდა მარტივ ცვლადს. ეს განსაკუთრებით მნიშვნელოვანია იმ შემთხვევაში, თუ როდის უნდა გაიწმინდოს მოვლენათა ჯგუფის ბიტი და როდის უნდა დაყენდეს და შემდეგ ატომურად შემოწმდეს ბიტები - როგორც ეს ხდება მაშინ, როდესაც მოვლენათა ჯგუფები გამოიყენება მრავალ დავალებას შორის სინქრონიზაციის წერტილის („შეხვედრის“) შესაქმნელად. event_groups.h</p>
<p>აკრიფეთ, თუ რომელი მოვლენების ჯგუფების მითითება ხდება. მაგალითად, xEventGroupCreate()-ის გამოძახება აბრუნებს EventGroupHandle_t ცვლადს, რომლის გამოყენებაც შემდეგ შესაძლებელია სხვა მოვლენების ჯგუფების ფუნქციების პარამეტრად. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv411EventBits_t">
<span id="_CPPv311EventBits_t"></span><span id="_CPPv211EventBits_t"></span><span id="EventBits_t"></span><span class="target" id="event__groups_8h_1ab2f21b93db0b2a0ab64d7a81ff32ac2e"></span><em class="property">typedef </em>TickType_t <code class="descname">EventBits_t</code><a class="headerlink" href="freertos.html#_CPPv411EventBits_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="freertos_additions.html" rel="next" title="FreeRTOS Additions">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="esp_event_legacy.html" rel="prev" title="Legacy event loop"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (Shanghai) CO., LTD
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>