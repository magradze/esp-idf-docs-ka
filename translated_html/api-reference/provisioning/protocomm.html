
<!DOCTYPE html>

<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>პროტოკოლის კომუნიკაცია — ESP-IDF პროგრამირების სახელმძღვანელო v4.1-dev-2071-gf91080637 დოკუმენტაცია</title>
<script src="../../_static/js/modernizr.min.js" type="text/javascript"></script>
<script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js" type="text/javascript"></script>
<script src="../../_static/jquery.js" type="text/javascript"></script>
<script src="../../_static/underscore.js" type="text/javascript"></script>
<script src="../../_static/doctools.js" type="text/javascript"></script>
<script src="../../_static/language_data.js" type="text/javascript"></script>
<script src="https://media.readthedocs.com/javascript/readthedocs-doc-embed.js" type="text/javascript"></script>
<script src="../../_static/js/theme.js" type="text/javascript"></script>
<link href="../../_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../../_static/theme_overrides.css" rel="stylesheet" type="text/css"/>
<link href="../../about.html" rel="author" title="About these documents"/>
<link href="../../genindex.html" rel="index" title="Index"/>
<link href="../../search.html" rel="search" title="Search"/>
<link href="provisioning.html" rel="next" title="Unified Provisioning"/>
<link href="index.html" rel="prev" title="Provisioning API"/>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/provisioning/protocomm.html" rel="canonical"/>
<link href="https://media.readthedocs.com/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="../../_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = "api-reference/provisioning/protocomm"
READTHEDOCS_DATA['source_suffix'] = ".rst"
</script>
<script src="https://media.readthedocs.com/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
<script async="" src="../../../../../../_/static/javascript/readthedocs-addons.js" type="text/javascript"></script><meta content="espressif-esp-idf" name="readthedocs-project-slug"><meta content="latest" name="readthedocs-version-slug"><meta content="/api-reference/provisioning/protocomm.html" name="readthedocs-resolver-filename"/><meta content="200" name="readthedocs-http-status"/></meta></meta></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../index.html"> ESP-IDF პროგრამირების სახელმძღვანელო
          

          
            
            <img alt="Logo" class="logo" src="../../_static/espressif-logo.svg"/>
</a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../get-started/index.html">დაწყება</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API მითითება</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../bluetooth/index.html">Bluetooth</a></li>
<li class="toctree-l2"><a class="reference internal" href="../network/index.html">ქსელური მუშაობა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../peripherals/index.html">პერიფერიული მოწყობილობები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../protocols/index.html">პროტოკოლები</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">უზრუნველყოფა</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="protocomm.html#">პროტოკოლის კომუნიკაცია</a><ul>
<li class="toctree-l4"><a class="reference internal" href="protocomm.html#overview">მიმოხილვა</a></li>
<li class="toctree-l4"><a class="reference internal" href="protocomm.html#transport-example-softap-http-with-security-1">ტრანსპორტირების მაგალითი (SoftAP + HTTP) Security 1-ით</a></li>
<li class="toctree-l4"><a class="reference internal" href="protocomm.html#transport-example-ble-with-security-0">ტრანსპორტის მაგალითი (BLE) უსაფრთხოების 0-ით</a></li>
<li class="toctree-l4"><a class="reference internal" href="protocomm.html#api-reference">API მითითება</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="provisioning.html">ერთიანი უზრუნველყოფა</a></li>
<li class="toctree-l3"><a class="reference internal" href="wifi_provisioning.html">Wi-Fi უზრუნველყოფა</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../storage/index.html">შენახვა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../system/index.html">სისტემა</a></li>
<li class="toctree-l2"><a class="reference internal" href="../kconfig.html">კონფიგურაციის პარამეტრები</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error-codes.html">შეცდომის კოდების მითითება</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../hw-reference/index.html">ტექნიკის/საშუალებების მითითება</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../esp32s2.html">ESP32-S2-ის წინასწარი გადახედვის მხარდაჭერა</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api-guides/index.html">API სახელმძღვანელოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libraries-and-frameworks/index.html">ბიბლიოთეკები და ჩარჩოები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">წვლილი შეიტანეთ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../versions.html">ვერსიები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../resources.html">რესურსები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../COPYRIGHT.html">საავტორო უფლებები</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">შესახებ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../languages.html">语言/ენები</a></li>
<li class="toctree-l1"><a class="reference external" href="https://readthedocs.com/projects/espressif-esp-idf/downloads/">სახელმძღვანელოს ჩამოტვირთვები</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../index.html">ESP-IDF პროგრამირების სახელმძღვანელო</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="../../index.html">დოკუმენტები</a> »</li>
<li><a href="../index.html">API მითითება</a> »</li>
<li><a href="index.html">უზრუნველყოფის API</a> »</li>
<li>პროტოკოლის კომუნიკაცია</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/espressif/esp-idf/blob/master/docs/en/api-reference/provisioning/protocomm.rst"> რედაქტირება GitHub-ზე</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="protocol-communication">
<h1>პროტოკოლის კომუნიკაცია<a class="headerlink" href="protocomm.html#protocol-communication" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>მიმოხილვა<a class="headerlink" href="protocomm.html#overview" title="Permalink to this headline">¶</a></h2>
<p>პროტოკოლის კომუნიკაციის (protocomm) კომპონენტი მართავს უსაფრთხო სესიებს და უზრუნველყოფს ჩარჩო მრავალი ტრანსპორტისთვის. აპლიკაციას ასევე შეუძლია პირდაპირ გამოიყენოს protocomm ფენა, რათა ჰქონდეს აპლიკაციის სპეციფიკური გაფართოებები უზრუნველყოფის (ან არაუზრუნველყოფის) გამოყენების შემთხვევებისთვის.</p>
<dl class="docutils">
<dt>Following features are available for provisioning :</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>Communication security at application level -</dt>
<dd><ul class="first last">
<li>protocomm_security0 (უსაფრთხოება არ არის)</li>
<li>protocomm_security1 (curve25519 გასაღების გაცვლა + AES-CTR დაშიფვრა)</li>
</ul>
</dd>
</dl>
</li>
<li>ფლობის დამადასტურებელი საბუთი (მხოლოდ protocomm_security1-ის მხარდაჭერა)</li>
</ul>
</dd>
</dl>
<p>Protocomm შიდა სისტემაში იყენებს protobuf-ს (პროტოკოლის ბუფერებს) უსაფრთხო სესიის დასამყარებლად. თუმცა მომხმარებლებს შეუძლიათ საკუთარი უსაფრთხოების დანერგვა (protobuf-ის გამოყენების გარეშეც კი). protocomm-ის გამოყენება შესაძლებელია უსაფრთხოების ფენის გარეშეც კი.</p>
<p>Protocomm უზრუნველყოფს ჩარჩო სხვადასხვა ტრანსპორტირებისთვის - WiFi (SoftAP+HTTPD), BLE, კონსოლი - ამ შემთხვევაში, დამმუშავებლის გამოძახება ავტომატურად სრულდება მოწყობილობის მხარეს (კოდის ფრაგმენტებისთვის იხილეთ ტრანსპორტის მაგალითები ქვემოთ).</p>
<p>გაითვალისწინეთ, რომ კლიენტს კვლავ სჭირდება სესიის დამყარება (მხოლოდ protocomm_security1-ისთვის) ორმხრივი კავშირის შესრულებით. იხილეთ <a class="reference internal" href="provisioning.html"><span class="doc">ერთიანი უზრუნველყოფა</span></a> უსაფრთხო ხელის შეხების ლოგიკის შესახებ დამატებითი ინფორმაციისთვის.</p>
</div>
<div class="section" id="transport-example-softap-http-with-security-1">
<h2>ტრანსპორტირების მაგალითი (SoftAP + HTTP) Security 1-ით<a class="headerlink" href="protocomm.html#transport-example-softap-http-with-security-1" title="Permalink to this headline">¶</a></h2>
<p>სრული მაგალითისთვის იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/provisioning/softap_prov">უზრუნველყოფა/softap_prov</a></p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Endpoint handler to be registered with protocomm.</span>
<span class="cm"> * This simply echoes back the received data. */</span>
<span class="n">esp_err_t</span> <span class="nf">echo_req_handler</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">session_id</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">inbuf</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="n">inlen</span><span class="p">,</span>
                            <span class="kt">uint8_t</span> <span class="o">**</span><span class="n">outbuf</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="o">*</span><span class="n">outlen</span><span class="p">,</span>
                            <span class="kt">void</span> <span class="o">*</span><span class="n">priv_data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Session ID may be used for persistence */</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Session ID : %d"</span><span class="p">,</span> <span class="n">session_id</span><span class="p">);</span>

    <span class="cm">/* Echo back the received data */</span>
    <span class="o">*</span><span class="n">outlen</span> <span class="o">=</span> <span class="n">inlen</span><span class="p">;</span>            <span class="cm">/* Output data length updated */</span>
    <span class="o">*</span><span class="n">outbuf</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">inlen</span><span class="p">);</span>    <span class="cm">/* This will be deallocated outside */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">outbuf</span><span class="p">,</span> <span class="n">inbuf</span><span class="p">,</span> <span class="n">inlen</span><span class="p">);</span>

    <span class="cm">/* Private data that was passed at the time of endpoint creation */</span>
    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">priv_data</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">priv</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Private data : %d"</span><span class="p">,</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ESP_OK</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Example function for launching a protocomm instance over HTTP */</span>
<span class="n">protocomm_t</span> <span class="o">*</span><span class="nf">start_pc</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pop_string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">protocomm_t</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">protocomm_new</span><span class="p">();</span>


    <span class="cm">/* Config for protocomm_httpd_start() */</span>
    <span class="n">protocomm_httpd_config_t</span> <span class="n">pc_config</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">PROTOCOMM_HTTPD_DEFAULT_CONFIG</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="cm">/* Start protocomm server on top of HTTP */</span>
    <span class="n">protocomm_httpd_start</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pc_config</span><span class="p">);</span>

    <span class="cm">/* Create Proof of Possession object from pop_string. It must be valid</span>
<span class="cm">     * throughout the scope of protocomm endpoint. This need not be static,</span>
<span class="cm">     * ie. could be dynamically allocated and freed at the time of endpoint</span>
<span class="cm">     * removal */</span>
    <span class="k">const</span> <span class="k">static</span> <span class="n">protocomm_security_pop_t</span> <span class="n">pop_obj</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">strdup</span><span class="p">(</span><span class="n">pop_string</span><span class="p">),</span>
        <span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pop_string</span><span class="p">)</span>
    <span class="p">};</span>

    <span class="cm">/* Set security for communication at application level. Just like for</span>
<span class="cm">     * request handlers, setting security creates an endpoint and registers</span>
<span class="cm">     * the handler provided by protocomm_security1. One can similarly use</span>
<span class="cm">     * protocomm_security0. Only one type of security can be set for a</span>
<span class="cm">     * protocomm instance at a time. */</span>
    <span class="n">protocomm_set_security</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"security_endpoint"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protocomm_security1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pop_obj</span><span class="p">);</span>

    <span class="cm">/* Private data passed to the endpoint must be valid throughout the scope</span>
<span class="cm">     * of protocomm endpoint. This need not be static, ie. could be dynamically</span>
<span class="cm">     * allocated and freed at the time of endpoint removal */</span>
    <span class="k">static</span> <span class="kt">uint32_t</span> <span class="n">priv_data</span> <span class="o">=</span> <span class="mi">1234</span><span class="p">;</span>

    <span class="cm">/* Add a new endpoint for the protocomm instance, identified by a unique name</span>
<span class="cm">     * and register a handler function along with private data to be passed at the</span>
<span class="cm">     * time of handler execution. Multiple endpoints can be added as long as they</span>
<span class="cm">     * are identified by unique names */</span>
    <span class="n">protocomm_add_endpoint</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"echo_req_endpoint"</span><span class="p">,</span>
                           <span class="n">echo_req_handler</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">priv_data</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Example function for stopping a protocomm instance */</span>
<span class="kt">void</span> <span class="nf">stop_pc</span><span class="p">(</span><span class="n">protocomm_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Remove endpoint identified by it's unique name */</span>
    <span class="n">protocomm_remove_endpoint</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"echo_req_endpoint"</span><span class="p">);</span>

    <span class="cm">/* Remove security endpoint identified by it's name */</span>
    <span class="n">protocomm_unset_security</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"security_endpoint"</span><span class="p">);</span>

    <span class="cm">/* Stop HTTP server */</span>
    <span class="n">protocomm_httpd_stop</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

    <span class="cm">/* Delete (deallocate) the protocomm instance */</span>
    <span class="n">protocomm_delete</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="transport-example-ble-with-security-0">
<h2>ტრანსპორტის მაგალითი (BLE) უსაფრთხოების 0-ით<a class="headerlink" href="protocomm.html#transport-example-ble-with-security-0" title="Permalink to this headline">¶</a></h2>
<p>სრული მაგალითისთვის იხილეთ <a class="reference external" href="https://github.com/espressif/esp-idf/tree/f91080637/examples/provisioning/ble_prov">უზრუნველყოფა/ble_prov</a></p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Example function for launching a secure protocomm instance over BLE */</span>
<span class="n">protocomm_t</span> <span class="o">*</span><span class="nf">start_pc</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">protocomm_t</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="n">protocomm_new</span><span class="p">();</span>

    <span class="cm">/* Endpoint UUIDs */</span>
    <span class="n">protocomm_ble_name_uuid_t</span> <span class="n">nu_lookup_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="s">"security_endpoint"</span><span class="p">,</span> <span class="mh">0xFF51</span><span class="p">},</span>
        <span class="p">{</span><span class="s">"echo_req_endpoint"</span><span class="p">,</span> <span class="mh">0xFF52</span><span class="p">}</span>
    <span class="p">};</span>

    <span class="cm">/* Config for protocomm_ble_start() */</span>
    <span class="n">protocomm_ble_config_t</span> <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">service_uuid</span> <span class="o">=</span> <span class="p">{</span>
            <span class="cm">/* LSB &lt;---------------------------------------</span>
<span class="cm">            * ---------------------------------------&gt; MSB */</span>
            <span class="mh">0xfb</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x9b</span><span class="p">,</span> <span class="mh">0x5f</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span>
            <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">.</span><span class="n">nu_lookup_count</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nu_lookup_table</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nu_lookup_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="p">.</span><span class="n">nu_lookup</span> <span class="o">=</span> <span class="n">nu_lookup_table</span>
    <span class="p">};</span>

    <span class="cm">/* Start protocomm layer on top of BLE */</span>
    <span class="n">protocomm_ble_start</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">config</span><span class="p">);</span>

    <span class="cm">/* For protocomm_security0, Proof of Possession is not used, and can be kept NULL */</span>
    <span class="n">protocomm_set_security</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"security_endpoint"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">protocomm_security0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">protocomm_add_endpoint</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"echo_req_endpoint"</span><span class="p">,</span> <span class="n">echo_req_handler</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Example function for stopping a protocomm instance */</span>
<span class="kt">void</span> <span class="nf">stop_pc</span><span class="p">(</span><span class="n">protocomm_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">protocomm_remove_endpoint</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"echo_req_endpoint"</span><span class="p">);</span>
    <span class="n">protocomm_unset_security</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="s">"security_endpoint"</span><span class="p">);</span>

    <span class="cm">/* Stop BLE protocomm service */</span>
    <span class="n">protocomm_ble_stop</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>

    <span class="n">protocomm_delete</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="api-reference">
<h2>API მითითება<a class="headerlink" href="protocomm.html#api-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="header-file">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#header-file" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/common/protocomm.h">protocomm/include/common/protocomm.h</a></li>
</ul>
</div>
<div class="section" id="functions">
<h3>ფუნქციები<a class="headerlink" href="protocomm.html#functions" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv413protocomm_newv">
<span id="_CPPv313protocomm_newv"></span><span id="_CPPv213protocomm_newv"></span><span id="protocomm_new__void"></span><span class="target" id="protocomm_8h_1a349588eefbc12e0c6d504cb7db15585f"></span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<code class="descname">protocomm_new</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv413protocomm_newv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შექმენით ახალი protocomm ეგზემპლარი. </p>
<p>ეს API დააბრუნებს ახალ დინამიურად გამოყოფილ protocomm ინსტანციას, protocomm_t სტრუქტურის ყველა ელემენტით, რომელიც ინიციალიზებული იქნება NULL-ზე.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>protocomm_t* : წარმატების შესახებ</li>
<li>NULL: ახალი ინსტანციის გამოყოფის მეხსიერება არ არის </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv416protocomm_deleteP11protocomm_t">
<span id="_CPPv316protocomm_deleteP11protocomm_t"></span><span id="_CPPv216protocomm_deleteP11protocomm_t"></span><span id="protocomm_delete__protocomm_tP"></span><span class="target" id="protocomm_8h_1a9bdb95ea5ab65d942405691a2f902ebe"></span>void <code class="descname">protocomm_delete</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv416protocomm_deleteP11protocomm_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm ეგზემპლარის წაშლა. </p>
<p>ეს API განაახლებს protocomm-ის ინსტანციას, რომელიც შეიქმნა გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</p>
<p><dl class="docutils">
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: წასაშლელი protocomm ეგზემპლარის მითითება </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422protocomm_add_endpointP11protocomm_tPKc23protocomm_req_handler_tPv">
<span id="_CPPv322protocomm_add_endpointP11protocomm_tPKc23protocomm_req_handler_tPv"></span><span id="_CPPv222protocomm_add_endpointP11protocomm_tPKc23protocomm_req_handler_tPv"></span><span id="protocomm_add_endpoint__protocomm_tP.cCP.protocomm_req_handler_t.voidP"></span><span class="target" id="protocomm_8h_1a9db8520cf4afd44ed0a4f4e6fddf428c"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_add_endpoint</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em>, <a class="reference internal" href="protocomm.html#_CPPv423protocomm_req_handler_t" title="protocomm_req_handler_t">protocomm_req_handler_t</a> <em>სთ</em>, void *<em>პრივილეგირებული_მონაცემები</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv422protocomm_add_endpointP11protocomm_tPKc23protocomm_req_handler_tPv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაამატეთ საბოლოო წერტილის მოთხოვნის დამმუშავებელი protocomm ეგზემპლარისთვის. </p>
<p>ეს API დააკავშირებს ბოლო წერტილის დამმუშავებლის ფუნქციას მითითებულ ბოლო წერტილის სახელთან, ნებისმიერ კერძო მონაცემთან ერთად, რომელიც უნდა გადაეცეს დამმუშავებელს გამოძახების დროს.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
<li>ეს ფუნქცია შინაგანად იძახებს რეგისტრირებულს <code class="docutils literal notranslate"><span class="pre">add_endpoint()</span></code> არჩეული ტრანსპორტის ფუნქცია, რომელიც protocomm_t ეგზემპლარის სტრუქტურის წევრია.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_FAIL: საბოლოო წერტილის დამატების შეცდომა / ამ სახელის მქონე საბოლოო წერტილი უკვე არსებობს</li>
<li>ESP_ERR_NO_MEM: შეცდომა საბოლოო წერტილის რესურსის გამოყოფისას</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის/დამმუშავებლის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი </li>
<li><code class="docutils literal notranslate"><span class="pre">h</span></code>საბოლოო წერტილის დამმუშავებლის ფუნქცია </li>
<li><code class="docutils literal notranslate"><span class="pre">priv_data</span></code>: გამოძახებისას დამმუშავებლის ფუნქციისთვის პარამეტრის სახით გადასაცემად კერძო მონაცემების მაჩვენებელი. საჭიროების შემთხვევაში, გადაეცით NULL.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv425protocomm_remove_endpointP11protocomm_tPKc">
<span id="_CPPv325protocomm_remove_endpointP11protocomm_tPKc"></span><span id="_CPPv225protocomm_remove_endpointP11protocomm_tPKc"></span><span id="protocomm_remove_endpoint__protocomm_tP.cCP"></span><span class="target" id="protocomm_8h_1a789adb75606137496368a77cfed1daef"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_remove_endpoint</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv425protocomm_remove_endpointP11protocomm_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm ეგზემპლარის საბოლოო წერტილის მოთხოვნის დამმუშავებლის წაშლა. </p>
<p>ეს API წაშლის რეგისტრირებულ საბოლოო წერტილის დამმუშავებელს, რომელიც იდენტიფიცირებულია საბოლოო წერტილის სახელით.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>ეს ფუნქცია შინაგანად იძახებს რეგისტრირებულს <code class="docutils literal notranslate"><span class="pre">remove_endpoint()</span></code> ფუნქცია, რომელიც protocomm_t ეგზემპლარის სტრუქტურის წევრია.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_NOT_FOUND: მითითებული სახელის მქონე საბოლოო წერტილი არ არსებობს.</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422protocomm_open_sessionP11protocomm_t8uint32_t">
<span id="_CPPv322protocomm_open_sessionP11protocomm_t8uint32_t"></span><span id="_CPPv222protocomm_open_sessionP11protocomm_t8uint32_t"></span><span id="protocomm_open_session__protocomm_tP.uint32_t"></span><span class="target" id="protocomm_8h_1a8f6226f1d5391a18d6b0c71e7f76e4b2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_open_session</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, uint32_t <em>სესიის_იდენტიფიკატორი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv422protocomm_open_sessionP11protocomm_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>გამოყოფს შიდა რესურსებს ახალი ტრანსპორტის სესიისთვის. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: მოთხოვნა წარმატებით დამუშავდა</li>
<li>ESP_ERR_NO_MEM: შეცდომა შიდა რესურსის გამოყოფისას</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">session_id</span></code>: საკომუნიკაციო სესიის უნიკალური ID</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423protocomm_close_sessionP11protocomm_t8uint32_t">
<span id="_CPPv323protocomm_close_sessionP11protocomm_t8uint32_t"></span><span id="_CPPv223protocomm_close_sessionP11protocomm_t8uint32_t"></span><span id="protocomm_close_session__protocomm_tP.uint32_t"></span><span class="target" id="protocomm_8h_1a67ff69125ec2eedeb39babdb2a3031f2"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_close_session</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, uint32_t <em>სესიის_იდენტიფიკატორი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv423protocomm_close_sessionP11protocomm_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ათავისუფლებს ტრანსპორტირების სესიის მიერ გამოყენებულ შიდა რესურსებს. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: მოთხოვნა წარმატებით დამუშავდა</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">session_id</span></code>: საკომუნიკაციო სესიის უნიკალური ID</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420protocomm_req_handleP11protocomm_tPKc8uint32_tPK7uint8_t7ssize_tPP7uint8_tP7ssize_t">
<span id="_CPPv320protocomm_req_handleP11protocomm_tPKc8uint32_tPK7uint8_t7ssize_tPP7uint8_tP7ssize_t"></span><span id="_CPPv220protocomm_req_handleP11protocomm_tPKc8uint32_tPK7uint8_t7ssize_tPP7uint8_tP7ssize_t"></span><span id="protocomm_req_handle__protocomm_tP.cCP.uint32_t.uint8_tCP.ssize_t.uint8_tPP.ssize_tP"></span><span class="target" id="protocomm_8h_1a66546a0610c41163712396e57b887c99"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_req_handle</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em>, uint32_t <em>სესიის_იდენტიფიკატორი</em>, <em class="property">კონსტ</em> uint8_t *<em>ინბუფი</em>, ssize_t <em>ინლენი</em>, uint8_t **<em>აუტბაფი</em>, ssize_t *<em>აუთლენი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv420protocomm_req_handleP11protocomm_tPKc8uint32_tPK7uint8_t7ssize_tPP7uint8_tP7ssize_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>შემომავალი მონაცემების დასამუშავებლად და პასუხის გენერირებისთვის გამოიძახებს ბოლო წერტილის სესიის რეგისტრირებულ დამმუშავებელს. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
<li>შედეგად მიღებული გამომავალი ბუფერი გამომძახებელმა უნდა განაცალკევოს.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: მოთხოვნა წარმატებით დამუშავდა</li>
<li>ESP_FAIL: რეგისტრირებული დამმუშავებლის შესრულებისას შიდა შეცდომა</li>
<li>ESP_ERR_NO_MEM: შეცდომა შიდა რესურსის გამოყოფისას</li>
<li>ESP_ERR_NOT_FOUND: მითითებული სახელის მქონე საბოლოო წერტილი არ არსებობს.</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი </li>
<li><code class="docutils literal notranslate"><span class="pre">session_id</span></code>: საკომუნიკაციო სესიის უნიკალური ID </li>
<li><code class="docutils literal notranslate"><span class="pre">inbuf</span></code>შეყვანის ბუფერი შეიცავს შეყვანის მოთხოვნის მონაცემებს, რომლებიც უნდა დამუშავდეს რეგისტრირებული დამმუშავებლის მიერ. </li>
<li><code class="docutils literal notranslate"><span class="pre">inlen</span></code>შეყვანის ბუფერის სიგრძე </li>
<li><code class="docutils literal notranslate"><span class="pre">outbuf</span></code>: მიმთითებელი შიდად გამოყოფილი გამომავალი ბუფერისკენ, სადაც უნდა შეინახოს რეგისტრირებული დამმუშავებლის მიერ გამოტანილი საპასუხო მონაცემები. </li>
<li><code class="docutils literal notranslate"><span class="pre">outlen</span></code>გამოყოფილი გამომავალი ბუფერის ბუფერის სიგრძე</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv422protocomm_set_securityP11protocomm_tPKcPK20protocomm_security_tPK24protocomm_security_pop_t">
<span id="_CPPv322protocomm_set_securityP11protocomm_tPKcPK20protocomm_security_tPK24protocomm_security_pop_t"></span><span id="_CPPv222protocomm_set_securityP11protocomm_tPKcPK20protocomm_security_tPK24protocomm_security_pop_t"></span><span id="protocomm_set_security__protocomm_tP.cCP.protocomm_security_tCP.protocomm_security_pop_tCP"></span><span class="target" id="protocomm_8h_1aaf94c5d3f70b9b655865e14917c48e33"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_set_security</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em>, <em class="property">კონსტ</em> <a class="reference internal" href="protocomm.html#_CPPv420protocomm_security_t" title="protocomm_security_t">protocomm_security_t</a> *<em>წმ</em>, <em class="property">კონსტ</em> <a class="reference internal" href="protocomm.html#_CPPv424protocomm_security_pop_t" title="protocomm_security_pop_t">protocomm_security_pop_t</a> *<em>პოპ</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv422protocomm_set_securityP11protocomm_tPKcPK20protocomm_security_tPK24protocomm_security_pop_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დაამატეთ საბოლოო წერტილის უსაფრთხოება protocomm-ის ეგზემპლარისთვის. </p>
<p>ეს API დააკავშირებს უსაფრთხოების სესიის დამფუძნებელს მითითებულ საბოლოო წერტილის სახელთან, სესიის კლიენტის ავთენტიფიკაციისთვის საჭირო ნებისმიერ დამადასტურებელ საბუთთან ერთად.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
<li>უსაფრთხოების არჩევანი შეიძლება იყოს ნებისმიერი <code class="docutils literal notranslate"><span class="pre">protocomm_security_t</span></code> მაგალითი. არჩევანი <code class="docutils literal notranslate"><span class="pre">protocomm_security0</span></code> და <code class="docutils literal notranslate"><span class="pre">protocomm_security1</span></code> ადვილად ხელმისაწვდომია.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_FAIL: საბოლოო წერტილის დამატების შეცდომა / ამ სახელის მქონე საბოლოო წერტილი უკვე არსებობს</li>
<li>ESP_ERR_INVALID_STATE: უსაფრთხოების საბოლოო წერტილი უკვე დაყენებულია</li>
<li>ESP_ERR_NO_MEM: შეცდომა საბოლოო წერტილის რესურსის გამოყოფისას</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის/დამმუშავებლის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი </li>
<li><code class="docutils literal notranslate"><span class="pre">sec</span></code>: საბოლოო წერტილის უსაფრთხოების ეგზემპლარის მითითება </li>
<li><code class="docutils literal notranslate"><span class="pre">pop</span></code>კლიენტის ავთენტიფიკაციისთვის ფლობის დამადასტურებელი საბუთის მითითება</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv424protocomm_unset_securityP11protocomm_tPKc">
<span id="_CPPv324protocomm_unset_securityP11protocomm_tPKc"></span><span id="_CPPv224protocomm_unset_securityP11protocomm_tPKc"></span><span id="protocomm_unset_security__protocomm_tP.cCP"></span><span class="target" id="protocomm_8h_1a04f61745971fe767703988f33facae24"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_unset_security</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv424protocomm_unset_securityP11protocomm_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm ეგზემპლარის საბოლოო წერტილის უსაფრთხოების მოხსნა. </p>
<p>ეს API წაშლის რეგისტრირებულ უსაფრთხოების საბოლოო წერტილს, რომელიც იდენტიფიცირებულია საბოლოო წერტილის სახელით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_NOT_FOUND: მითითებული სახელის მქონე საბოლოო წერტილი არ არსებობს.</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv421protocomm_set_versionP11protocomm_tPKcPKc">
<span id="_CPPv321protocomm_set_versionP11protocomm_tPKcPKc"></span><span id="_CPPv221protocomm_set_versionP11protocomm_tPKcPKc"></span><span id="protocomm_set_version__protocomm_tP.cCP.cCP"></span><span class="target" id="protocomm_8h_1a4f9ec6fa55bde3d3e7d2af9c033ce560"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_set_version</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em>, <em class="property">კონსტ</em> char *<em>ვერსია</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv421protocomm_set_versionP11protocomm_tPKcPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ვერსიის ვერიფიკაციისთვის საბოლოო წერტილის დაყენება. </p>
<p>ეს API შეიძლება გამოყენებულ იქნას აპლიკაციისთვის სპეციფიკური პროტოკოლის ვერსიის დასაყენებლად, რომლის გადამოწმებაც კლიენტებს შეუძლიათ საბოლოო წერტილის მეშვეობით.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd><ul class="simple">
<li>საბოლოო წერტილი უნდა იყოს დაკავშირებული ვალიდურ protocomm ინსტანციასთან, რომელიც შექმნილია გამოყენებით <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code>.</li>
</ul>
</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_FAIL: საბოლოო წერტილის დამატების შეცდომა / ამ სახელის მქონე საბოლოო წერტილი უკვე არსებობს</li>
<li>ESP_ERR_INVALID_STATE: ვერსიის საბოლოო წერტილი უკვე დაყენებულია</li>
<li>ESP_ERR_NO_MEM: შეცდომა საბოლოო წერტილის რესურსის გამოყოფისას</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის/დამმუშავებლის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი </li>
<li><code class="docutils literal notranslate"><span class="pre">version</span></code>: ვერსიის იდენტიფიკატორის (სახელის) სტრიქონი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv423protocomm_unset_versionP11protocomm_tPKc">
<span id="_CPPv323protocomm_unset_versionP11protocomm_tPKc"></span><span id="_CPPv223protocomm_unset_versionP11protocomm_tPKc"></span><span id="protocomm_unset_version__protocomm_tP.cCP"></span><span class="target" id="protocomm_8h_1ac252f6e897105d35824e843c99230edd"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_unset_version</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> char *<em>ep_name</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv423protocomm_unset_versionP11protocomm_tPKc" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ვერსიის დადასტურების საბოლოო წერტილის წაშლა protocomm ეგზემპლარიდან. </p>
<p>ეს API წაშლის რეგისტრირებული ვერსიის საბოლოო წერტილს, რომელიც იდენტიფიცირებულია საბოლოო წერტილის სახელით.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_NOT_FOUND: მითითებული სახელის მქონე საბოლოო წერტილი არ არსებობს.</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი ეგზემპლარის/სახელის არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>: protocomm ინსტანციის მაჩვენებელი </li>
<li><code class="docutils literal notranslate"><span class="pre">ep_name</span></code>: საბოლოო წერტილის იდენტიფიკატორის (სახელის) სტრიქონი</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="type-definitions">
<h3>ტიპის განმარტებები<a class="headerlink" href="protocomm.html#type-definitions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv423protocomm_req_handler_t">
<span id="_CPPv323protocomm_req_handler_t"></span><span id="_CPPv223protocomm_req_handler_t"></span><span id="protocomm_req_handler_t"></span><span class="target" id="protocomm_8h_1af0bb71b922cf9a418a1151ad553c8f95"></span><em class="property">typedef </em><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">protocomm_req_handler_t</code>)<span class="sig-paren">(</span>uint32_t session_id, <em class="property">კონსტ</em> uint8_t *inbuf, ssize_t inlen, uint8_t **outbuf, ssize_t *outlen, void *priv_data<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv423protocomm_req_handler_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm-ის საბოლოო წერტილის დამმუშავებლის ფუნქციის პროტოტიპი. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv411protocomm_t">
<span id="_CPPv311protocomm_t"></span><span id="_CPPv211protocomm_t"></span><span id="protocomm_t"></span><span class="target" id="protocomm_8h_1a27b1e4598dccc907b988b4c256cb2bf9"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> protocomm <code class="descname">protocomm_t</code><a class="headerlink" href="protocomm.html#_CPPv411protocomm_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ეს სტრუქტურა შეესაბამება protocomm-ის უნიკალურ ეგზემპლარს, რომელიც დაბრუნებულია, როდესაც API <code class="docutils literal notranslate"><span class="pre">protocomm_new()</span></code> გამოძახებულია. დარჩენილი Protocomm API ისთვის ეს ობიექტი პირველ პარამეტრად არის საჭირო. </p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>Structure of the protocomm object is kept private </dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id1">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#id1" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/security/protocomm_security.h">protocomm/include/security/protocomm_security.h</a></li>
</ul>
</div>
<div class="section" id="structures">
<h3>სტრუქტურები<a class="headerlink" href="protocomm.html#structures" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv422protocomm_security_pop">
<span id="_CPPv322protocomm_security_pop"></span><span id="_CPPv222protocomm_security_pop"></span><span id="protocomm_security_pop"></span><span class="target" id="structprotocomm__security__pop"></span><em class="property">სტრუქტურა </em><code class="descname">protocomm_security_pop</code><a class="headerlink" href="protocomm.html#_CPPv422protocomm_security_pop" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უსაფრთხო სესიის ავთენტიფიკაციის დამადასტურებელი დოკუმენტი. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N22protocomm_security_pop4dataE">
<span id="_CPPv3N22protocomm_security_pop4dataE"></span><span id="_CPPv2N22protocomm_security_pop4dataE"></span><span id="protocomm_security_pop::data__uint8_tCP"></span><span class="target" id="structprotocomm__security__pop_1a8df40d21ad058b9d14cef23ccf28cfda"></span><em class="property">კონსტ</em> uint8_t *<code class="descname">data</code><a class="headerlink" href="protocomm.html#_CPPv4N22protocomm_security_pop4dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ბუფერის მიმთითებელი, რომელიც შეიცავს ფლობის დამადასტურებელ მონაცემებს </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N22protocomm_security_pop3lenE">
<span id="_CPPv3N22protocomm_security_pop3lenE"></span><span id="_CPPv2N22protocomm_security_pop3lenE"></span><span id="protocomm_security_pop::len__uint16_t"></span><span class="target" id="structprotocomm__security__pop_1a1c29ade53c772a231ee1ffba2d33fa16"></span>uint16_t <code class="descname">len</code><a class="headerlink" href="protocomm.html#_CPPv4N22protocomm_security_pop3lenE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფლობის დამადასტურებელი მონაცემების სიგრძე (ბაიტებში) </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv418protocomm_security">
<span id="_CPPv318protocomm_security"></span><span id="_CPPv218protocomm_security"></span><span id="protocomm_security"></span><span class="target" id="structprotocomm__security"></span><em class="property">სტრუქტურა </em><code class="descname">protocomm_security</code><a class="headerlink" href="protocomm.html#_CPPv418protocomm_security" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Protocomm-ის უსაფრთხოების ობიექტის სტრუქტურა. </p>
<p>წევრი ფუნქციები გამოიყენება უსაფრთხო პროტოკომის სესიების განსახორციელებლად.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This structure should not have any dynamic members to allow re-entrancy </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N18protocomm_security3verE">
<span id="_CPPv3N18protocomm_security3verE"></span><span id="_CPPv2N18protocomm_security3verE"></span><span id="protocomm_security::ver__i"></span><span class="target" id="structprotocomm__security_1ab49e4bf557883a1f4620d235e6418c59"></span>int <code class="descname">ver</code><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security3verE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უსაფრთხოების იმპლემენტაციის უნიკალური ვერსიის ნომერი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security4initE">
<span id="_CPPv3N18protocomm_security4initE"></span><span id="_CPPv2N18protocomm_security4initE"></span><span class="target" id="structprotocomm__security_1aeb33c465ce70e0cce46b961bb9b1a2f3"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">init</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> *handle<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security4initE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უსაფრთხოების ინფრასტრუქტურის ინიციალიზაციის/გამოყოფის ფუნქცია </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security7cleanupE">
<span id="_CPPv3N18protocomm_security7cleanupE"></span><span id="_CPPv2N18protocomm_security7cleanupE"></span><span class="target" id="structprotocomm__security_1a6e4e76fc63b99b4894fe926c041b0a65"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">cleanup</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security7cleanupE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უსაფრთხოების ინფრასტრუქტურის დელოკაციის ფუნქცია </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security21new_transport_sessionE">
<span id="_CPPv3N18protocomm_security21new_transport_sessionE"></span><span id="_CPPv2N18protocomm_security21new_transport_sessionE"></span><span class="target" id="structprotocomm__security_1a316fb471136b4a9bc5dd3877add7024a"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">new_transport_session</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle, uint32_t session_id<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security21new_transport_sessionE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>იწყება ახალი უსაფრთხო ტრანსპორტირების სესია მითითებული ID-ით </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security23close_transport_sessionE">
<span id="_CPPv3N18protocomm_security23close_transport_sessionE"></span><span id="_CPPv2N18protocomm_security23close_transport_sessionE"></span><span class="target" id="structprotocomm__security_1a3fc7becde4139cbe4f4cc1aa77d1fb49"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">close_transport_session</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle, uint32_t session_id<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security23close_transport_sessionE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დახურავს უსაფრთხო ტრანსპორტირების სესიას მითითებული ID-ით </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security20security_req_handlerE">
<span id="_CPPv3N18protocomm_security20security_req_handlerE"></span><span id="_CPPv2N18protocomm_security20security_req_handlerE"></span><span class="target" id="structprotocomm__security_1aad9d016313c82af8d93324e330c58564"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">security_req_handler</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle, <em class="property">კონსტ</em> <a class="reference internal" href="protocomm.html#_CPPv424protocomm_security_pop_t" title="protocomm_security_pop_t">protocomm_security_pop_t</a> *pop, uint32_t session_id, <em class="property">კონსტ</em> uint8_t *inbuf, ssize_t inlen, uint8_t **outbuf, ssize_t *outlen, void *priv_data<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security20security_req_handlerE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>დამმუშავებლის ფუნქცია კავშირის მოთხოვნის ავთენტიფიკაციისა და უსაფრთხო სესიის დასამყარებლად </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security7encryptE">
<span id="_CPPv3N18protocomm_security7encryptE"></span><span id="_CPPv2N18protocomm_security7encryptE"></span><span class="target" id="structprotocomm__security_1abd509887cc017a2ac247ad236412297f"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">encrypt</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle, uint32_t session_id, <em class="property">კონსტ</em> uint8_t *inbuf, ssize_t inlen, uint8_t *outbuf, ssize_t *outlen<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security7encryptE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფუნქცია, რომელიც ახორციელებს დაშიფვრის ალგორითმს </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N18protocomm_security7decryptE">
<span id="_CPPv3N18protocomm_security7decryptE"></span><span id="_CPPv2N18protocomm_security7decryptE"></span><span class="target" id="structprotocomm__security_1af2124337395e478a08f5ae16f73d27fa"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> (*<code class="descname">decrypt</code>)<span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="protocomm_security_handle_t">protocomm_security_handle_t</a> handle, uint32_t session_id, <em class="property">კონსტ</em> uint8_t *inbuf, ssize_t inlen, uint8_t *outbuf, ssize_t *outlen<span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv4N18protocomm_security7decryptE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ფუნქცია, რომელიც ახორციელებს გაშიფვრის ალგორითმს </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id2">
<h3>ტიპის განმარტებები<a class="headerlink" href="protocomm.html#id2" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv424protocomm_security_pop_t">
<span id="_CPPv324protocomm_security_pop_t"></span><span id="_CPPv224protocomm_security_pop_t"></span><span id="protocomm_security_pop_t"></span><span class="target" id="protocomm__security_8h_1a9e072d18c1589201b8957540e2819fa1"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="protocomm.html#_CPPv422protocomm_security_pop" title="protocomm_security_pop">protocomm_security_pop</a> <code class="descname">protocomm_security_pop_t</code><a class="headerlink" href="protocomm.html#_CPPv424protocomm_security_pop_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უსაფრთხო სესიის ავთენტიფიკაციის დამადასტურებელი დოკუმენტი. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv427protocomm_security_handle_t">
<span id="_CPPv327protocomm_security_handle_t"></span><span id="_CPPv227protocomm_security_handle_t"></span><span id="protocomm_security_handle_t"></span><span class="target" id="protocomm__security_8h_1aec904c117ecfd4a89846c5b4b95e9d9d"></span><em class="property">typedef </em>void *<code class="descname">protocomm_security_handle_t</code><a class="headerlink" href="protocomm.html#_CPPv427protocomm_security_handle_t" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
<dl class="type">
<dt id="_CPPv420protocomm_security_t">
<span id="_CPPv320protocomm_security_t"></span><span id="_CPPv220protocomm_security_t"></span><span id="protocomm_security_t"></span><span class="target" id="protocomm__security_8h_1ac3a3e828ef8aeeff7164f3bd9ac1f048"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="protocomm.html#_CPPv418protocomm_security" title="protocomm_security">პროტოკომი_უსაფრთხოება</a> <code class="descname">protocomm_security_t</code><a class="headerlink" href="protocomm.html#_CPPv420protocomm_security_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Protocomm-ის უსაფრთხოების ობიექტის სტრუქტურა. </p>
<p>წევრი ფუნქციები გამოიყენება უსაფრთხო პროტოკომის სესიების განსახორციელებლად.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This structure should not have any dynamic members to allow re-entrancy </dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id3">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#id3" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/security/protocomm_security0.h">protocomm/include/security/protocomm_security0.h</a></li>
</ul>
</div>
<div class="section" id="id4">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#id4" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/security/protocomm_security1.h">protocomm/include/security/protocomm_security1.h</a></li>
</ul>
</div>
<div class="section" id="id5">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#id5" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/transports/protocomm_httpd.h">protocomm/include/transports/protocomm_httpd.h</a></li>
</ul>
</div>
<div class="section" id="id6">
<h3>ფუნქციები<a class="headerlink" href="protocomm.html#id6" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv421protocomm_httpd_startP11protocomm_tPK24protocomm_httpd_config_t">
<span id="_CPPv321protocomm_httpd_startP11protocomm_tPK24protocomm_httpd_config_t"></span><span id="_CPPv221protocomm_httpd_startP11protocomm_tPK24protocomm_httpd_config_t"></span><span id="protocomm_httpd_start__protocomm_tP.protocomm_httpd_config_tCP"></span><span class="target" id="protocomm__httpd_8h_1a7dbe14ee8e099c8b987e490784cd2d4b"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_httpd_start</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="protocomm.html#_CPPv424protocomm_httpd_config_t" title="protocomm_httpd_config_t">protocomm_httpd_config_t</a> *<em>კონფიგურაცია</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv421protocomm_httpd_startP11protocomm_tPK24protocomm_httpd_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>HTTPD პროტოკომის ტრანსპორტის დაწყება. </p>
<p>ეს API შინაგანად ქმნის ჩარჩო , რათა უზრუნველყოს პროტოკომის ბოლო წერტილის რეგისტრაცია და უსაფრთხოების კონფიგურაცია.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>This is a singleton. ie. Protocomm can have multiple instances, but only one instance can be bound to an HTTP transport layer.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი არგუმენტები</li>
<li>ESP_ERR_NOT_SUPPORTED: ტრანსპორტის ფენა დაკავშირებულია სხვა პროტოკომის ინსტანციასთან.</li>
<li>ESP_ERR_INVALID_STATE: ტრანსპორტის ფენა უკვე დაკავშირებულია ამ პროტოკომის ინსტანციასთან.</li>
<li>ESP_ERR_NO_MEM: სერვერის რესურსისთვის მეხსიერების გამოყოფა ვერ მოხერხდა.</li>
<li>ESP_ERR_HTTPD_*: HTTP სერვერის შეცდომა გაშვებისას </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>Protocomm-ის ეგზემპლარის მაჩვენებელი მიღებულია protocomm_new()-დან </li>
<li><code class="docutils literal notranslate"><span class="pre">config</span></code>HTTP სერვერის ინიციალიზაციისთვის კონფიგურაციის სტრუქტურის მითითება</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv420protocomm_httpd_stopP11protocomm_t">
<span id="_CPPv320protocomm_httpd_stopP11protocomm_t"></span><span id="_CPPv220protocomm_httpd_stopP11protocomm_t"></span><span id="protocomm_httpd_stop__protocomm_tP"></span><span class="target" id="protocomm__httpd_8h_1ace54bdf94e43d7a05615c55aaf040385"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_httpd_stop</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv420protocomm_httpd_stopP11protocomm_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>HTTPD პროტოკომის ტრანსპორტის შეჩერება. </p>
<p>ეს API ასუფთავებს HTTPD ტრანსპორტის პროტოკომს და ათავისუფლებს პროტოკომში რეგისტრირებულ ყველა დამმუშავებელს.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_ERR_INVALID_ARG: ნული / არასწორი პროტოკომის ეგზემპლარის მაჩვენებელი </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>იგივე protocomm ეგზემპლარი, რომელიც გადაეცა protocomm_httpd_start()-ს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="unions">
<h3>პროფკავშირები<a class="headerlink" href="protocomm.html#unions" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv429protocomm_httpd_config_data_t">
<span id="_CPPv329protocomm_httpd_config_data_t"></span><span id="_CPPv229protocomm_httpd_config_data_t"></span><span id="protocomm_httpd_config_data_t"></span><span class="target" id="unionprotocomm__httpd__config__data__t"></span><em class="property">კავშირი </em><code class="descname">protocomm_httpd_config_data_t</code><a class="headerlink" href="protocomm.html#_CPPv429protocomm_httpd_config_data_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><em>#ჩართვა&lt;protocomm_httpd.h&gt;</em><p>Protocomm HTTPD კონფიგურაციის მონაცემები </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N29protocomm_httpd_config_data_t6handleE">
<span id="_CPPv3N29protocomm_httpd_config_data_t6handleE"></span><span id="_CPPv2N29protocomm_httpd_config_data_t6handleE"></span><span id="protocomm_httpd_config_data_t::handle__voidP"></span><span class="target" id="unionprotocomm__httpd__config__data__t_1aa5124a1cd7db82b24fd064c516b16612"></span>void *<code class="descname">handle</code><a class="headerlink" href="protocomm.html#_CPPv4N29protocomm_httpd_config_data_t6handleE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>HTTP სერვერის სახელური, თუ ext_handle_provided-ის მნიშვნელობა true-ზეა დაყენებული </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N29protocomm_httpd_config_data_t6configE">
<span id="_CPPv3N29protocomm_httpd_config_data_t6configE"></span><span id="_CPPv2N29protocomm_httpd_config_data_t6configE"></span><span id="protocomm_httpd_config_data_t::config__protocomm_http_server_config_t"></span><span class="target" id="unionprotocomm__httpd__config__data__t_1a811597a2fc91ee7192321f9848ea0166"></span><a class="reference internal" href="protocomm.html#_CPPv430protocomm_http_server_config_t" title="protocomm_http_server_config_t">protocomm_http_server_config_t</a> <code class="descname">config</code><a class="headerlink" href="protocomm.html#_CPPv4N29protocomm_httpd_config_data_t6configE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>HTTP სერვერის კონფიგურაცია, თუ სერვერი უკვე აქტიური არ არის </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id7">
<h3>სტრუქტურები<a class="headerlink" href="protocomm.html#id7" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv430protocomm_http_server_config_t">
<span id="_CPPv330protocomm_http_server_config_t"></span><span id="_CPPv230protocomm_http_server_config_t"></span><span id="protocomm_http_server_config_t"></span><span class="target" id="structprotocomm__http__server__config__t"></span><em class="property">სტრუქტურა </em><code class="descname">protocomm_http_server_config_t</code><a class="headerlink" href="protocomm.html#_CPPv430protocomm_http_server_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm HTTP სერვერის კონფიგურაციის პარამეტრები. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N30protocomm_http_server_config_t4portE">
<span id="_CPPv3N30protocomm_http_server_config_t4portE"></span><span id="_CPPv2N30protocomm_http_server_config_t4portE"></span><span id="protocomm_http_server_config_t::port__uint16_t"></span><span class="target" id="structprotocomm__http__server__config__t_1a6a657a170ca7492de686cf3266026ceb"></span>uint16_t <code class="descname">port</code><a class="headerlink" href="protocomm.html#_CPPv4N30protocomm_http_server_config_t4portE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პორტი, რომელზეც HTTP სერვერი მოუსმენს </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N30protocomm_http_server_config_t10stack_sizeE">
<span id="_CPPv3N30protocomm_http_server_config_t10stack_sizeE"></span><span id="_CPPv2N30protocomm_http_server_config_t10stack_sizeE"></span><span id="protocomm_http_server_config_t::stack_size__s"></span><span class="target" id="structprotocomm__http__server__config__t_1a943ac3fd909df6ce0072f5792bbe2ce9"></span>size_t <code class="descname">stack_size</code><a class="headerlink" href="protocomm.html#_CPPv4N30protocomm_http_server_config_t10stack_sizeE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სერვერის დავალების დასტის ზომა, რომელიც რეგულირდება საბოლოო წერტილის დამმუშავებლის დასტის გამოყენების მიხედვით </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N30protocomm_http_server_config_t13task_priorityE">
<span id="_CPPv3N30protocomm_http_server_config_t13task_priorityE"></span><span id="_CPPv2N30protocomm_http_server_config_t13task_priorityE"></span><span id="protocomm_http_server_config_t::task_priority__unsigned"></span><span class="target" id="structprotocomm__http__server__config__t_1ae40fc5696ab94bfbbf494dff1f7dd6d8"></span>unsigned <code class="descname">task_priority</code><a class="headerlink" href="protocomm.html#_CPPv4N30protocomm_http_server_config_t13task_priorityE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>სერვერის დავალების პრიორიტეტი </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv424protocomm_httpd_config_t">
<span id="_CPPv324protocomm_httpd_config_t"></span><span id="_CPPv224protocomm_httpd_config_t"></span><span id="protocomm_httpd_config_t"></span><span class="target" id="structprotocomm__httpd__config__t"></span><em class="property">სტრუქტურა </em><code class="descname">protocomm_httpd_config_t</code><a class="headerlink" href="protocomm.html#_CPPv424protocomm_httpd_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm HTTP სერვერის კონფიგურაციის პარამეტრები. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N24protocomm_httpd_config_t19ext_handle_providedE">
<span id="_CPPv3N24protocomm_httpd_config_t19ext_handle_providedE"></span><span id="_CPPv2N24protocomm_httpd_config_t19ext_handle_providedE"></span><span id="protocomm_httpd_config_t::ext_handle_provided__b"></span><span class="target" id="structprotocomm__httpd__config__t_1ab08c05354a3a95bdb78fbfb434ffd343"></span>bool <code class="descname">ext_handle_provided</code><a class="headerlink" href="protocomm.html#_CPPv4N24protocomm_httpd_config_t19ext_handle_providedE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მოწოდებულია გარე HTTP სერვერის Handle-ის მითითების დროშა. ასეთ შემთხვევაში, protocomm გამოიყენებს იმავე HTTP სერვერს და შიდა რეჟიმში ახალს არ გაუშვებს. </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N24protocomm_httpd_config_t4dataE">
<span id="_CPPv3N24protocomm_httpd_config_t4dataE"></span><span id="_CPPv2N24protocomm_httpd_config_t4dataE"></span><span id="protocomm_httpd_config_t::data__protocomm_httpd_config_data_t"></span><span class="target" id="structprotocomm__httpd__config__t_1a1f4c60fb5f4c6b4d9320e8eff539cc7f"></span><a class="reference internal" href="protocomm.html#_CPPv429protocomm_httpd_config_data_t" title="protocomm_httpd_config_data_t">protocomm_httpd_config_data_t</a> <code class="descname">data</code><a class="headerlink" href="protocomm.html#_CPPv4N24protocomm_httpd_config_t4dataE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Protocomm HTTPD კონფიგურაციის მონაცემები </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="macros">
<h3>მაკროები<a class="headerlink" href="protocomm.html#macros" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.PROTOCOMM_HTTPD_DEFAULT_CONFIG">
<span class="target" id="protocomm__httpd_8h_1aefb3e82b2e7771802541ec94eae7867b"></span><code class="descname">PROTOCOMM_HTTPD_DEFAULT_CONFIG</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#c.PROTOCOMM_HTTPD_DEFAULT_CONFIG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</div>
<div class="section" id="id8">
<h3>სათაურის ფაილი<a class="headerlink" href="protocomm.html#id8" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="https://github.com/espressif/esp-idf/blob/f91080637/components/protocomm/include/transports/protocomm_ble.h">protocomm/include/transports/protocomm_ble.h</a></li>
</ul>
</div>
<div class="section" id="id9">
<h3>ფუნქციები<a class="headerlink" href="protocomm.html#id9" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv419protocomm_ble_startP11protocomm_tPK22protocomm_ble_config_t">
<span id="_CPPv319protocomm_ble_startP11protocomm_tPK22protocomm_ble_config_t"></span><span id="_CPPv219protocomm_ble_startP11protocomm_tPK22protocomm_ble_config_t"></span><span id="protocomm_ble_start__protocomm_tP.protocomm_ble_config_tCP"></span><span class="target" id="protocomm__ble_8h_1abed95eab34dc13bfddc48d20f1735b54"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_ble_start</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em>, <em class="property">კონსტ</em> <a class="reference internal" href="protocomm.html#_CPPv422protocomm_ble_config_t" title="protocomm_ble_config_t">protocomm_ble_config_t</a> *<em>კონფიგურაცია</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv419protocomm_ble_startP11protocomm_tPK22protocomm_ble_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Bluetooth დაწყება - დაბალი ენერგიის საფუძველზე ტრანსპორტირების ფენა უზრუნველყოფისთვის. </p>
<p>უზრუნველყოფისთვის საჭირო BLE სერვისის ინიციალიზაცია და გაშვება. ეს მოიცავს BLE-სთვის მახასიათებლების/სერვისის ინიციალიზაციას.</p>
<p><dl class="docutils">
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_FAIL: BLE-ს გაშვების მარტივი შეცდომა</li>
<li>ESP_ERR_NO_MEM: შეცდომა შიდა რესურსებისთვის მეხსიერების გამოყოფისას</li>
<li>ESP_ERR_INVALID_STATE: შეცდომა ble კონფიგურაციაში</li>
<li>ESP_ERR_INVALID_ARG: ნულოვანი არგუმენტები </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>Protocomm-ის ეგზემპლარის მაჩვენებელი მიღებულია protocomm_new()-დან </li>
<li><code class="docutils literal notranslate"><span class="pre">config</span></code>BLE-ს ინიციალიზაციისთვის კონფიგურაციის სტრუქტურის მითითება</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="function">
<dt id="_CPPv418protocomm_ble_stopP11protocomm_t">
<span id="_CPPv318protocomm_ble_stopP11protocomm_t"></span><span id="_CPPv218protocomm_ble_stopP11protocomm_t"></span><span id="protocomm_ble_stop__protocomm_tP"></span><span class="target" id="protocomm__ble_8h_1a845bd66134f96ec3ccddde2e98f68226"></span><a class="reference internal" href="../system/esp_err.html#_CPPv49esp_err_t" title="esp_err_t">esp_err_t</a> <code class="descname">protocomm_ble_stop</code><span class="sig-paren">(</span><a class="reference internal" href="protocomm.html#_CPPv411protocomm_t" title="protocomm_t">პროტოკომი</a> *<em>კომპიუტერი</em><span class="sig-paren">)</span><a class="headerlink" href="protocomm.html#_CPPv418protocomm_ble_stopP11protocomm_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Stop Bluetooth დაბალი ენერგიის საფუძველზე ტრანსპორტირების ფენა უზრუნველყოფისთვის. </p>
<p>BLE-ზე დაფუძნებული ურთიერთქმედებებისთვის პასუხისმგებელი სერვისის/დავალების შეჩერება მიწოდების მიზნით.</p>
<p><dl class="docutils">
<dt><strong>შენიშვნა</strong></dt>
<dd>You might want to optionally reclaim memory from Bluetooth. Refer to the documentation of <code class="docutils literal notranslate"><span class="pre">esp_bt_mem_release</span></code> in that case.</dd>
<dt><strong>დაბრუნება</strong></dt>
<dd><ul class="simple">
<li>ESP_OK: წარმატება</li>
<li>ESP_FAIL: BLE-ს გაჩერების მარტივი შეცდომა</li>
<li>ESP_ERR_INVALID_ARG: ნული / არასწორი პროტოკომის ეგზემპლარი </li>
</ul>
</dd>
<dt><strong>პარამეტრები</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pc</span></code>იგივე protocomm ეგზემპლარი, რომელიც გადაეცა protocomm_ble_start()-ს.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
<div class="section" id="id10">
<h3>სტრუქტურები<a class="headerlink" href="protocomm.html#id10" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv49name_uuid">
<span id="_CPPv39name_uuid"></span><span id="_CPPv29name_uuid"></span><span id="name_uuid"></span><span class="target" id="structname__uuid"></span><em class="property">სტრუქტურა </em><code class="descname">name_uuid</code><a class="headerlink" href="protocomm.html#_CPPv49name_uuid" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ეს სტრუქტურა აკავშირებს პროტოკომის ფენის მიერ საჭირო დამმუშავებელს UUID-ებთან, რომლებიც გამოიყენება სმარტფონიდან ან მსგავსი კლიენტური მოწყობილობიდან BLE მახასიათებლების უნიკალურად იდენტიფიცირებისთვის. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N9name_uuid4nameE">
<span id="_CPPv3N9name_uuid4nameE"></span><span id="_CPPv2N9name_uuid4nameE"></span><span id="name_uuid::name__cCP"></span><span class="target" id="structname__uuid_1a9b24ae00fd547e2ae5e0dace1927d882"></span><em class="property">კონსტ</em> char *<code class="descname">name</code><a class="headerlink" href="protocomm.html#_CPPv4N9name_uuid4nameE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>პროტოკომის ფენაზე გადაცემული დამმუშავებლის სახელი </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N9name_uuid4uuidE">
<span id="_CPPv3N9name_uuid4uuidE"></span><span id="_CPPv2N9name_uuid4uuidE"></span><span id="name_uuid::uuid__uint16_t"></span><span class="target" id="structname__uuid_1aee5fcf6c244bd9a3e8c190de3c3ef6ed"></span>uint16_t <code class="descname">uuid</code><a class="headerlink" href="protocomm.html#_CPPv4N9name_uuid4uuidE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>UUID, რომელიც უნდა მიენიჭოს BLE მახასიათებელს, რომელიც მიმაგრებულია დამმუშავებელთან. </p>
</dd></dl>
</div>
</dd></dl>
<dl class="class">
<dt id="_CPPv420protocomm_ble_config">
<span id="_CPPv320protocomm_ble_config"></span><span id="_CPPv220protocomm_ble_config"></span><span id="protocomm_ble_config"></span><span class="target" id="structprotocomm__ble__config"></span><em class="property">სტრუქტურა </em><code class="descname">protocomm_ble_config</code><a class="headerlink" href="protocomm.html#_CPPv420protocomm_ble_config" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm BLE სერვისის კონფიგურაციის პარამეტრები. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">საჯარო წევრები</p>
<dl class="member">
<dt id="_CPPv4N20protocomm_ble_config11device_nameE">
<span id="_CPPv3N20protocomm_ble_config11device_nameE"></span><span id="_CPPv2N20protocomm_ble_config11device_nameE"></span><span id="protocomm_ble_config::device_name__cA"></span><span class="target" id="structprotocomm__ble__config_1aa975f5f173215374940104f3b4517911"></span>char <code class="descname">device_name</code>[<code class="descname">MAX_BLE_DEVNAME_LEN</code>]<a class="headerlink" href="protocomm.html#_CPPv4N20protocomm_ble_config11device_nameE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>BLE მოწყობილობის სახელი გადაიცემა უზრუნველყოფის დროს </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N20protocomm_ble_config12service_uuidE">
<span id="_CPPv3N20protocomm_ble_config12service_uuidE"></span><span id="_CPPv2N20protocomm_ble_config12service_uuidE"></span><span id="protocomm_ble_config::service_uuid__uint8_tA"></span><span class="target" id="structprotocomm__ble__config_1a3365693352fbeeb94f54623a3330379a"></span>uint8_t <code class="descname">service_uuid</code>[<code class="descname">BLE_UUID128_VAL_LENGTH</code>]<a class="headerlink" href="protocomm.html#_CPPv4N20protocomm_ble_config12service_uuidE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>უზრუნველყოფის სერვისის 128 ბიტიანი UUID </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N20protocomm_ble_config15nu_lookup_countE">
<span id="_CPPv3N20protocomm_ble_config15nu_lookup_countE"></span><span id="_CPPv2N20protocomm_ble_config15nu_lookup_countE"></span><span id="protocomm_ble_config::nu_lookup_count__ssize_t"></span><span class="target" id="structprotocomm__ble__config_1af0911f726f0e46fd00f071e610b3a53e"></span>ssize_t <code class="descname">nu_lookup_count</code><a class="headerlink" href="protocomm.html#_CPPv4N20protocomm_ble_config15nu_lookup_countE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ჩანაწერების რაოდენობა Name-UUID ძიების ცხრილში </p>
</dd></dl>
<dl class="member">
<dt id="_CPPv4N20protocomm_ble_config9nu_lookupE">
<span id="_CPPv3N20protocomm_ble_config9nu_lookupE"></span><span id="_CPPv2N20protocomm_ble_config9nu_lookupE"></span><span id="protocomm_ble_config::nu_lookup__protocomm_ble_name_uuid_tP"></span><span class="target" id="structprotocomm__ble__config_1a06bf8d25a9ae3a4ed2e3a4bbf0f7fc58"></span><a class="reference internal" href="protocomm.html#_CPPv425protocomm_ble_name_uuid_t" title="protocomm_ble_name_uuid_t">protocomm_ble_name_uuid_t</a> *<code class="descname">nu_lookup</code><a class="headerlink" href="protocomm.html#_CPPv4N20protocomm_ble_config9nu_lookupE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>მითითება Name-UUID საძიებო ცხრილზე </p>
</dd></dl>
</div>
</dd></dl>
</div>
<div class="section" id="id11">
<h3>მაკროები<a class="headerlink" href="protocomm.html#id11" title="Permalink to this headline">¶</a></h3>
<dl class="macro">
<dt id="c.MAX_BLE_DEVNAME_LEN">
<span class="target" id="protocomm__ble_8h_1a2508f7570e00e207a7acbf449e500fac"></span><code class="descname">MAX_BLE_DEVNAME_LEN</code><a class="headerlink" href="protocomm.html#c.MAX_BLE_DEVNAME_LEN" title="Permalink to this definition">¶</a></dt>
<dd><p>BLE მოწყობილობის სახელი არ შეიძლება იყოს ამ მნიშვნელობაზე დიდი 31 ბაიტი (მაქსიმალური სკანირების პასუხის ზომა) - 1 ბაიტი (სიგრძე) - 1 ბაიტი (ტიპი) = 29 ბაიტი </p>
</dd></dl>
<dl class="macro">
<dt id="c.BLE_UUID128_VAL_LENGTH">
<span class="target" id="protocomm__ble_8h_1a5c61a39d35f6ada137f65f9c8d9f93d8"></span><code class="descname">BLE_UUID128_VAL_LENGTH</code><a class="headerlink" href="protocomm.html#c.BLE_UUID128_VAL_LENGTH" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</div>
<div class="section" id="id12">
<h3>ტიპის განმარტებები<a class="headerlink" href="protocomm.html#id12" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="_CPPv425protocomm_ble_name_uuid_t">
<span id="_CPPv325protocomm_ble_name_uuid_t"></span><span id="_CPPv225protocomm_ble_name_uuid_t"></span><span id="protocomm_ble_name_uuid_t"></span><span class="target" id="protocomm__ble_8h_1abdba2fa28fcf239add6e59144a16df3e"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="protocomm.html#_CPPv49name_uuid" title="name_uuid">სახელი_uuid</a> <code class="descname">protocomm_ble_name_uuid_t</code><a class="headerlink" href="protocomm.html#_CPPv425protocomm_ble_name_uuid_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>ეს სტრუქტურა აკავშირებს პროტოკომის ფენის მიერ საჭირო დამმუშავებელს UUID-ებთან, რომლებიც გამოიყენება სმარტფონიდან ან მსგავსი კლიენტური მოწყობილობიდან BLE მახასიათებლების უნიკალურად იდენტიფიცირებისთვის. </p>
</dd></dl>
<dl class="type">
<dt id="_CPPv422protocomm_ble_config_t">
<span id="_CPPv322protocomm_ble_config_t"></span><span id="_CPPv222protocomm_ble_config_t"></span><span id="protocomm_ble_config_t"></span><span class="target" id="protocomm__ble_8h_1ab9715634f44c16e350395f3b53107d62"></span><em class="property">typedef </em><em class="property">სტრუქტურა</em> <a class="reference internal" href="protocomm.html#_CPPv420protocomm_ble_config" title="protocomm_ble_config">protocomm_ble_config</a> <code class="descname">protocomm_ble_config_t</code><a class="headerlink" href="protocomm.html#_CPPv422protocomm_ble_config_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>protocomm BLE სერვისის კონფიგურაციის პარამეტრები. </p>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="provisioning.html" rel="next" title="Unified Provisioning">შემდეგი <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Provisioning API"><span class="fa fa-arrow-circle-left"></span> წინა</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        © საავტორო უფლება 2016 - 2019, Espressif Systems (შანხაი) კომპანია, შპს
      
        <span class="commit">
          რევიზია <code>f9108063</code>.
        </span>
</p>
</div>
  Built with <a href="http://sphinx-doc.org/">სფინქსი</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">თემა</a> provided by <a href="https://readthedocs.org">წაიკითხეთ დოკუმენტები</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>